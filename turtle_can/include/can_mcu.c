/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.13 Mon Jun 23 01:31:53 2025.
 */

#include <string.h>

#include "can_mcu.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t unpack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) << shift);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int can_mcu_vcu_susp_r_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_susp_r_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->susp_pot_rl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->susp_pot_rl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->susp_pot_rr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->susp_pot_rr, 8u, 0xffu);

    return (4);
}

int can_mcu_vcu_susp_r_unpack(
    struct can_mcu_vcu_susp_r_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->susp_pot_rl = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->susp_pot_rl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->susp_pot_rr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->susp_pot_rr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

int can_mcu_vcu_susp_r_init(struct can_mcu_vcu_susp_r_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_susp_r_t));

    return 0;
}

uint16_t can_mcu_vcu_susp_r_susp_pot_rl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_susp_r_susp_pot_rl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_susp_r_susp_pot_rl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_vcu_susp_r_susp_pot_rr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_susp_r_susp_pot_rr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_susp_r_susp_pot_rr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_apps_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u16(src_p->apps1_raw, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->apps1_raw, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->apps2_raw, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->apps2_raw, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_signals, 0u, 0x01u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_sup, 1u, 0x02u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_gnd, 2u, 0x04u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_out_of_range, 3u, 0x08u);

    return (5);
}

int can_mcu_dash_apps_unpack(
    struct can_mcu_dash_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->apps1_raw = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->apps1_raw |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->apps2_raw = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->apps2_raw |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->apps_sc_signals = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->apps_sc_sup = unpack_right_shift_u8(src_p[4], 1u, 0x02u);
    dst_p->apps_sc_gnd = unpack_right_shift_u8(src_p[4], 2u, 0x04u);
    dst_p->apps_out_of_range = unpack_right_shift_u8(src_p[4], 3u, 0x08u);

    return (0);
}

int can_mcu_dash_apps_init(struct can_mcu_dash_apps_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_apps_t));

    return 0;
}

uint16_t can_mcu_dash_apps_apps1_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_apps_apps1_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps1_raw_is_in_range(uint16_t value)
{
    return (value <= 1u);
}

uint16_t can_mcu_dash_apps_apps2_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_apps_apps2_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps2_raw_is_in_range(uint16_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_signals_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_signals_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_signals_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_sup_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_sup_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_sup_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_gnd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_gnd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_gnd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_out_of_range_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_out_of_range_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_out_of_range_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_vcu_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_bools_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->buzzer, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->enable, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->safe_state, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->ams, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->imd, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->mode, 5u, 0x20u);

    return (1);
}

int can_mcu_vcu_bools_unpack(
    struct can_mcu_vcu_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->buzzer = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->enable = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->safe_state = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->ams = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->imd = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->mode = unpack_right_shift_u8(src_p[0], 5u, 0x20u);

    return (0);
}

int can_mcu_vcu_bools_init(struct can_mcu_vcu_bools_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_bools_t));

    return 0;
}

uint8_t can_mcu_vcu_bools_buzzer_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_bools_buzzer_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_bools_buzzer_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_vcu_bools_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_bools_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_bools_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_vcu_bools_safe_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_bools_safe_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_bools_safe_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_vcu_bools_ams_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_bools_ams_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_bools_ams_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_vcu_bools_imd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_bools_imd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_bools_imd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_vcu_bools_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_bools_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_bools_mode_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_dash_steering_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_steering_t *src_p,
    size_t size)
{
    uint32_t steering;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&steering, &src_p->steering, sizeof(steering));
    dst_p[0] |= pack_left_shift_u32(steering, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(steering, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(steering, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(steering, 24u, 0xffu);

    return (4);
}

int can_mcu_dash_steering_unpack(
    struct can_mcu_dash_steering_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t steering;

    if (size < 4u) {
        return (-EINVAL);
    }

    steering = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->steering, &steering, sizeof(dst_p->steering));

    return (0);
}

int can_mcu_dash_steering_init(struct can_mcu_dash_steering_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_steering_t));

    return 0;
}

float can_mcu_dash_steering_steering_encode(double value)
{
    return (float)(value);
}

double can_mcu_dash_steering_steering_decode(float value)
{
    return ((double)value);
}

bool can_mcu_dash_steering_steering_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_bools_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u8(src_p->start, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->add_act, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->steering_implausibility, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->cooling_status, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->ts_off, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->rotary_active_mode, 6u, 0xc0u);
    dst_p[1] |= pack_left_shift_u8(src_p->setup, 0u, 0x0fu);
    dst_p[1] |= pack_left_shift_u8(src_p->main_menu, 4u, 0xf0u);
    dst_p[2] |= pack_left_shift_u8(src_p->sub_menu, 0u, 0x0fu);
    dst_p[2] |= pack_left_shift_u8(src_p->screen, 4u, 0xf0u);
    dst_p[3] |= pack_left_shift_u8(src_p->reset_sdc, 0u, 0x01u);

    return (4);
}

int can_mcu_dash_bools_unpack(
    struct can_mcu_dash_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->start = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->add_act = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->steering_implausibility = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->monitor = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->cooling_status = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->ts_off = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->rotary_active_mode = unpack_right_shift_u8(src_p[0], 6u, 0xc0u);
    dst_p->setup = unpack_right_shift_u8(src_p[1], 0u, 0x0fu);
    dst_p->main_menu = unpack_right_shift_u8(src_p[1], 4u, 0xf0u);
    dst_p->sub_menu = unpack_right_shift_u8(src_p[2], 0u, 0x0fu);
    dst_p->screen = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    dst_p->reset_sdc = unpack_right_shift_u8(src_p[3], 0u, 0x01u);

    return (0);
}

int can_mcu_dash_bools_init(struct can_mcu_dash_bools_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_bools_t));

    return 0;
}

uint8_t can_mcu_dash_bools_start_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_start_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_start_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_add_act_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_add_act_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_add_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_steering_implausibility_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_steering_implausibility_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_steering_implausibility_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_monitor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_monitor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_monitor_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_cooling_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_cooling_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_cooling_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_ts_off_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_ts_off_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_ts_off_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_rotary_active_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_rotary_active_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_rotary_active_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_setup_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_setup_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_setup_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_main_menu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_main_menu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_main_menu_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_sub_menu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_sub_menu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_sub_menu_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_screen_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_screen_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_screen_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_reset_sdc_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_reset_sdc_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_reset_sdc_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_dash_susp_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_susp_f_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->susp_pot_fl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->susp_pot_fl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->susp_pot_fr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->susp_pot_fr, 8u, 0xffu);

    return (4);
}

int can_mcu_dash_susp_f_unpack(
    struct can_mcu_dash_susp_f_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->susp_pot_fl = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->susp_pot_fl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->susp_pot_fr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->susp_pot_fr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

int can_mcu_dash_susp_f_init(struct can_mcu_dash_susp_f_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_susp_f_t));

    return 0;
}

uint16_t can_mcu_dash_susp_f_susp_pot_fl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_susp_pot_fl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_susp_pot_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_susp_f_susp_pot_fr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_susp_pot_fr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_susp_pot_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_adu_t *src_p,
    size_t size)
{
    uint8_t power_k_w;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    power_k_w = (uint8_t)src_p->power_k_w;
    dst_p[0] |= pack_left_shift_u8(power_k_w, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->vicor_thermistor, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->recom_thermistor, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->velocity, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->velocity, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->sensor_error, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->inverter_rpm_max_actual, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->tv_on, 0u, 0x01u);
    dst_p[7] |= pack_left_shift_u8(src_p->regen_on, 1u, 0x02u);
    dst_p[7] |= pack_left_shift_u8(src_p->tc_on, 2u, 0x04u);

    return (8);
}

int can_mcu_vcu_adu_unpack(
    struct can_mcu_vcu_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t power_k_w;

    if (size < 8u) {
        return (-EINVAL);
    }

    power_k_w = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->power_k_w = (int8_t)power_k_w;
    dst_p->vicor_thermistor = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->recom_thermistor = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->velocity = unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->velocity |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->sensor_error = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->inverter_rpm_max_actual = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->tv_on = unpack_right_shift_u8(src_p[7], 0u, 0x01u);
    dst_p->regen_on = unpack_right_shift_u8(src_p[7], 1u, 0x02u);
    dst_p->tc_on = unpack_right_shift_u8(src_p[7], 2u, 0x04u);

    return (0);
}

int can_mcu_vcu_adu_init(struct can_mcu_vcu_adu_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_adu_t));

    return 0;
}

int8_t can_mcu_vcu_adu_power_k_w_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_vcu_adu_power_k_w_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_adu_power_k_w_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_adu_vicor_thermistor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_adu_vicor_thermistor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_adu_vicor_thermistor_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_adu_recom_thermistor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_adu_recom_thermistor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_adu_recom_thermistor_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_vcu_adu_velocity_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_vcu_adu_velocity_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_adu_velocity_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_adu_sensor_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_adu_sensor_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_adu_sensor_error_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_adu_inverter_rpm_max_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_adu_inverter_rpm_max_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_adu_inverter_rpm_max_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_adu_tv_on_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_adu_tv_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_adu_tv_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_vcu_adu_regen_on_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_adu_regen_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_adu_regen_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_vcu_adu_tc_on_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_adu_tc_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_adu_tc_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_vcu_rl_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_rl_info_t *src_p,
    size_t size)
{
    uint16_t irms_rl;
    uint16_t rpm_rl;
    uint16_t torque_commanded_rl;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->igbt_rl, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->motor_temp_rl, 0u, 0xffu);
    rpm_rl = (uint16_t)src_p->rpm_rl;
    dst_p[2] |= pack_left_shift_u16(rpm_rl, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(rpm_rl, 8u, 0xffu);
    torque_commanded_rl = (uint16_t)src_p->torque_commanded_rl;
    dst_p[4] |= pack_left_shift_u16(torque_commanded_rl, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(torque_commanded_rl, 8u, 0xffu);
    irms_rl = (uint16_t)src_p->irms_rl;
    dst_p[6] |= pack_left_shift_u16(irms_rl, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(irms_rl, 8u, 0xffu);

    return (8);
}

int can_mcu_vcu_rl_info_unpack(
    struct can_mcu_vcu_rl_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t irms_rl;
    uint16_t rpm_rl;
    uint16_t torque_commanded_rl;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->igbt_rl = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->motor_temp_rl = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    rpm_rl = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    rpm_rl |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rpm_rl = (int16_t)rpm_rl;
    torque_commanded_rl = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    torque_commanded_rl |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_commanded_rl = (int16_t)torque_commanded_rl;
    irms_rl = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    irms_rl |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->irms_rl = (int16_t)irms_rl;

    return (0);
}

int can_mcu_vcu_rl_info_init(struct can_mcu_vcu_rl_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_rl_info_t));

    return 0;
}

uint8_t can_mcu_vcu_rl_info_igbt_rl_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double can_mcu_vcu_rl_info_igbt_rl_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_vcu_rl_info_igbt_rl_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_rl_info_motor_temp_rl_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double can_mcu_vcu_rl_info_motor_temp_rl_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_vcu_rl_info_motor_temp_rl_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_rl_info_rpm_rl_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_vcu_rl_info_rpm_rl_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_rl_info_rpm_rl_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_rl_info_torque_commanded_rl_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_vcu_rl_info_torque_commanded_rl_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_rl_info_torque_commanded_rl_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_rl_info_irms_rl_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_vcu_rl_info_irms_rl_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_rl_info_irms_rl_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_rr_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_rr_info_t *src_p,
    size_t size)
{
    uint16_t irms_rr;
    uint16_t rpm_rr;
    uint16_t torque_commanded_rr;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->igbt_rr, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->motor_temp_rr, 0u, 0xffu);
    rpm_rr = (uint16_t)src_p->rpm_rr;
    dst_p[2] |= pack_left_shift_u16(rpm_rr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(rpm_rr, 8u, 0xffu);
    torque_commanded_rr = (uint16_t)src_p->torque_commanded_rr;
    dst_p[4] |= pack_left_shift_u16(torque_commanded_rr, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(torque_commanded_rr, 8u, 0xffu);
    irms_rr = (uint16_t)src_p->irms_rr;
    dst_p[6] |= pack_left_shift_u16(irms_rr, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(irms_rr, 8u, 0xffu);

    return (8);
}

int can_mcu_vcu_rr_info_unpack(
    struct can_mcu_vcu_rr_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t irms_rr;
    uint16_t rpm_rr;
    uint16_t torque_commanded_rr;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->igbt_rr = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->motor_temp_rr = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    rpm_rr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    rpm_rr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rpm_rr = (int16_t)rpm_rr;
    torque_commanded_rr = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    torque_commanded_rr |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_commanded_rr = (int16_t)torque_commanded_rr;
    irms_rr = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    irms_rr |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->irms_rr = (int16_t)irms_rr;

    return (0);
}

int can_mcu_vcu_rr_info_init(struct can_mcu_vcu_rr_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_rr_info_t));

    return 0;
}

uint8_t can_mcu_vcu_rr_info_igbt_rr_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double can_mcu_vcu_rr_info_igbt_rr_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_vcu_rr_info_igbt_rr_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_rr_info_motor_temp_rr_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double can_mcu_vcu_rr_info_motor_temp_rr_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_vcu_rr_info_motor_temp_rr_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_rr_info_rpm_rr_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_vcu_rr_info_rpm_rr_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_rr_info_rpm_rr_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_rr_info_torque_commanded_rr_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_vcu_rr_info_torque_commanded_rr_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_rr_info_torque_commanded_rr_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_rr_info_irms_rr_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_vcu_rr_info_irms_rr_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_rr_info_irms_rr_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_asb_pack(
    uint8_t *dst_p,
    const struct can_mcu_asb_t *src_p,
    size_t size)
{
    uint16_t ebs_tank_pressure;
    uint8_t initial_check_step;

    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->asms_state, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->tsms_out, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->asb_led, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->initial_checked, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_tank_pressure, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_brake_pressure, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_servo_check, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_apu, 7u, 0x80u);
    initial_check_step = (uint8_t)src_p->initial_check_step;
    dst_p[1] |= pack_left_shift_u8(initial_check_step, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->service_brake_status, 0u, 0x0fu);
    dst_p[2] |= pack_left_shift_u8(src_p->ebs_status, 4u, 0xf0u);
    ebs_tank_pressure = (uint16_t)src_p->ebs_tank_pressure;
    dst_p[3] |= pack_left_shift_u16(ebs_tank_pressure, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(ebs_tank_pressure, 8u, 0xffu);

    return (5);
}

int can_mcu_asb_unpack(
    struct can_mcu_asb_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t ebs_tank_pressure;
    uint8_t initial_check_step;

    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->asms_state = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->tsms_out = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->asb_led = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->initial_checked = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->monitor_tank_pressure = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->monitor_brake_pressure = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->monitor_servo_check = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->monitor_apu = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    initial_check_step = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->initial_check_step = (int8_t)initial_check_step;
    dst_p->service_brake_status = unpack_right_shift_u8(src_p[2], 0u, 0x0fu);
    dst_p->ebs_status = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    ebs_tank_pressure = unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    ebs_tank_pressure |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->ebs_tank_pressure = (int16_t)ebs_tank_pressure;

    return (0);
}

int can_mcu_asb_init(struct can_mcu_asb_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_asb_t));

    return 0;
}

uint8_t can_mcu_asb_asms_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_asms_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_asms_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_tsms_out_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_tsms_out_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_tsms_out_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_asb_led_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_asb_led_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_asb_led_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_initial_checked_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_initial_checked_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_initial_checked_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_tank_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_tank_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_tank_pressure_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_brake_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_brake_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_brake_pressure_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_servo_check_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_servo_check_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_servo_check_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_apu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_apu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_apu_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int8_t can_mcu_asb_initial_check_step_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_asb_initial_check_step_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_initial_check_step_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_asb_service_brake_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_service_brake_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_service_brake_status_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_asb_ebs_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_ebs_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_ebs_status_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

int16_t can_mcu_asb_ebs_tank_pressure_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_asb_ebs_tank_pressure_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_asb_ebs_tank_pressure_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_apu_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_command_t *src_p,
    size_t size)
{
    uint32_t throttle_brake_commanded;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&throttle_brake_commanded, &src_p->throttle_brake_commanded, sizeof(throttle_brake_commanded));
    dst_p[0] |= pack_left_shift_u32(throttle_brake_commanded, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(throttle_brake_commanded, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(throttle_brake_commanded, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(throttle_brake_commanded, 24u, 0xffu);

    return (4);
}

int can_mcu_apu_command_unpack(
    struct can_mcu_apu_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t throttle_brake_commanded;

    if (size < 4u) {
        return (-EINVAL);
    }

    throttle_brake_commanded = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->throttle_brake_commanded, &throttle_brake_commanded, sizeof(dst_p->throttle_brake_commanded));

    return (0);
}

int can_mcu_apu_command_init(struct can_mcu_apu_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_command_t));

    return 0;
}

float can_mcu_apu_command_throttle_brake_commanded_encode(double value)
{
    return (float)(value);
}

double can_mcu_apu_command_throttle_brake_commanded_decode(float value)
{
    return ((double)value);
}

bool can_mcu_apu_command_throttle_brake_commanded_is_in_range(float value)
{
    return ((value >= -1.0f) && (value <= 1.0f));
}

int can_mcu_apu_state_mission_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_state_mission_t *src_p,
    size_t size)
{
    uint8_t as_mission;

    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    as_mission = (uint8_t)src_p->as_mission;
    dst_p[0] |= pack_left_shift_u8(as_mission, 0u, 0x07u);
    dst_p[0] |= pack_left_shift_u8(src_p->as_state, 3u, 0x38u);
    dst_p[0] |= pack_left_shift_u8(src_p->as_set_finished, 6u, 0x40u);

    return (1);
}

int can_mcu_apu_state_mission_unpack(
    struct can_mcu_apu_state_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t as_mission;

    if (size < 1u) {
        return (-EINVAL);
    }

    as_mission = unpack_right_shift_u8(src_p[0], 0u, 0x07u);

    if ((as_mission & (1u << 2)) != 0u) {
        as_mission |= 0xf8u;
    }

    dst_p->as_mission = (int8_t)as_mission;
    dst_p->as_state = unpack_right_shift_u8(src_p[0], 3u, 0x38u);
    dst_p->as_set_finished = unpack_right_shift_u8(src_p[0], 6u, 0x40u);

    return (0);
}

int can_mcu_apu_state_mission_init(struct can_mcu_apu_state_mission_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_state_mission_t));

    return 0;
}

int8_t can_mcu_apu_state_mission_as_mission_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_apu_state_mission_as_mission_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_mission_is_in_range(int8_t value)
{
    return ((value >= -4) && (value <= 3));
}

uint8_t can_mcu_apu_state_mission_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_state_mission_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_state_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t can_mcu_apu_state_mission_as_set_finished_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_state_mission_as_set_finished_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_set_finished_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_dash_ami_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_ami_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->ami, 0u, 0xffu);

    return (1);
}

int can_mcu_dash_ami_unpack(
    struct can_mcu_dash_ami_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->ami = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int can_mcu_dash_ami_init(struct can_mcu_dash_ami_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_ami_t));

    return 0;
}

uint8_t can_mcu_dash_ami_ami_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_ami_ami_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_ami_ami_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_idc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_idc_t *src_p,
    size_t size)
{
    uint32_t idc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->idc_measurement_error, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->system_error, 7u, 0x80u);
    idc = (uint32_t)src_p->idc;
    dst_p[2] |= pack_left_shift_u32(idc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(idc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(idc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(idc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_idc_unpack(
    struct can_mcu_isabellen_idc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t idc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->idc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->system_error = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    idc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->idc = (int32_t)idc;

    return (0);
}

int can_mcu_isabellen_idc_init(struct can_mcu_isabellen_idc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_idc_t));

    return 0;
}

uint8_t can_mcu_isabellen_idc_idc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_idc_idc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_idc_idc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_isabellen_idc_system_error_encode(double value)
{
    return (uint8_t)(value / 7.0);
}

double can_mcu_isabellen_idc_system_error_decode(uint8_t value)
{
    return ((double)value * 7.0);
}

bool can_mcu_isabellen_idc_system_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_idc_idc_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_isabellen_idc_idc_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_isabellen_idc_idc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_vdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_vdc_t *src_p,
    size_t size)
{
    uint32_t vdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->vdc_measurement_error, 5u, 0x20u);
    vdc = (uint32_t)src_p->vdc;
    dst_p[2] |= pack_left_shift_u32(vdc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vdc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(vdc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vdc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_vdc_unpack(
    struct can_mcu_isabellen_vdc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->vdc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    vdc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->vdc = (int32_t)vdc;

    return (0);
}

int can_mcu_isabellen_vdc_init(struct can_mcu_isabellen_vdc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_vdc_t));

    return 0;
}

uint8_t can_mcu_isabellen_vdc_vdc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_vdc_vdc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_vdc_vdc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_vdc_vdc_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_isabellen_vdc_vdc_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_isabellen_vdc_vdc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_pdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_pdc_t *src_p,
    size_t size)
{
    uint32_t pdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->pdc_measurement_error, 5u, 0x20u);
    pdc = (uint32_t)src_p->pdc;
    dst_p[2] |= pack_left_shift_u32(pdc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pdc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(pdc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(pdc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_pdc_unpack(
    struct can_mcu_isabellen_pdc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->pdc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    pdc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->pdc = (int32_t)pdc;

    return (0);
}

int can_mcu_isabellen_pdc_init(struct can_mcu_isabellen_pdc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_pdc_t));

    return 0;
}

uint8_t can_mcu_isabellen_pdc_pdc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_pdc_pdc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_pdc_pdc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_pdc_pdc_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_isabellen_pdc_pdc_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_pdc_pdc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_energy_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_energy_t *src_p,
    size_t size)
{
    uint32_t energy;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->energy_measurement_error, 5u, 0x20u);
    energy = (uint32_t)src_p->energy;
    dst_p[2] |= pack_left_shift_u32(energy, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(energy, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(energy, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(energy, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_energy_unpack(
    struct can_mcu_isabellen_energy_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t energy;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->energy_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    energy = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->energy = (int32_t)energy;

    return (0);
}

int can_mcu_isabellen_energy_init(struct can_mcu_isabellen_energy_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_energy_t));

    return 0;
}

uint8_t can_mcu_isabellen_energy_energy_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_energy_energy_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_energy_energy_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_energy_energy_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_isabellen_energy_energy_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_energy_energy_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_1_t *src_p,
    size_t size)
{
    uint8_t modes_of_operation_display;

    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u16(src_p->status_word, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->status_word, 8u, 0xffu);
    modes_of_operation_display = (uint8_t)src_p->modes_of_operation_display;
    dst_p[2] |= pack_left_shift_u8(modes_of_operation_display, 0u, 0xffu);

    return (3);
}

int can_mcu_bldc_tx_1_unpack(
    struct can_mcu_bldc_tx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t modes_of_operation_display;

    if (size < 3u) {
        return (-EINVAL);
    }

    dst_p->status_word = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->status_word |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    modes_of_operation_display = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->modes_of_operation_display = (int8_t)modes_of_operation_display;

    return (0);
}

int can_mcu_bldc_tx_1_init(struct can_mcu_bldc_tx_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_tx_1_t));

    return 0;
}

uint16_t can_mcu_bldc_tx_1_status_word_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_bldc_tx_1_status_word_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_1_status_word_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_bldc_tx_1_modes_of_operation_display_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_bldc_tx_1_modes_of_operation_display_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_1_modes_of_operation_display_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_1_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u16(src_p->controlword, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->controlword, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->mode_of_operation, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->motor_drive_submode_select, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 8u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 24u, 0xffu);

    return (7);
}

int can_mcu_bldc_rx_1_unpack(
    struct can_mcu_bldc_rx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    dst_p->controlword = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->controlword |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->mode_of_operation = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->motor_drive_submode_select = unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[4], 8u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[6], 24u, 0xffu);

    return (0);
}

int can_mcu_bldc_rx_1_init(struct can_mcu_bldc_rx_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_rx_1_t));

    return 0;
}

uint16_t can_mcu_bldc_rx_1_controlword_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_bldc_rx_1_controlword_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_controlword_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_bldc_rx_1_mode_of_operation_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_bldc_rx_1_mode_of_operation_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_mode_of_operation_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_bldc_rx_1_motor_drive_submode_select_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_1_motor_drive_submode_select_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_motor_drive_submode_select_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_2_t *src_p,
    size_t size)
{
    uint32_t target_position;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    target_position = (uint32_t)src_p->target_position;
    dst_p[0] |= pack_left_shift_u32(target_position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(target_position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(target_position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(target_position, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->profile_velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->profile_velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->profile_velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->profile_velocity, 24u, 0xffu);

    return (8);
}

int can_mcu_bldc_rx_2_unpack(
    struct can_mcu_bldc_rx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t target_position;

    if (size < 8u) {
        return (-EINVAL);
    }

    target_position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->target_position = (int32_t)target_position;
    dst_p->profile_velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int can_mcu_bldc_rx_2_init(struct can_mcu_bldc_rx_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_rx_2_t));

    return 0;
}

int32_t can_mcu_bldc_rx_2_target_position_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_bldc_rx_2_target_position_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_2_target_position_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_bldc_rx_2_profile_velocity_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_2_profile_velocity_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_2_profile_velocity_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_2_t *src_p,
    size_t size)
{
    uint32_t position_actual_value;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    position_actual_value = (uint32_t)src_p->position_actual_value;
    dst_p[0] |= pack_left_shift_u32(position_actual_value, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_actual_value, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_actual_value, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position_actual_value, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_tx_2_unpack(
    struct can_mcu_bldc_tx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position_actual_value;

    if (size < 4u) {
        return (-EINVAL);
    }

    position_actual_value = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->position_actual_value = (int32_t)position_actual_value;

    return (0);
}

int can_mcu_bldc_tx_2_init(struct can_mcu_bldc_tx_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_tx_2_t));

    return 0;
}

int32_t can_mcu_bldc_tx_2_position_actual_value_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_bldc_tx_2_position_actual_value_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_2_position_actual_value_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_3_t *src_p,
    size_t size)
{
    uint16_t velocity_actual_value;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    velocity_actual_value = (uint16_t)src_p->velocity_actual_value;
    dst_p[0] |= pack_left_shift_u16(velocity_actual_value, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_actual_value, 8u, 0xffu);

    return (2);
}

int can_mcu_bldc_tx_3_unpack(
    struct can_mcu_bldc_tx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_actual_value;

    if (size < 2u) {
        return (-EINVAL);
    }

    velocity_actual_value = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_actual_value |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_actual_value = (int16_t)velocity_actual_value;

    return (0);
}

int can_mcu_bldc_tx_3_init(struct can_mcu_bldc_tx_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_tx_3_t));

    return 0;
}

int16_t can_mcu_bldc_tx_3_velocity_actual_value_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_bldc_tx_3_velocity_actual_value_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_3_velocity_actual_value_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_3_t *src_p,
    size_t size)
{
    uint16_t target_velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    target_velocity = (uint16_t)src_p->target_velocity;
    dst_p[0] |= pack_left_shift_u16(target_velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(target_velocity, 8u, 0xffu);

    return (2);
}

int can_mcu_bldc_rx_3_unpack(
    struct can_mcu_bldc_rx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t target_velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    target_velocity = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    target_velocity |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->target_velocity = (int16_t)target_velocity;

    return (0);
}

int can_mcu_bldc_rx_3_init(struct can_mcu_bldc_rx_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_rx_3_t));

    return 0;
}

int16_t can_mcu_bldc_rx_3_target_velocity_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_bldc_rx_3_target_velocity_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_3_target_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_4_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->digital_input, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->digital_input, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->digital_input, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->digital_input, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_tx_4_unpack(
    struct can_mcu_bldc_tx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->digital_input = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

int can_mcu_bldc_tx_4_init(struct can_mcu_bldc_tx_4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_tx_4_t));

    return 0;
}

uint32_t can_mcu_bldc_tx_4_digital_input_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_tx_4_digital_input_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_4_digital_input_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_4_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->digital_output, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->digital_output, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->digital_output, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->digital_output, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_rx_4_unpack(
    struct can_mcu_bldc_rx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->digital_output = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

int can_mcu_bldc_rx_4_init(struct can_mcu_bldc_rx_4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_rx_4_t));

    return 0;
}

uint32_t can_mcu_bldc_rx_4_digital_output_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_4_digital_output_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_4_digital_output_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_steering_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_steering_command_t *src_p,
    size_t size)
{
    uint16_t velocity_target;
    uint32_t position_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position_target, &src_p->position_target, sizeof(position_target));
    dst_p[0] |= pack_left_shift_u32(position_target, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_target, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_target, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position_target, 24u, 0xffu);
    velocity_target = (uint16_t)src_p->velocity_target;
    dst_p[4] |= pack_left_shift_u16(velocity_target, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_target, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->steering_mode, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->steering_mode, 8u, 0xffu);

    return (8);
}

int can_mcu_dash_steering_command_unpack(
    struct can_mcu_dash_steering_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_target;
    uint32_t position_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    position_target = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position_target, &position_target, sizeof(dst_p->position_target));
    velocity_target = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_target |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_target = (int16_t)velocity_target;
    dst_p->steering_mode = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->steering_mode |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_dash_steering_command_init(struct can_mcu_dash_steering_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_steering_command_t));

    return 0;
}

float can_mcu_dash_steering_command_position_target_encode(double value)
{
    return (float)(value);
}

double can_mcu_dash_steering_command_position_target_decode(float value)
{
    return ((double)value);
}

bool can_mcu_dash_steering_command_position_target_is_in_range(float value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_dash_steering_command_velocity_target_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_dash_steering_command_velocity_target_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_steering_command_velocity_target_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_steering_command_steering_mode_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_steering_command_steering_mode_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_steering_command_steering_mode_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_apu_tuning_vcu_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_tuning_vcu_t *src_p,
    size_t size)
{
    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u16(src_p->value, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->value, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->index, 0u, 0x07u);

    return (3);
}

int can_mcu_apu_tuning_vcu_unpack(
    struct can_mcu_apu_tuning_vcu_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 3u) {
        return (-EINVAL);
    }

    dst_p->value = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->value |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->index = unpack_right_shift_u8(src_p[2], 0u, 0x07u);

    return (0);
}

int can_mcu_apu_tuning_vcu_init(struct can_mcu_apu_tuning_vcu_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_tuning_vcu_t));

    return 0;
}

uint16_t can_mcu_apu_tuning_vcu_value_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_apu_tuning_vcu_value_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_tuning_vcu_value_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_apu_tuning_vcu_index_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_tuning_vcu_index_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_tuning_vcu_index_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

int can_mcu_bms_min_max_s1_s2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s1_s2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s1_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s1_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s1_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s1_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s2_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s2_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s2_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s2_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s1_s2_unpack(
    struct can_mcu_bms_min_max_s1_s2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s1_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s1_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s1_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s1_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s2_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s2_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s2_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s2_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s1_s2_init(struct can_mcu_bms_min_max_s1_s2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s1_s2_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s1_s2_s1_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_s1_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_s1_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s1_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_s1_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_s1_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s2_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_s2_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_s2_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s2_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_s2_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_s2_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s3_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s3_s4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s3_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s3_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s3_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s3_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s4_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s4_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s4_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s4_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s3_s4_unpack(
    struct can_mcu_bms_min_max_s3_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s3_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s3_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s3_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s3_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s4_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s4_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s4_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s4_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s3_s4_init(struct can_mcu_bms_min_max_s3_s4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s3_s4_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s3_s4_s3_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_s3_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_s3_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s3_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_s3_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_s3_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s4_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_s4_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_s4_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s4_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_s4_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_s4_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s5_s6_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s5_s6_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s5_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s5_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s5_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s5_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s6_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s6_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s6_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s6_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s5_s6_unpack(
    struct can_mcu_bms_min_max_s5_s6_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s5_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s5_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s5_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s5_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s6_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s6_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s6_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s6_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s5_s6_init(struct can_mcu_bms_min_max_s5_s6_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s5_s6_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s5_s6_s5_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_s5_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_s5_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s5_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_s5_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_s5_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s6_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_s6_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_s6_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s6_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_s6_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_s6_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s7_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s7_s8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s7_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s7_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s7_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s7_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s8_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s8_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s8_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s8_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s7_s8_unpack(
    struct can_mcu_bms_min_max_s7_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s7_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s7_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s7_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s7_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s8_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s8_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s8_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s8_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s7_s8_init(struct can_mcu_bms_min_max_s7_s8_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s7_s8_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s7_s8_s7_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_s7_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_s7_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s7_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_s7_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_s7_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s8_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_s8_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_s8_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s8_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_s8_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_s8_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s9_s10_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s9_s10_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s9_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s9_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s9_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s9_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s10_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s10_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s10_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s10_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s9_s10_unpack(
    struct can_mcu_bms_min_max_s9_s10_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s9_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s9_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s9_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s9_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s10_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s10_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s10_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s10_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s9_s10_init(struct can_mcu_bms_min_max_s9_s10_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s9_s10_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s9_s10_s9_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_s9_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_s9_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s9_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_s9_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_s9_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s10_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_s10_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_s10_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s10_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_s10_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_s10_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s11_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s11_s12_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s11_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s11_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s11_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s11_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s12_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s12_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s12_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s12_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s11_s12_unpack(
    struct can_mcu_bms_min_max_s11_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s11_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s11_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s11_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s11_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s12_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s12_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s12_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s12_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s11_s12_init(struct can_mcu_bms_min_max_s11_s12_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s11_s12_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s11_s12_s11_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_s11_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_s11_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s11_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_s11_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_s11_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s12_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_s12_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_s12_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s12_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_s12_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_s12_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s1_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s1_s4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s1_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s1_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s2_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s2_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s3_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s3_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s4_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s4_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s1_s4_unpack(
    struct can_mcu_bms_max_temp_s1_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s1_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s1_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s2_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s2_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s3_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s3_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s4_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s4_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_max_temp_s1_s4_init(struct can_mcu_bms_max_temp_s1_s4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_max_temp_s1_s4_t));

    return 0;
}

uint16_t can_mcu_bms_max_temp_s1_s4_s1_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s1_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s1_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s2_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s2_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s2_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s3_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s3_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s3_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s4_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s4_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s4_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s5_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s5_s8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s5_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s5_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s6_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s6_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s7_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s7_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s8_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s8_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s5_s8_unpack(
    struct can_mcu_bms_max_temp_s5_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s5_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s5_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s6_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s6_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s7_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s7_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s8_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s8_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_max_temp_s5_s8_init(struct can_mcu_bms_max_temp_s5_s8_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_max_temp_s5_s8_t));

    return 0;
}

uint16_t can_mcu_bms_max_temp_s5_s8_s5_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s5_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s5_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s6_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s6_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s6_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s7_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s7_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s7_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s8_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s8_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s8_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s9_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s9_s12_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s9_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s9_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s10_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s10_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s11_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s11_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s12_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s12_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s9_s12_unpack(
    struct can_mcu_bms_max_temp_s9_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s9_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s9_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s10_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s10_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s11_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s11_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s12_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s12_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_max_temp_s9_s12_init(struct can_mcu_bms_max_temp_s9_s12_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_max_temp_s9_s12_t));

    return 0;
}

uint16_t can_mcu_bms_max_temp_s9_s12_s9_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s9_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s9_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s10_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s10_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s10_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s11_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s11_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s11_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s12_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s12_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s12_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_apu_temp_tha_enhmerwthei_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_temp_tha_enhmerwthei_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->cpu_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->cpu_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->gpu_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->gpu_temp, 8u, 0xffu);

    return (4);
}

int can_mcu_apu_temp_tha_enhmerwthei_unpack(
    struct can_mcu_apu_temp_tha_enhmerwthei_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->cpu_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->cpu_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->gpu_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->gpu_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

int can_mcu_apu_temp_tha_enhmerwthei_init(struct can_mcu_apu_temp_tha_enhmerwthei_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_temp_tha_enhmerwthei_t));

    return 0;
}

uint16_t can_mcu_apu_temp_tha_enhmerwthei_cpu_temp_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_apu_temp_tha_enhmerwthei_cpu_temp_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_temp_tha_enhmerwthei_cpu_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_apu_temp_tha_enhmerwthei_gpu_temp_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_apu_temp_tha_enhmerwthei_gpu_temp_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_temp_tha_enhmerwthei_gpu_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_brake_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_brake_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u16(src_p->brake_pressure_front, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->brake_pressure_front, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->brake_pressure_rear, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->brake_pressure_rear, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_sc_gnd, 0u, 0x01u);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_sc_sup, 1u, 0x02u);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_out_of_range, 2u, 0x04u);

    return (5);
}

int can_mcu_dash_brake_unpack(
    struct can_mcu_dash_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->brake_pressure_front = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->brake_pressure_front |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->brake_pressure_rear = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->brake_pressure_rear |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->brake_sc_gnd = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->brake_sc_sup = unpack_right_shift_u8(src_p[4], 1u, 0x02u);
    dst_p->brake_out_of_range = unpack_right_shift_u8(src_p[4], 2u, 0x04u);

    return (0);
}

int can_mcu_dash_brake_init(struct can_mcu_dash_brake_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_brake_t));

    return 0;
}

uint16_t can_mcu_dash_brake_brake_pressure_front_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_dash_brake_brake_pressure_front_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_dash_brake_brake_pressure_front_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_brake_brake_pressure_rear_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_dash_brake_brake_pressure_rear_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_dash_brake_brake_pressure_rear_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dash_brake_brake_sc_gnd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_sc_gnd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_sc_gnd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_brake_brake_sc_sup_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_sc_sup_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_sc_sup_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_brake_brake_out_of_range_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_out_of_range_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_out_of_range_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_isabellen_16_bit_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_16_bit_t *src_p,
    size_t size)
{
    uint16_t idc_16_bit;
    uint16_t pdc_16_bit;
    uint16_t vdc_16_bit;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    vdc_16_bit = (uint16_t)src_p->vdc_16_bit;
    dst_p[0] |= pack_left_shift_u16(vdc_16_bit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(vdc_16_bit, 8u, 0xffu);
    pdc_16_bit = (uint16_t)src_p->pdc_16_bit;
    dst_p[2] |= pack_left_shift_u16(pdc_16_bit, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(pdc_16_bit, 8u, 0xffu);
    idc_16_bit = (uint16_t)src_p->idc_16_bit;
    dst_p[4] |= pack_left_shift_u16(idc_16_bit, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(idc_16_bit, 8u, 0xffu);

    return (8);
}

int can_mcu_isabellen_16_bit_unpack(
    struct can_mcu_isabellen_16_bit_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t idc_16_bit;
    uint16_t pdc_16_bit;
    uint16_t vdc_16_bit;

    if (size < 8u) {
        return (-EINVAL);
    }

    vdc_16_bit = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    vdc_16_bit |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->vdc_16_bit = (int16_t)vdc_16_bit;
    pdc_16_bit = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    pdc_16_bit |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->pdc_16_bit = (int16_t)pdc_16_bit;
    idc_16_bit = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    idc_16_bit |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->idc_16_bit = (int16_t)idc_16_bit;

    return (0);
}

int can_mcu_isabellen_16_bit_init(struct can_mcu_isabellen_16_bit_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_16_bit_t));

    return 0;
}

int16_t can_mcu_isabellen_16_bit_vdc_16_bit_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_mcu_isabellen_16_bit_vdc_16_bit_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_isabellen_16_bit_vdc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_isabellen_16_bit_pdc_16_bit_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_isabellen_16_bit_pdc_16_bit_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_16_bit_pdc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_isabellen_16_bit_idc_16_bit_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_isabellen_16_bit_idc_16_bit_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_isabellen_16_bit_idc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_apps_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u16(src_p->apps, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->apps, 8u, 0xffu);

    return (2);
}

int can_mcu_vcu_apps_unpack(
    struct can_mcu_vcu_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->apps = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->apps |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    return (0);
}

int can_mcu_vcu_apps_init(struct can_mcu_vcu_apps_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_apps_t));

    return 0;
}

uint16_t can_mcu_vcu_apps_apps_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_apps_apps_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_apps_apps_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_res_status_pack(
    uint8_t *dst_p,
    const struct can_mcu_res_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->stop, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->toggle, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->button, 2u, 0x04u);
    dst_p[6] |= pack_left_shift_u8(src_p->signal_strength, 0u, 0xffu);

    return (8);
}

int can_mcu_res_status_unpack(
    struct can_mcu_res_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->stop = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->toggle = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->button = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->signal_strength = unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

int can_mcu_res_status_init(struct can_mcu_res_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_res_status_t));

    return 0;
}

uint8_t can_mcu_res_status_stop_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_res_status_stop_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_res_status_stop_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_res_status_toggle_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_res_status_toggle_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_res_status_toggle_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_res_status_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_res_status_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_res_status_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_res_status_signal_strength_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_res_status_signal_strength_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_res_status_signal_strength_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

int can_mcu_apu_res_init_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_res_init_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->requested_state, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->addresed_node, 0u, 0xffu);

    return (2);
}

int can_mcu_apu_res_init_unpack(
    struct can_mcu_apu_res_init_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->requested_state = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->addresed_node = unpack_right_shift_u8(src_p[1], 0u, 0xffu);

    return (0);
}

int can_mcu_apu_res_init_init(struct can_mcu_apu_res_init_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_res_init_t));

    return 0;
}

uint8_t can_mcu_apu_res_init_requested_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_res_init_requested_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_res_init_requested_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_apu_res_init_addresed_node_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_res_init_addresed_node_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_res_init_addresed_node_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_tuning_vcu_general_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_tuning_vcu_general_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u16(src_p->index, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->index, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(src_p->value, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->value, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->value, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->value, 24u, 0xffu);

    return (6);
}

int can_mcu_dash_tuning_vcu_general_unpack(
    struct can_mcu_dash_tuning_vcu_general_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->index = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->index |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->value = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);

    return (0);
}

int can_mcu_dash_tuning_vcu_general_init(struct can_mcu_dash_tuning_vcu_general_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_tuning_vcu_general_t));

    return 0;
}

uint16_t can_mcu_dash_tuning_vcu_general_index_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_tuning_vcu_general_index_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_tuning_vcu_general_index_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_dash_tuning_vcu_general_value_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_dash_tuning_vcu_general_value_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_dash_tuning_vcu_general_value_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_tuning_vcu_control_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_tuning_vcu_control_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u16(src_p->index, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->index, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(src_p->value, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->value, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->value, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->value, 24u, 0xffu);

    return (6);
}

int can_mcu_dash_tuning_vcu_control_unpack(
    struct can_mcu_dash_tuning_vcu_control_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->index = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->index |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->value = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);

    return (0);
}

int can_mcu_dash_tuning_vcu_control_init(struct can_mcu_dash_tuning_vcu_control_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_tuning_vcu_control_t));

    return 0;
}

uint16_t can_mcu_dash_tuning_vcu_control_index_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_tuning_vcu_control_index_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_tuning_vcu_control_index_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_dash_tuning_vcu_control_value_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_dash_tuning_vcu_control_value_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_dash_tuning_vcu_control_value_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_adu_t *src_p,
    size_t size)
{
    uint16_t steering_16bit;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    steering_16bit = (uint16_t)src_p->steering_16bit;
    dst_p[0] |= pack_left_shift_u16(steering_16bit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(steering_16bit, 8u, 0xffu);

    return (2);
}

int can_mcu_dash_adu_unpack(
    struct can_mcu_dash_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t steering_16bit;

    if (size < 2u) {
        return (-EINVAL);
    }

    steering_16bit = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    steering_16bit |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->steering_16bit = (int16_t)steering_16bit;

    return (0);
}

int can_mcu_dash_adu_init(struct can_mcu_dash_adu_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_adu_t));

    return 0;
}

int16_t can_mcu_dash_adu_steering_16bit_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_dash_adu_steering_16bit_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_adu_steering_16bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_fl_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_fl_info_t *src_p,
    size_t size)
{
    uint16_t irms_fl;
    uint16_t rpm_fl;
    uint16_t torque_commanded_fl;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->igbt_fl, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->motor_temp_fl, 0u, 0xffu);
    rpm_fl = (uint16_t)src_p->rpm_fl;
    dst_p[2] |= pack_left_shift_u16(rpm_fl, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(rpm_fl, 8u, 0xffu);
    torque_commanded_fl = (uint16_t)src_p->torque_commanded_fl;
    dst_p[4] |= pack_left_shift_u16(torque_commanded_fl, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(torque_commanded_fl, 8u, 0xffu);
    irms_fl = (uint16_t)src_p->irms_fl;
    dst_p[6] |= pack_left_shift_u16(irms_fl, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(irms_fl, 8u, 0xffu);

    return (8);
}

int can_mcu_vcu_fl_info_unpack(
    struct can_mcu_vcu_fl_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t irms_fl;
    uint16_t rpm_fl;
    uint16_t torque_commanded_fl;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->igbt_fl = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->motor_temp_fl = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    rpm_fl = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    rpm_fl |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rpm_fl = (int16_t)rpm_fl;
    torque_commanded_fl = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    torque_commanded_fl |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_commanded_fl = (int16_t)torque_commanded_fl;
    irms_fl = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    irms_fl |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->irms_fl = (int16_t)irms_fl;

    return (0);
}

int can_mcu_vcu_fl_info_init(struct can_mcu_vcu_fl_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_fl_info_t));

    return 0;
}

uint8_t can_mcu_vcu_fl_info_igbt_fl_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double can_mcu_vcu_fl_info_igbt_fl_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_vcu_fl_info_igbt_fl_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_fl_info_motor_temp_fl_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double can_mcu_vcu_fl_info_motor_temp_fl_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_vcu_fl_info_motor_temp_fl_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_fl_info_rpm_fl_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_vcu_fl_info_rpm_fl_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_fl_info_rpm_fl_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_fl_info_torque_commanded_fl_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_vcu_fl_info_torque_commanded_fl_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_fl_info_torque_commanded_fl_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_fl_info_irms_fl_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_vcu_fl_info_irms_fl_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_fl_info_irms_fl_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_fr_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_fr_info_t *src_p,
    size_t size)
{
    uint16_t irms_fr;
    uint16_t rpm_fr;
    uint16_t torque_commanded_fr;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->igbt_fr, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->motor_temp_fr, 0u, 0xffu);
    rpm_fr = (uint16_t)src_p->rpm_fr;
    dst_p[2] |= pack_left_shift_u16(rpm_fr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(rpm_fr, 8u, 0xffu);
    torque_commanded_fr = (uint16_t)src_p->torque_commanded_fr;
    dst_p[4] |= pack_left_shift_u16(torque_commanded_fr, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(torque_commanded_fr, 8u, 0xffu);
    irms_fr = (uint16_t)src_p->irms_fr;
    dst_p[6] |= pack_left_shift_u16(irms_fr, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(irms_fr, 8u, 0xffu);

    return (8);
}

int can_mcu_vcu_fr_info_unpack(
    struct can_mcu_vcu_fr_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t irms_fr;
    uint16_t rpm_fr;
    uint16_t torque_commanded_fr;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->igbt_fr = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->motor_temp_fr = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    rpm_fr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    rpm_fr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rpm_fr = (int16_t)rpm_fr;
    torque_commanded_fr = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    torque_commanded_fr |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_commanded_fr = (int16_t)torque_commanded_fr;
    irms_fr = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    irms_fr |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->irms_fr = (int16_t)irms_fr;

    return (0);
}

int can_mcu_vcu_fr_info_init(struct can_mcu_vcu_fr_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_fr_info_t));

    return 0;
}

uint8_t can_mcu_vcu_fr_info_igbt_fr_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double can_mcu_vcu_fr_info_igbt_fr_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_vcu_fr_info_igbt_fr_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_vcu_fr_info_motor_temp_fr_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double can_mcu_vcu_fr_info_motor_temp_fr_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_vcu_fr_info_motor_temp_fr_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_fr_info_rpm_fr_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_vcu_fr_info_rpm_fr_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_fr_info_rpm_fr_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_fr_info_torque_commanded_fr_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_vcu_fr_info_torque_commanded_fr_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_fr_info_torque_commanded_fr_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_fr_info_irms_fr_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_vcu_fr_info_irms_fr_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_vcu_fr_info_irms_fr_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_sdc_detection_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_sdc_detection_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->before_inertia, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->after_bspd, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->before_tsms, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->after_res, 3u, 0x08u);

    return (1);
}

int can_mcu_dash_sdc_detection_unpack(
    struct can_mcu_dash_sdc_detection_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->before_inertia = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->after_bspd = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->before_tsms = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->after_res = unpack_right_shift_u8(src_p[0], 3u, 0x08u);

    return (0);
}

int can_mcu_dash_sdc_detection_init(struct can_mcu_dash_sdc_detection_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_sdc_detection_t));

    return 0;
}

uint8_t can_mcu_dash_sdc_detection_before_inertia_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_sdc_detection_before_inertia_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_sdc_detection_before_inertia_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_sdc_detection_after_bspd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_sdc_detection_after_bspd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_sdc_detection_after_bspd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_sdc_detection_before_tsms_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_sdc_detection_before_tsms_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_sdc_detection_before_tsms_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_sdc_detection_after_res_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_sdc_detection_after_res_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_sdc_detection_after_res_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_vcu_servo_control_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_servo_control_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->servo_control, 0u, 0xffu);

    return (1);
}

int can_mcu_vcu_servo_control_unpack(
    struct can_mcu_vcu_servo_control_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->servo_control = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int can_mcu_vcu_servo_control_init(struct can_mcu_vcu_servo_control_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_servo_control_t));

    return 0;
}

uint8_t can_mcu_vcu_servo_control_servo_control_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_vcu_servo_control_servo_control_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_servo_control_servo_control_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_pos_alt_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *src_p,
    size_t size)
{
    uint16_t undulation;
    uint32_t altitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    altitude = (uint32_t)src_p->altitude;
    dst_p[0] |= pack_left_shift_u32(altitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(altitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(altitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(altitude, 24u, 0xffu);
    undulation = (uint16_t)src_p->undulation;
    dst_p[4] |= pack_left_shift_u16(undulation, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(undulation, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->num_sv, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->diff_corr_age, 0u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_gps1_pos_alt_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t undulation;
    uint32_t altitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    altitude = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->altitude = (int32_t)altitude;
    undulation = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    undulation |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->undulation = (int16_t)undulation;
    dst_p->num_sv = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->diff_corr_age = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_pos_alt_init(struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t));

    return 0;
}

int32_t can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_is_in_range(int32_t value)
{
    return ((value >= -2147480000) && (value <= 2147480000));
}

int16_t can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_encode(double value)
{
    return (int16_t)(value / 0.005);
}

double can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_decode(int16_t value)
{
    return ((double)value * 0.005);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_pos_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_pos_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    latitude = (uint32_t)src_p->latitude;
    dst_p[0] |= pack_left_shift_u32(latitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(latitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(latitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(latitude, 24u, 0xffu);
    longitude = (uint32_t)src_p->longitude;
    dst_p[4] |= pack_left_shift_u32(longitude, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(longitude, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(longitude, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(longitude, 24u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_gps1_pos_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    latitude = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->latitude = (int32_t)latitude;
    longitude = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    dst_p->longitude = (int32_t)longitude;

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_pos_init(struct can_mcu_sbg_ecan_msg_gps1_pos_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_pos_t));

    return 0;
}

int32_t can_mcu_sbg_ecan_msg_gps1_pos_latitude_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double can_mcu_sbg_ecan_msg_gps1_pos_latitude_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_latitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int32_t can_mcu_sbg_ecan_msg_gps1_pos_longitude_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double can_mcu_sbg_ecan_msg_gps1_pos_longitude_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_longitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_vel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_vel_t *src_p,
    size_t size)
{
    uint16_t velocity_d;
    uint16_t velocity_e;
    uint16_t velocity_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    velocity_n = (uint16_t)src_p->velocity_n;
    dst_p[0] |= pack_left_shift_u16(velocity_n, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_n, 8u, 0xffu);
    velocity_e = (uint16_t)src_p->velocity_e;
    dst_p[2] |= pack_left_shift_u16(velocity_e, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(velocity_e, 8u, 0xffu);
    velocity_d = (uint16_t)src_p->velocity_d;
    dst_p[4] |= pack_left_shift_u16(velocity_d, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_d, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_gps1_vel_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_d;
    uint16_t velocity_e;
    uint16_t velocity_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    velocity_n = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_n |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_n = (int16_t)velocity_n;
    velocity_e = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    velocity_e |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->velocity_e = (int16_t)velocity_e;
    velocity_d = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_d |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_d = (int16_t)velocity_d;

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_vel_init(struct can_mcu_sbg_ecan_msg_gps1_vel_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_vel_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_odo_vel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_odo_vel_t *src_p,
    size_t size)
{
    uint16_t velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    velocity = (uint16_t)src_p->velocity;
    dst_p[0] |= pack_left_shift_u16(velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity, 8u, 0xffu);

    return (2);
}

int can_mcu_sbg_ecan_msg_odo_vel_unpack(
    struct can_mcu_sbg_ecan_msg_odo_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    velocity = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity = (int16_t)velocity;

    return (0);
}

int can_mcu_sbg_ecan_msg_odo_vel_init(struct can_mcu_sbg_ecan_msg_odo_vel_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_odo_vel_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_odo_vel_velocity_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_odo_vel_velocity_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_odo_vel_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_vel_body_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *src_p,
    size_t size)
{
    uint16_t velocity_x;
    uint16_t velocity_y;
    uint16_t velocity_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    velocity_x = (uint16_t)src_p->velocity_x;
    dst_p[0] |= pack_left_shift_u16(velocity_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_x, 8u, 0xffu);
    velocity_y = (uint16_t)src_p->velocity_y;
    dst_p[2] |= pack_left_shift_u16(velocity_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(velocity_y, 8u, 0xffu);
    velocity_z = (uint16_t)src_p->velocity_z;
    dst_p[4] |= pack_left_shift_u16(velocity_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_z, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_vel_body_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_x;
    uint16_t velocity_y;
    uint16_t velocity_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    velocity_x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_x = (int16_t)velocity_x;
    velocity_y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    velocity_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->velocity_y = (int16_t)velocity_y;
    velocity_z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_z = (int16_t)velocity_z;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_vel_body_init(struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_vel_body_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *src_p,
    size_t size)
{
    uint16_t velocity_d;
    uint16_t velocity_e;
    uint16_t velocity_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    velocity_n = (uint16_t)src_p->velocity_n;
    dst_p[0] |= pack_left_shift_u16(velocity_n, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_n, 8u, 0xffu);
    velocity_e = (uint16_t)src_p->velocity_e;
    dst_p[2] |= pack_left_shift_u16(velocity_e, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(velocity_e, 8u, 0xffu);
    velocity_d = (uint16_t)src_p->velocity_d;
    dst_p[4] |= pack_left_shift_u16(velocity_d, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_d, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_d;
    uint16_t velocity_e;
    uint16_t velocity_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    velocity_n = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_n |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_n = (int16_t)velocity_n;
    velocity_e = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    velocity_e |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->velocity_e = (int16_t)velocity_e;
    velocity_d = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_d |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_d = (int16_t)velocity_d;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_init(struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_pos_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_pos_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    latitude = (uint32_t)src_p->latitude;
    dst_p[0] |= pack_left_shift_u32(latitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(latitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(latitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(latitude, 24u, 0xffu);
    longitude = (uint32_t)src_p->longitude;
    dst_p[4] |= pack_left_shift_u32(longitude, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(longitude, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(longitude, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(longitude, 24u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_ekf_pos_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    latitude = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->latitude = (int32_t)latitude;
    longitude = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    dst_p->longitude = (int32_t)longitude;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_pos_init(struct can_mcu_sbg_ecan_msg_ekf_pos_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_pos_t));

    return 0;
}

int32_t can_mcu_sbg_ecan_msg_ekf_pos_latitude_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double can_mcu_sbg_ecan_msg_ekf_pos_latitude_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool can_mcu_sbg_ecan_msg_ekf_pos_latitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int32_t can_mcu_sbg_ecan_msg_ekf_pos_longitude_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double can_mcu_sbg_ecan_msg_ekf_pos_longitude_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool can_mcu_sbg_ecan_msg_ekf_pos_longitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_euler_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_euler_t *src_p,
    size_t size)
{
    uint16_t pitch;
    uint16_t roll;
    uint16_t yaw;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    roll = (uint16_t)src_p->roll;
    dst_p[0] |= pack_left_shift_u16(roll, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(roll, 8u, 0xffu);
    pitch = (uint16_t)src_p->pitch;
    dst_p[2] |= pack_left_shift_u16(pitch, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(pitch, 8u, 0xffu);
    yaw = (uint16_t)src_p->yaw;
    dst_p[4] |= pack_left_shift_u16(yaw, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(yaw, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_euler_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_euler_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t pitch;
    uint16_t roll;
    uint16_t yaw;

    if (size < 6u) {
        return (-EINVAL);
    }

    roll = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    roll |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->roll = (int16_t)roll;
    pitch = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    pitch |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->pitch = (int16_t)pitch;
    yaw = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    yaw |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->yaw = (int16_t)yaw;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_euler_init(struct can_mcu_sbg_ecan_msg_ekf_euler_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_euler_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_ekf_euler_roll_encode(double value)
{
    return (int16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_euler_roll_decode(int16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_euler_roll_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_euler_pitch_encode(double value)
{
    return (int16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_euler_pitch_decode(int16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_euler_pitch_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_euler_yaw_encode(double value)
{
    return (int16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_euler_yaw_decode(int16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_euler_yaw_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_imu_gyro_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_imu_gyro_t *src_p,
    size_t size)
{
    uint16_t gyro_x;
    uint16_t gyro_y;
    uint16_t gyro_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    gyro_x = (uint16_t)src_p->gyro_x;
    dst_p[0] |= pack_left_shift_u16(gyro_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(gyro_x, 8u, 0xffu);
    gyro_y = (uint16_t)src_p->gyro_y;
    dst_p[2] |= pack_left_shift_u16(gyro_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(gyro_y, 8u, 0xffu);
    gyro_z = (uint16_t)src_p->gyro_z;
    dst_p[4] |= pack_left_shift_u16(gyro_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(gyro_z, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_imu_gyro_unpack(
    struct can_mcu_sbg_ecan_msg_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t gyro_x;
    uint16_t gyro_y;
    uint16_t gyro_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    gyro_x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    gyro_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->gyro_x = (int16_t)gyro_x;
    gyro_y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    gyro_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->gyro_y = (int16_t)gyro_y;
    gyro_z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    gyro_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->gyro_z = (int16_t)gyro_z;

    return (0);
}

int can_mcu_sbg_ecan_msg_imu_gyro_init(struct can_mcu_sbg_ecan_msg_imu_gyro_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_imu_gyro_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_imu_accel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_imu_accel_t *src_p,
    size_t size)
{
    uint16_t accel_x;
    uint16_t accel_y;
    uint16_t accel_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    accel_x = (uint16_t)src_p->accel_x;
    dst_p[0] |= pack_left_shift_u16(accel_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(accel_x, 8u, 0xffu);
    accel_y = (uint16_t)src_p->accel_y;
    dst_p[2] |= pack_left_shift_u16(accel_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(accel_y, 8u, 0xffu);
    accel_z = (uint16_t)src_p->accel_z;
    dst_p[4] |= pack_left_shift_u16(accel_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(accel_z, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_imu_accel_unpack(
    struct can_mcu_sbg_ecan_msg_imu_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t accel_x;
    uint16_t accel_y;
    uint16_t accel_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    accel_x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    accel_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->accel_x = (int16_t)accel_x;
    accel_y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    accel_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->accel_y = (int16_t)accel_y;
    accel_z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    accel_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->accel_z = (int16_t)accel_z;

    return (0);
}

int can_mcu_sbg_ecan_msg_imu_accel_init(struct can_mcu_sbg_ecan_msg_imu_accel_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_imu_accel_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_x_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_imu_accel_accel_x_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_imu_accel_accel_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_y_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_imu_accel_accel_y_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_imu_accel_accel_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_z_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_imu_accel_accel_z_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_imu_accel_accel_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_apps_raw_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_apps_raw_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->apps1_raw_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->apps1_raw_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->apps2_raw_min, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->apps2_raw_min, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->apps1_raw_max, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->apps1_raw_max, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->apps2_raw_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->apps2_raw_max, 8u, 0xffu);

    return (8);
}

int can_mcu_vcu_apps_raw_unpack(
    struct can_mcu_vcu_apps_raw_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->apps1_raw_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->apps1_raw_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->apps2_raw_min = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->apps2_raw_min |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->apps1_raw_max = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->apps1_raw_max |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->apps2_raw_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->apps2_raw_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_vcu_apps_raw_init(struct can_mcu_vcu_apps_raw_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_apps_raw_t));

    return 0;
}

uint16_t can_mcu_vcu_apps_raw_apps1_raw_min_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_apps_raw_apps1_raw_min_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_apps_raw_apps1_raw_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_vcu_apps_raw_apps2_raw_min_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_apps_raw_apps2_raw_min_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_apps_raw_apps2_raw_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_vcu_apps_raw_apps1_raw_max_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_apps_raw_apps1_raw_max_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_apps_raw_apps1_raw_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_vcu_apps_raw_apps2_raw_max_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_apps_raw_apps2_raw_max_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_apps_raw_apps2_raw_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_steering_calibrated_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_steering_calibrated_t *src_p,
    size_t size)
{
    uint16_t steering_offset;
    uint32_t steering_angle_calibrated;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    memcpy(&steering_angle_calibrated, &src_p->steering_angle_calibrated, sizeof(steering_angle_calibrated));
    dst_p[0] |= pack_left_shift_u32(steering_angle_calibrated, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(steering_angle_calibrated, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(steering_angle_calibrated, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(steering_angle_calibrated, 24u, 0xffu);
    steering_offset = (uint16_t)src_p->steering_offset;
    dst_p[4] |= pack_left_shift_u16(steering_offset, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(steering_offset, 8u, 0xffu);

    return (6);
}

int can_mcu_vcu_steering_calibrated_unpack(
    struct can_mcu_vcu_steering_calibrated_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t steering_offset;
    uint32_t steering_angle_calibrated;

    if (size < 6u) {
        return (-EINVAL);
    }

    steering_angle_calibrated = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    steering_angle_calibrated |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    steering_angle_calibrated |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    steering_angle_calibrated |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->steering_angle_calibrated, &steering_angle_calibrated, sizeof(dst_p->steering_angle_calibrated));
    steering_offset = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    steering_offset |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->steering_offset = (int16_t)steering_offset;

    return (0);
}

int can_mcu_vcu_steering_calibrated_init(struct can_mcu_vcu_steering_calibrated_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_steering_calibrated_t));

    return 0;
}

float can_mcu_vcu_steering_calibrated_steering_angle_calibrated_encode(double value)
{
    return (float)(value);
}

double can_mcu_vcu_steering_calibrated_steering_angle_calibrated_decode(float value)
{
    return ((double)value);
}

bool can_mcu_vcu_steering_calibrated_steering_angle_calibrated_is_in_range(float value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_vcu_steering_calibrated_steering_offset_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_vcu_steering_calibrated_steering_offset_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_steering_calibrated_steering_offset_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dv_system_status_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_system_status_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->as_state, 0u, 0x07u);
    dst_p[0] |= pack_left_shift_u8(src_p->asb_ebs_state, 3u, 0x18u);
    dst_p[0] |= pack_left_shift_u8(src_p->ami_state, 5u, 0xe0u);
    dst_p[1] |= pack_left_shift_u8(src_p->steering_state, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->asb_redundancy_state, 1u, 0x06u);
    dst_p[1] |= pack_left_shift_u8(src_p->lap_counter, 3u, 0x78u);
    dst_p[1] |= pack_left_shift_u8(src_p->cones_count_actual, 7u, 0x80u);
    dst_p[2] |= pack_right_shift_u8(src_p->cones_count_actual, 1u, 0x7fu);
    dst_p[2] |= pack_left_shift_u32(src_p->cones_count_all, 7u, 0x80u);
    dst_p[3] |= pack_right_shift_u32(src_p->cones_count_all, 1u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->cones_count_all, 9u, 0xffu);

    return (5);
}

int can_mcu_dv_system_status_unpack(
    struct can_mcu_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->as_state = unpack_right_shift_u8(src_p[0], 0u, 0x07u);
    dst_p->asb_ebs_state = unpack_right_shift_u8(src_p[0], 3u, 0x18u);
    dst_p->ami_state = unpack_right_shift_u8(src_p[0], 5u, 0xe0u);
    dst_p->steering_state = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->asb_redundancy_state = unpack_right_shift_u8(src_p[1], 1u, 0x06u);
    dst_p->lap_counter = unpack_right_shift_u8(src_p[1], 3u, 0x78u);
    dst_p->cones_count_actual = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    dst_p->cones_count_actual |= unpack_left_shift_u8(src_p[2], 1u, 0x7fu);
    dst_p->cones_count_all = unpack_right_shift_u32(src_p[2], 7u, 0x80u);
    dst_p->cones_count_all |= unpack_left_shift_u32(src_p[3], 1u, 0xffu);
    dst_p->cones_count_all |= unpack_left_shift_u32(src_p[4], 9u, 0xffu);

    return (0);
}

int can_mcu_dv_system_status_init(struct can_mcu_dv_system_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dv_system_status_t));

    return 0;
}

uint8_t can_mcu_dv_system_status_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_as_state_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t can_mcu_dv_system_status_asb_ebs_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_asb_ebs_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_asb_ebs_state_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_mcu_dv_system_status_ami_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_ami_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_ami_state_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t can_mcu_dv_system_status_steering_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_steering_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_steering_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dv_system_status_asb_redundancy_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_asb_redundancy_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_asb_redundancy_state_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_mcu_dv_system_status_lap_counter_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_lap_counter_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_lap_counter_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dv_system_status_cones_count_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_cones_count_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_cones_count_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_dv_system_status_cones_count_all_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_dv_system_status_cones_count_all_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_cones_count_all_is_in_range(uint32_t value)
{
    return (value <= 131071u);
}

int can_mcu_dv_driving_dynamics_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_driving_dynamics_1_t *src_p,
    size_t size)
{
    uint8_t motor_moment_actual;
    uint8_t motor_moment_target;
    uint8_t steering_angle_actual;
    uint8_t steering_angle_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->speed_actual, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->speed_target, 0u, 0xffu);
    steering_angle_actual = (uint8_t)src_p->steering_angle_actual;
    dst_p[2] |= pack_left_shift_u8(steering_angle_actual, 0u, 0xffu);
    steering_angle_target = (uint8_t)src_p->steering_angle_target;
    dst_p[3] |= pack_left_shift_u8(steering_angle_target, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_hydr_acrtual, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->brake_hydr_target, 0u, 0xffu);
    motor_moment_actual = (uint8_t)src_p->motor_moment_actual;
    dst_p[6] |= pack_left_shift_u8(motor_moment_actual, 0u, 0xffu);
    motor_moment_target = (uint8_t)src_p->motor_moment_target;
    dst_p[7] |= pack_left_shift_u8(motor_moment_target, 0u, 0xffu);

    return (8);
}

int can_mcu_dv_driving_dynamics_1_unpack(
    struct can_mcu_dv_driving_dynamics_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t motor_moment_actual;
    uint8_t motor_moment_target;
    uint8_t steering_angle_actual;
    uint8_t steering_angle_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->speed_actual = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->speed_target = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    steering_angle_actual = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->steering_angle_actual = (int8_t)steering_angle_actual;
    steering_angle_target = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->steering_angle_target = (int8_t)steering_angle_target;
    dst_p->brake_hydr_acrtual = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->brake_hydr_target = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    motor_moment_actual = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->motor_moment_actual = (int8_t)motor_moment_actual;
    motor_moment_target = unpack_right_shift_u8(src_p[7], 0u, 0xffu);
    dst_p->motor_moment_target = (int8_t)motor_moment_target;

    return (0);
}

int can_mcu_dv_driving_dynamics_1_init(struct can_mcu_dv_driving_dynamics_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dv_driving_dynamics_1_t));

    return 0;
}

uint8_t can_mcu_dv_driving_dynamics_1_speed_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_speed_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_speed_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dv_driving_dynamics_1_speed_target_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_speed_target_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_speed_target_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_dv_driving_dynamics_1_steering_angle_actual_encode(double value)
{
    return (int8_t)(value / 0.5);
}

double can_mcu_dv_driving_dynamics_1_steering_angle_actual_decode(int8_t value)
{
    return ((double)value * 0.5);
}

bool can_mcu_dv_driving_dynamics_1_steering_angle_actual_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_dv_driving_dynamics_1_steering_angle_target_encode(double value)
{
    return (int8_t)(value / 0.5);
}

double can_mcu_dv_driving_dynamics_1_steering_angle_target_decode(int8_t value)
{
    return ((double)value * 0.5);
}

bool can_mcu_dv_driving_dynamics_1_steering_angle_target_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dv_driving_dynamics_1_brake_hydr_target_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_brake_hydr_target_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_brake_hydr_target_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_dv_driving_dynamics_1_motor_moment_actual_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_motor_moment_actual_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_motor_moment_actual_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_dv_driving_dynamics_1_motor_moment_target_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_motor_moment_target_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_motor_moment_target_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dv_driving_dynamics_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_driving_dynamics_2_t *src_p,
    size_t size)
{
    uint16_t acceleration_lateral;
    uint16_t acceleration_longitudinal;
    uint16_t yaw_rate;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    acceleration_longitudinal = (uint16_t)src_p->acceleration_longitudinal;
    dst_p[0] |= pack_left_shift_u16(acceleration_longitudinal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(acceleration_longitudinal, 8u, 0xffu);
    acceleration_lateral = (uint16_t)src_p->acceleration_lateral;
    dst_p[2] |= pack_left_shift_u16(acceleration_lateral, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(acceleration_lateral, 8u, 0xffu);
    yaw_rate = (uint16_t)src_p->yaw_rate;
    dst_p[4] |= pack_left_shift_u16(yaw_rate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(yaw_rate, 8u, 0xffu);

    return (6);
}

int can_mcu_dv_driving_dynamics_2_unpack(
    struct can_mcu_dv_driving_dynamics_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t acceleration_lateral;
    uint16_t acceleration_longitudinal;
    uint16_t yaw_rate;

    if (size < 6u) {
        return (-EINVAL);
    }

    acceleration_longitudinal = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    acceleration_longitudinal |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->acceleration_longitudinal = (int16_t)acceleration_longitudinal;
    acceleration_lateral = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    acceleration_lateral |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->acceleration_lateral = (int16_t)acceleration_lateral;
    yaw_rate = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    yaw_rate |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->yaw_rate = (int16_t)yaw_rate;

    return (0);
}

int can_mcu_dv_driving_dynamics_2_init(struct can_mcu_dv_driving_dynamics_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dv_driving_dynamics_2_t));

    return 0;
}

int16_t can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_encode(double value)
{
    return (int16_t)(value / 0.00195313);
}

double can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_decode(int16_t value)
{
    return ((double)value * 0.00195313);
}

bool can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_dv_driving_dynamics_2_acceleration_lateral_encode(double value)
{
    return (int16_t)(value / 0.00195313);
}

double can_mcu_dv_driving_dynamics_2_acceleration_lateral_decode(int16_t value)
{
    return ((double)value * 0.00195313);
}

bool can_mcu_dv_driving_dynamics_2_acceleration_lateral_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_dv_driving_dynamics_2_yaw_rate_encode(double value)
{
    return (int16_t)(value / 0.0078125);
}

double can_mcu_dv_driving_dynamics_2_yaw_rate_decode(int16_t value)
{
    return ((double)value * 0.0078125);
}

bool can_mcu_dv_driving_dynamics_2_yaw_rate_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_asb_datalogger_pack(
    uint8_t *dst_p,
    const struct can_mcu_asb_datalogger_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->ebs_pneumatic_pressure, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->brake_pressure_rear, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->brake_pressure_front, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->eb_sstate_unavailable, 0u, 0x01u);
    dst_p[3] |= pack_left_shift_u8(src_p->eb_sstate_armed, 1u, 0x02u);
    dst_p[3] |= pack_left_shift_u8(src_p->eb_sstate_activated, 2u, 0x04u);
    dst_p[3] |= pack_left_shift_u8(src_p->servicebrakestate_disengaged, 3u, 0x08u);
    dst_p[3] |= pack_left_shift_u8(src_p->servicebrakestate_engaged, 4u, 0x10u);
    dst_p[3] |= pack_left_shift_u8(src_p->servicebrakestate_available, 5u, 0x20u);
    dst_p[3] |= pack_left_shift_u8(src_p->watchdog_ok, 6u, 0x40u);
    dst_p[3] |= pack_left_shift_u8(src_p->valve_interlock_ok, 7u, 0x80u);
    dst_p[4] |= pack_left_shift_u8(src_p->servo_interlock_ok, 0u, 0x01u);
    dst_p[4] |= pack_left_shift_u8(src_p->as_state, 1u, 0x0eu);

    return (8);
}

int can_mcu_asb_datalogger_unpack(
    struct can_mcu_asb_datalogger_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ebs_pneumatic_pressure = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->brake_pressure_rear = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->brake_pressure_front = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->eb_sstate_unavailable = unpack_right_shift_u8(src_p[3], 0u, 0x01u);
    dst_p->eb_sstate_armed = unpack_right_shift_u8(src_p[3], 1u, 0x02u);
    dst_p->eb_sstate_activated = unpack_right_shift_u8(src_p[3], 2u, 0x04u);
    dst_p->servicebrakestate_disengaged = unpack_right_shift_u8(src_p[3], 3u, 0x08u);
    dst_p->servicebrakestate_engaged = unpack_right_shift_u8(src_p[3], 4u, 0x10u);
    dst_p->servicebrakestate_available = unpack_right_shift_u8(src_p[3], 5u, 0x20u);
    dst_p->watchdog_ok = unpack_right_shift_u8(src_p[3], 6u, 0x40u);
    dst_p->valve_interlock_ok = unpack_right_shift_u8(src_p[3], 7u, 0x80u);
    dst_p->servo_interlock_ok = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->as_state = unpack_right_shift_u8(src_p[4], 1u, 0x0eu);

    return (0);
}

int can_mcu_asb_datalogger_init(struct can_mcu_asb_datalogger_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_asb_datalogger_t));

    return 0;
}

uint8_t can_mcu_asb_datalogger_ebs_pneumatic_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_ebs_pneumatic_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_ebs_pneumatic_pressure_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_asb_datalogger_brake_pressure_rear_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_brake_pressure_rear_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_brake_pressure_rear_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_asb_datalogger_brake_pressure_front_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_brake_pressure_front_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_brake_pressure_front_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_asb_datalogger_eb_sstate_unavailable_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_eb_sstate_unavailable_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_eb_sstate_unavailable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_eb_sstate_armed_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_eb_sstate_armed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_eb_sstate_armed_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_eb_sstate_activated_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_eb_sstate_activated_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_eb_sstate_activated_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_servicebrakestate_disengaged_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_servicebrakestate_disengaged_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_servicebrakestate_disengaged_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_servicebrakestate_engaged_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_servicebrakestate_engaged_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_servicebrakestate_engaged_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_servicebrakestate_available_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_servicebrakestate_available_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_servicebrakestate_available_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_watchdog_ok_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_watchdog_ok_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_watchdog_ok_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_valve_interlock_ok_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_valve_interlock_ok_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_valve_interlock_ok_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_servo_interlock_ok_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_servo_interlock_ok_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_servo_interlock_ok_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_datalogger_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_datalogger_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_datalogger_as_state_is_in_range(uint8_t value)
{
    return (value <= 7u);
}
