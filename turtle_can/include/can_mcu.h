/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.13 Mon Jun 23 01:31:53 2025.
 */

#ifndef CAN_MCU_H
#define CAN_MCU_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_MCU_VCU_SUSP_R_FRAME_ID (0x323u)
#define CAN_MCU_DASH_APPS_FRAME_ID (0x64u)
#define CAN_MCU_VCU_BOOLS_FRAME_ID (0x320u)
#define CAN_MCU_DASH_STEERING_FRAME_ID (0x66u)
#define CAN_MCU_DASH_BOOLS_FRAME_ID (0x67u)
#define CAN_MCU_DASH_SUSP_F_FRAME_ID (0x69u)
#define CAN_MCU_VCU_ADU_FRAME_ID (0x321u)
#define CAN_MCU_VCU_RL_INFO_FRAME_ID (0x2bdu)
#define CAN_MCU_VCU_RR_INFO_FRAME_ID (0x2beu)
#define CAN_MCU_ASB_FRAME_ID (0x23u)
#define CAN_MCU_APU_COMMAND_FRAME_ID (0x0bu)
#define CAN_MCU_APU_STATE_MISSION_FRAME_ID (0x0au)
#define CAN_MCU_DASH_AMI_FRAME_ID (0x6du)
#define CAN_MCU_ISABELLEN_IDC_FRAME_ID (0x521u)
#define CAN_MCU_ISABELLEN_VDC_FRAME_ID (0x522u)
#define CAN_MCU_ISABELLEN_PDC_FRAME_ID (0x526u)
#define CAN_MCU_ISABELLEN_ENERGY_FRAME_ID (0x528u)
#define CAN_MCU_BLDC_TX_1_FRAME_ID (0x200u)
#define CAN_MCU_BLDC_RX_1_FRAME_ID (0x27fu)
#define CAN_MCU_BLDC_RX_2_FRAME_ID (0x37fu)
#define CAN_MCU_BLDC_TX_2_FRAME_ID (0x2ffu)
#define CAN_MCU_BLDC_TX_3_FRAME_ID (0x3ffu)
#define CAN_MCU_BLDC_RX_3_FRAME_ID (0x47fu)
#define CAN_MCU_BLDC_TX_4_FRAME_ID (0x4ffu)
#define CAN_MCU_BLDC_RX_4_FRAME_ID (0x57fu)
#define CAN_MCU_DASH_STEERING_COMMAND_FRAME_ID (0x1eu)
#define CAN_MCU_APU_TUNING_VCU_FRAME_ID (0x0cu)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_FRAME_ID (0x640u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_FRAME_ID (0x641u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_FRAME_ID (0x642u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_FRAME_ID (0x643u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_FRAME_ID (0x644u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_FRAME_ID (0x645u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_FRAME_ID (0x646u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_FRAME_ID (0x647u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_FRAME_ID (0x648u)
#define CAN_MCU_APU_TEMP_THA_ENHMERWTHEI_FRAME_ID (0x0du)
#define CAN_MCU_DASH_BRAKE_FRAME_ID (0x65u)
#define CAN_MCU_ISABELLEN_16_BIT_FRAME_ID (0x523u)
#define CAN_MCU_VCU_APPS_FRAME_ID (0x31eu)
#define CAN_MCU_RES_STATUS_FRAME_ID (0x191u)
#define CAN_MCU_APU_RES_INIT_FRAME_ID (0x00u)
#define CAN_MCU_DASH_TUNING_VCU_GENERAL_FRAME_ID (0x6bu)
#define CAN_MCU_DASH_TUNING_VCU_CONTROL_FRAME_ID (0x6au)
#define CAN_MCU_DASH_ADU_FRAME_ID (0x6cu)
#define CAN_MCU_VCU_FL_INFO_FRAME_ID (0x2bfu)
#define CAN_MCU_VCU_FR_INFO_FRAME_ID (0x2c0u)
#define CAN_MCU_DASH_SDC_DETECTION_FRAME_ID (0x68u)
#define CAN_MCU_VCU_SERVO_CONTROL_FRAME_ID (0x324u)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_ALT_FRAME_ID (0x176u)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_FRAME_ID (0x175u)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_VEL_FRAME_ID (0x171u)
#define CAN_MCU_SBG_ECAN_MSG_ODO_VEL_FRAME_ID (0x164u)
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_BODY_FRAME_ID (0x139u)
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_NED_FRAME_ID (0x137u)
#define CAN_MCU_SBG_ECAN_MSG_EKF_POS_FRAME_ID (0x134u)
#define CAN_MCU_SBG_ECAN_MSG_EKF_EULER_FRAME_ID (0x132u)
#define CAN_MCU_SBG_ECAN_MSG_IMU_GYRO_FRAME_ID (0x122u)
#define CAN_MCU_SBG_ECAN_MSG_IMU_ACCEL_FRAME_ID (0x121u)
#define CAN_MCU_VCU_APPS_RAW_FRAME_ID (0x325u)
#define CAN_MCU_VCU_STEERING_CALIBRATED_FRAME_ID (0x31fu)
#define CAN_MCU_DV_SYSTEM_STATUS_FRAME_ID (0x502u)
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_FRAME_ID (0x500u)
#define CAN_MCU_DV_DRIVING_DYNAMICS_2_FRAME_ID (0x501u)
#define CAN_MCU_ASB_DATALOGGER_FRAME_ID (0x511u)

/* Frame lengths in bytes. */
#define CAN_MCU_VCU_SUSP_R_LENGTH (4u)
#define CAN_MCU_DASH_APPS_LENGTH (5u)
#define CAN_MCU_VCU_BOOLS_LENGTH (1u)
#define CAN_MCU_DASH_STEERING_LENGTH (4u)
#define CAN_MCU_DASH_BOOLS_LENGTH (4u)
#define CAN_MCU_DASH_SUSP_F_LENGTH (4u)
#define CAN_MCU_VCU_ADU_LENGTH (8u)
#define CAN_MCU_VCU_RL_INFO_LENGTH (8u)
#define CAN_MCU_VCU_RR_INFO_LENGTH (8u)
#define CAN_MCU_ASB_LENGTH (5u)
#define CAN_MCU_APU_COMMAND_LENGTH (4u)
#define CAN_MCU_APU_STATE_MISSION_LENGTH (1u)
#define CAN_MCU_DASH_AMI_LENGTH (1u)
#define CAN_MCU_ISABELLEN_IDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_VDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_PDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_ENERGY_LENGTH (6u)
#define CAN_MCU_BLDC_TX_1_LENGTH (3u)
#define CAN_MCU_BLDC_RX_1_LENGTH (7u)
#define CAN_MCU_BLDC_RX_2_LENGTH (8u)
#define CAN_MCU_BLDC_TX_2_LENGTH (4u)
#define CAN_MCU_BLDC_TX_3_LENGTH (2u)
#define CAN_MCU_BLDC_RX_3_LENGTH (2u)
#define CAN_MCU_BLDC_TX_4_LENGTH (4u)
#define CAN_MCU_BLDC_RX_4_LENGTH (4u)
#define CAN_MCU_DASH_STEERING_COMMAND_LENGTH (8u)
#define CAN_MCU_APU_TUNING_VCU_LENGTH (3u)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_LENGTH (8u)
#define CAN_MCU_APU_TEMP_THA_ENHMERWTHEI_LENGTH (4u)
#define CAN_MCU_DASH_BRAKE_LENGTH (5u)
#define CAN_MCU_ISABELLEN_16_BIT_LENGTH (8u)
#define CAN_MCU_VCU_APPS_LENGTH (2u)
#define CAN_MCU_RES_STATUS_LENGTH (8u)
#define CAN_MCU_APU_RES_INIT_LENGTH (2u)
#define CAN_MCU_DASH_TUNING_VCU_GENERAL_LENGTH (6u)
#define CAN_MCU_DASH_TUNING_VCU_CONTROL_LENGTH (6u)
#define CAN_MCU_DASH_ADU_LENGTH (2u)
#define CAN_MCU_VCU_FL_INFO_LENGTH (8u)
#define CAN_MCU_VCU_FR_INFO_LENGTH (8u)
#define CAN_MCU_DASH_SDC_DETECTION_LENGTH (1u)
#define CAN_MCU_VCU_SERVO_CONTROL_LENGTH (1u)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_ALT_LENGTH (8u)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_LENGTH (8u)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_VEL_LENGTH (6u)
#define CAN_MCU_SBG_ECAN_MSG_ODO_VEL_LENGTH (2u)
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_BODY_LENGTH (6u)
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_NED_LENGTH (6u)
#define CAN_MCU_SBG_ECAN_MSG_EKF_POS_LENGTH (8u)
#define CAN_MCU_SBG_ECAN_MSG_EKF_EULER_LENGTH (6u)
#define CAN_MCU_SBG_ECAN_MSG_IMU_GYRO_LENGTH (6u)
#define CAN_MCU_SBG_ECAN_MSG_IMU_ACCEL_LENGTH (6u)
#define CAN_MCU_VCU_APPS_RAW_LENGTH (8u)
#define CAN_MCU_VCU_STEERING_CALIBRATED_LENGTH (6u)
#define CAN_MCU_DV_SYSTEM_STATUS_LENGTH (5u)
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_LENGTH (8u)
#define CAN_MCU_DV_DRIVING_DYNAMICS_2_LENGTH (6u)
#define CAN_MCU_ASB_DATALOGGER_LENGTH (8u)

/* Extended or standard frame types. */
#define CAN_MCU_VCU_SUSP_R_IS_EXTENDED (0)
#define CAN_MCU_DASH_APPS_IS_EXTENDED (0)
#define CAN_MCU_VCU_BOOLS_IS_EXTENDED (0)
#define CAN_MCU_DASH_STEERING_IS_EXTENDED (0)
#define CAN_MCU_DASH_BOOLS_IS_EXTENDED (0)
#define CAN_MCU_DASH_SUSP_F_IS_EXTENDED (0)
#define CAN_MCU_VCU_ADU_IS_EXTENDED (0)
#define CAN_MCU_VCU_RL_INFO_IS_EXTENDED (0)
#define CAN_MCU_VCU_RR_INFO_IS_EXTENDED (0)
#define CAN_MCU_ASB_IS_EXTENDED (0)
#define CAN_MCU_APU_COMMAND_IS_EXTENDED (0)
#define CAN_MCU_APU_STATE_MISSION_IS_EXTENDED (0)
#define CAN_MCU_DASH_AMI_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_IDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_VDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_PDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_ENERGY_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_1_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_1_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_2_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_2_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_3_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_3_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_4_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_4_IS_EXTENDED (0)
#define CAN_MCU_DASH_STEERING_COMMAND_IS_EXTENDED (0)
#define CAN_MCU_APU_TUNING_VCU_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_IS_EXTENDED (0)
#define CAN_MCU_APU_TEMP_THA_ENHMERWTHEI_IS_EXTENDED (0)
#define CAN_MCU_DASH_BRAKE_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_16_BIT_IS_EXTENDED (0)
#define CAN_MCU_VCU_APPS_IS_EXTENDED (0)
#define CAN_MCU_RES_STATUS_IS_EXTENDED (0)
#define CAN_MCU_APU_RES_INIT_IS_EXTENDED (0)
#define CAN_MCU_DASH_TUNING_VCU_GENERAL_IS_EXTENDED (0)
#define CAN_MCU_DASH_TUNING_VCU_CONTROL_IS_EXTENDED (0)
#define CAN_MCU_DASH_ADU_IS_EXTENDED (0)
#define CAN_MCU_VCU_FL_INFO_IS_EXTENDED (0)
#define CAN_MCU_VCU_FR_INFO_IS_EXTENDED (0)
#define CAN_MCU_DASH_SDC_DETECTION_IS_EXTENDED (0)
#define CAN_MCU_VCU_SERVO_CONTROL_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_ALT_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_GPS1_VEL_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_ODO_VEL_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_BODY_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_NED_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_EKF_POS_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_EKF_EULER_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_IMU_GYRO_IS_EXTENDED (0)
#define CAN_MCU_SBG_ECAN_MSG_IMU_ACCEL_IS_EXTENDED (0)
#define CAN_MCU_VCU_APPS_RAW_IS_EXTENDED (0)
#define CAN_MCU_VCU_STEERING_CALIBRATED_IS_EXTENDED (0)
#define CAN_MCU_DV_SYSTEM_STATUS_IS_EXTENDED (0)
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_IS_EXTENDED (0)
#define CAN_MCU_DV_DRIVING_DYNAMICS_2_IS_EXTENDED (0)
#define CAN_MCU_ASB_DATALOGGER_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define CAN_MCU_VCU_SUSP_R_CYCLE_TIME_MS (10u)
#define CAN_MCU_DASH_APPS_CYCLE_TIME_MS (5u)
#define CAN_MCU_VCU_BOOLS_CYCLE_TIME_MS (100u)
#define CAN_MCU_DASH_STEERING_CYCLE_TIME_MS (5u)
#define CAN_MCU_DASH_BOOLS_CYCLE_TIME_MS (100u)
#define CAN_MCU_VCU_ADU_CYCLE_TIME_MS (100u)
#define CAN_MCU_VCU_RL_INFO_CYCLE_TIME_MS (10u)
#define CAN_MCU_VCU_RR_INFO_CYCLE_TIME_MS (10u)
#define CAN_MCU_ASB_CYCLE_TIME_MS (50u)
#define CAN_MCU_APU_COMMAND_CYCLE_TIME_MS (20u)
#define CAN_MCU_APU_STATE_MISSION_CYCLE_TIME_MS (125u)
#define CAN_MCU_DASH_AMI_CYCLE_TIME_MS (20u)
#define CAN_MCU_DASH_STEERING_COMMAND_CYCLE_TIME_MS (20u)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_CYCLE_TIME_MS (5000u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_CYCLE_TIME_MS (5000u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_CYCLE_TIME_MS (5000u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_CYCLE_TIME_MS (5000u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_CYCLE_TIME_MS (5000u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_CYCLE_TIME_MS (5000u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_CYCLE_TIME_MS (5000u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_CYCLE_TIME_MS (5000u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_CYCLE_TIME_MS (5000u)
#define CAN_MCU_DASH_BRAKE_CYCLE_TIME_MS (5u)
#define CAN_MCU_VCU_APPS_CYCLE_TIME_MS (10u)
#define CAN_MCU_RES_STATUS_CYCLE_TIME_MS (30u)
#define CAN_MCU_APU_RES_INIT_CYCLE_TIME_MS (1000u)
#define CAN_MCU_DASH_ADU_CYCLE_TIME_MS (20u)
#define CAN_MCU_DV_SYSTEM_STATUS_CYCLE_TIME_MS (100u)
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_CYCLE_TIME_MS (100u)
#define CAN_MCU_DV_DRIVING_DYNAMICS_2_CYCLE_TIME_MS (100u)
#define CAN_MCU_ASB_DATALOGGER_CYCLE_TIME_MS (100u)

/* Signal choices. */
#define CAN_MCU_DASH_APPS_APPS1_RAW_LOWER_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS1_RAW_HIGHER_CHOICE (4095u)

#define CAN_MCU_DASH_APPS_APPS2_RAW_LOWER_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS2_RAW_HIGHER_CHOICE (4095u)

#define CAN_MCU_DASH_APPS_APPS_SC_SIGNALS_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS_SC_SIGNALS_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_APPS_SC_SUP_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS_SC_SUP_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_APPS_SC_GND_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS_SC_GND_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_APPS_OUT_OF_RANGE_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS_OUT_OF_RANGE_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_BOOLS_COOLING_STATUS_COOLING_DISABLE_CHOICE (0u)
#define CAN_MCU_DASH_BOOLS_COOLING_STATUS_COOLING_ENABLE_CHOICE (1u)

#define CAN_MCU_ASB_ASMS_STATE_ASMS_OPENED_CHOICE (0u)
#define CAN_MCU_ASB_ASMS_STATE_ASMS_CLOSED_CHOICE (1u)

#define CAN_MCU_ASB_TSMS_OUT_TSMS_OPENED_CHOICE (0u)
#define CAN_MCU_ASB_TSMS_OUT_TSMS_CLOSED_CHOICE (1u)

#define CAN_MCU_ASB_ASB_LED_ASB_LED_OFF_CHOICE (0u)
#define CAN_MCU_ASB_ASB_LED_ASB_LED_ON_CHOICE (1u)

#define CAN_MCU_ASB_INITIAL_CHECKED_INITIAL_CHECK_FAILED_CHOICE (0u)
#define CAN_MCU_ASB_INITIAL_CHECKED_INITIAL_CHECK_SUCCESSFUL_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_TANK_PRESSURE_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_TANK_PRESSURE_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_BRAKE_PRESSURE_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_BRAKE_PRESSURE_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_SERVO_CHECK_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_SERVO_CHECK_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_APU_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_APU_OK_CHOICE (1u)

#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CLOSE_RES_RELAIS_AND_SDC_BEFORE_AS_RELAY_CHOICE (0)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_NOT_IN_INITIAL_CHECK_CHOICE (1)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_RE_ENABLE_WATCHDOG_CHOICE (2)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_TANK___BRAKE_PRESSURE_CHOICE (3)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CLOSE_SDC_CHOICE (4)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_EBS_ARMING_CHOICE (5)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_DE_ENERGIZE_EBS_ELECTRIC_VALVE_CHOICE (6)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_SERVICE_BRAKE_CHOICE (7)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_COMMUNICATION_WITH_APU_CHOICE (8)

#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_DISENGAGED_CHOICE (1u)
#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_ENGAGED_CHOICE (2u)
#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_AVAILABLE_CHOICE (3u)

#define CAN_MCU_ASB_EBS_STATUS_UNAVAILABLE_CHOICE (1u)
#define CAN_MCU_ASB_EBS_STATUS_ARMED_CHOICE (2u)
#define CAN_MCU_ASB_EBS_STATUS_TRIGGERED_CHOICE (3u)

#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_NO_MISSION_CHOICE (0)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_ACCELERATION_CHOICE (1)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_SKIDPAD_CHOICE (2)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_AUTOCROSS_CHOICE (3)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_TRACKDRIVE_CHOICE (4)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_EBSTEST_CHOICE (5)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_INSPECTION_CHOICE (6)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_MANUAL_DRIVING_CHOICE (7)

#define CAN_MCU_APU_STATE_MISSION_AS_STATE_MANUAL_DRIVING_CHOICE (0u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_OFF_CHOICE (1u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_READY_CHOICE (2u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_DRIVING_CHOICE (3u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_FINISHED_CHOICE (4u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_EMERGENCY_CHOICE (5u)

#define CAN_MCU_APU_STATE_MISSION_AS_SET_FINISHED_SET__FINISHED__FALSE_CHOICE (0u)
#define CAN_MCU_APU_STATE_MISSION_AS_SET_FINISHED_SET__FINISHED__TRUE_CHOICE (1u)

#define CAN_MCU_DASH_AMI_AMI_NO__MISSION_CHOICE (0u)
#define CAN_MCU_DASH_AMI_AMI_ACCELERATION_CHOICE (1u)
#define CAN_MCU_DASH_AMI_AMI_SKIDPAD_CHOICE (2u)
#define CAN_MCU_DASH_AMI_AMI_AUTOCROSS_CHOICE (3u)
#define CAN_MCU_DASH_AMI_AMI_TRACKDRIVE_CHOICE (4u)
#define CAN_MCU_DASH_AMI_AMI_EBS__TEST__CHOICE (5u)
#define CAN_MCU_DASH_AMI_AMI_INSPECTION_CHOICE (6u)
#define CAN_MCU_DASH_AMI_AMI_MANUAL__MISSION_CHOICE (7u)

#define CAN_MCU_DASH_STEERING_COMMAND_STEERING_MODE_CYCLIC_SYCHRONOUS_POSITION_MODE_CHOICE (8u)
#define CAN_MCU_DASH_STEERING_COMMAND_STEERING_MODE_CYCLIC_SYCHRONOUS_VELOCITY_MODE_CHOICE (9u)

#define CAN_MCU_APU_TUNING_VCU_INDEX_INVERTER_RPM_PERCENTAGE_CHOICE (1u)
#define CAN_MCU_APU_TUNING_VCU_INDEX_INVERTER_IRMS_MAX_CHOICE (2u)
#define CAN_MCU_APU_TUNING_VCU_INDEX_POWER_TARGET_CHOICE (3u)
#define CAN_MCU_APU_TUNING_VCU_INDEX_SERVO_START_SPEED_CHOICE (4u)
#define CAN_MCU_APU_TUNING_VCU_INDEX_REGEN_MIN_SPEED_CHOICE (5u)
#define CAN_MCU_APU_TUNING_VCU_INDEX_TV_ON_CHOICE (6u)
#define CAN_MCU_APU_TUNING_VCU_INDEX_TC_ON_CHOICE (7u)

#define CAN_MCU_RES_STATUS_STOP_ON_CHOICE (0u)
#define CAN_MCU_RES_STATUS_STOP_OFF_CHOICE (1u)

#define CAN_MCU_RES_STATUS_TOGGLE_OFF_CHOICE (0u)
#define CAN_MCU_RES_STATUS_TOGGLE_ON_CHOICE (1u)

#define CAN_MCU_RES_STATUS_BUTTON_OFF_CHOICE (0u)
#define CAN_MCU_RES_STATUS_BUTTON_ON_CHOICE (1u)

#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_OPERATIONAL_CHOICE (1u)
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_STOPPED_CHOICE (2u)
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_PRE_OPERATIONAL_CHOICE (128u)
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_RESET_NODE_CHOICE (129u)
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_RESET_COMM_CHOICE (130u)

#define CAN_MCU_APU_RES_INIT_ADDRESED_NODE_RES_ADDRESS_CHOICE (17u)

#define CAN_MCU_DV_SYSTEM_STATUS_AS_STATE_OFF_CHOICE (1u)
#define CAN_MCU_DV_SYSTEM_STATUS_AS_STATE_READY_CHOICE (2u)
#define CAN_MCU_DV_SYSTEM_STATUS_AS_STATE_DRIVING_CHOICE (3u)
#define CAN_MCU_DV_SYSTEM_STATUS_AS_STATE_EMERGENCY_CHOICE (4u)
#define CAN_MCU_DV_SYSTEM_STATUS_AS_STATE_FINISH_CHOICE (5u)

#define CAN_MCU_DV_SYSTEM_STATUS_ASB_EBS_STATE_DEACTIVATED_CHOICE (1u)
#define CAN_MCU_DV_SYSTEM_STATUS_ASB_EBS_STATE_INITIAL_CHECKUP_PASSED_CHOICE (2u)
#define CAN_MCU_DV_SYSTEM_STATUS_ASB_EBS_STATE_ACTIVATED_CHOICE (3u)

#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_ACCELERATION_CHOICE (1u)
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_SKIDPAD_CHOICE (2u)
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_TRACKDRIVE_CHOICE (3u)
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_BRAKETEST_CHOICE (4u)
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_INSPECTION_CHOICE (5u)
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_AUTOCROSS_CHOICE (6u)

#define CAN_MCU_DV_SYSTEM_STATUS_ASB_REDUNDANCY_STATE_DEACTIVATED_CHOICE (1u)
#define CAN_MCU_DV_SYSTEM_STATUS_ASB_REDUNDANCY_STATE_ENGAGED_CHOICE (2u)
#define CAN_MCU_DV_SYSTEM_STATUS_ASB_REDUNDANCY_STATE_INITIAL_CHECKUP_PASSED_CHOICE (3u)

#define CAN_MCU_ASB_DATALOGGER_AS_STATE_OFF_CHOICE (1u)
#define CAN_MCU_ASB_DATALOGGER_AS_STATE_READY_CHOICE (2u)
#define CAN_MCU_ASB_DATALOGGER_AS_STATE_DRIVING_CHOICE (3u)
#define CAN_MCU_ASB_DATALOGGER_AS_STATE_EMERGENCY_CHOICE (4u)
#define CAN_MCU_ASB_DATALOGGER_AS_STATE_FINISHED_CHOICE (5u)

/* Frame Names. */
#define CAN_MCU_VCU_SUSP_R_NAME "VCU_SUSP_R"
#define CAN_MCU_DASH_APPS_NAME "DASH_APPS"
#define CAN_MCU_VCU_BOOLS_NAME "VCU_BOOLS"
#define CAN_MCU_DASH_STEERING_NAME "DASH_STEERING"
#define CAN_MCU_DASH_BOOLS_NAME "DASH_BOOLS"
#define CAN_MCU_DASH_SUSP_F_NAME "DASH_SUSP_F"
#define CAN_MCU_VCU_ADU_NAME "VCU_ADU"
#define CAN_MCU_VCU_RL_INFO_NAME "VCU_RL_Info"
#define CAN_MCU_VCU_RR_INFO_NAME "VCU_RR_Info"
#define CAN_MCU_ASB_NAME "ASB"
#define CAN_MCU_APU_COMMAND_NAME "APU_COMMAND"
#define CAN_MCU_APU_STATE_MISSION_NAME "APU_STATE_MISSION"
#define CAN_MCU_DASH_AMI_NAME "DASH_AMI"
#define CAN_MCU_ISABELLEN_IDC_NAME "ISABELLEN_IDC"
#define CAN_MCU_ISABELLEN_VDC_NAME "ISABELLEN_VDC"
#define CAN_MCU_ISABELLEN_PDC_NAME "ISABELLEN_PDC"
#define CAN_MCU_ISABELLEN_ENERGY_NAME "ISABELLEN_ENERGY"
#define CAN_MCU_BLDC_TX_1_NAME "BLDC_TX_1"
#define CAN_MCU_BLDC_RX_1_NAME "BLDC_RX_1"
#define CAN_MCU_BLDC_RX_2_NAME "BLDC_RX_2"
#define CAN_MCU_BLDC_TX_2_NAME "BLDC_TX_2"
#define CAN_MCU_BLDC_TX_3_NAME "BLDC_TX_3"
#define CAN_MCU_BLDC_RX_3_NAME "BLDC_RX_3"
#define CAN_MCU_BLDC_TX_4_NAME "BLDC_TX_4"
#define CAN_MCU_BLDC_RX_4_NAME "BLDC_RX_4"
#define CAN_MCU_DASH_STEERING_COMMAND_NAME "DASH_STEERING_COMMAND"
#define CAN_MCU_APU_TUNING_VCU_NAME "APU_Tuning_VCU"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_NAME "BMS_MIN_MAX_S1_S2"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_NAME "BMS_MIN_MAX_S3_S4"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_NAME "BMS_MIN_MAX_S5_S6"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_NAME "BMS_MIN_MAX_S7_S8"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_NAME "BMS_MIN_MAX_S9_S10"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_NAME "BMS_MIN_MAX_S11_S12"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_NAME "BMS_Max_Temp_S1_S4"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_NAME "BMS_Max_Temp_S5_S8"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_NAME "BMS_Max_Temp_S9_S12"
#define CAN_MCU_APU_TEMP_THA_ENHMERWTHEI_NAME "APU_TEMP_THA_ENHMERWTHEI"
#define CAN_MCU_DASH_BRAKE_NAME "DASH_BRAKE"
#define CAN_MCU_ISABELLEN_16_BIT_NAME "ISABELLEN_16_bit"
#define CAN_MCU_VCU_APPS_NAME "VCU_APPS"
#define CAN_MCU_RES_STATUS_NAME "RES_STATUS"
#define CAN_MCU_APU_RES_INIT_NAME "APU_RES_INIT"
#define CAN_MCU_DASH_TUNING_VCU_GENERAL_NAME "DASH_Tuning_VCUGeneral"
#define CAN_MCU_DASH_TUNING_VCU_CONTROL_NAME "DASH_Tuning_VCUControl"
#define CAN_MCU_DASH_ADU_NAME "DASH_ADU"
#define CAN_MCU_VCU_FL_INFO_NAME "VCU_FL_Info"
#define CAN_MCU_VCU_FR_INFO_NAME "VCU_FR_Info"
#define CAN_MCU_DASH_SDC_DETECTION_NAME "DASH_SDC_Detection"
#define CAN_MCU_VCU_SERVO_CONTROL_NAME "VCU_Servo_Control"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_ALT_NAME "SBG_ECAN_MSG_GPS1_POS_ALT"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_NAME "SBG_ECAN_MSG_GPS1_POS"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_VEL_NAME "SBG_ECAN_MSG_GPS1_VEL"
#define CAN_MCU_SBG_ECAN_MSG_ODO_VEL_NAME "SBG_ECAN_MSG_ODO_VEL"
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_BODY_NAME "SBG_ECAN_MSG_EKF_VEL_BODY"
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_NED_NAME "SBG_ECAN_MSG_EKF_VEL_NED"
#define CAN_MCU_SBG_ECAN_MSG_EKF_POS_NAME "SBG_ECAN_MSG_EKF_POS"
#define CAN_MCU_SBG_ECAN_MSG_EKF_EULER_NAME "SBG_ECAN_MSG_EKF_EULER"
#define CAN_MCU_SBG_ECAN_MSG_IMU_GYRO_NAME "SBG_ECAN_MSG_IMU_GYRO"
#define CAN_MCU_SBG_ECAN_MSG_IMU_ACCEL_NAME "SBG_ECAN_MSG_IMU_ACCEL"
#define CAN_MCU_VCU_APPS_RAW_NAME "VCU_APPS_Raw"
#define CAN_MCU_VCU_STEERING_CALIBRATED_NAME "VCU_Steering_Calibrated"
#define CAN_MCU_DV_SYSTEM_STATUS_NAME "DV_SYSTEM_STATUS"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_NAME "DV_Driving_Dynamics_1"
#define CAN_MCU_DV_DRIVING_DYNAMICS_2_NAME "DV_Driving_Dynamics_2"
#define CAN_MCU_ASB_DATALOGGER_NAME "ASB_DATALOGGER"

/* Signal Names. */
#define CAN_MCU_VCU_SUSP_R_SUSP_POT_RL_NAME "Susp_Pot_RL"
#define CAN_MCU_VCU_SUSP_R_SUSP_POT_RR_NAME "Susp_Pot_RR"
#define CAN_MCU_DASH_APPS_APPS1_RAW_NAME "APPS1_Raw"
#define CAN_MCU_DASH_APPS_APPS2_RAW_NAME "APPS2_Raw"
#define CAN_MCU_DASH_APPS_APPS_SC_SIGNALS_NAME "APPS_SC_Signals"
#define CAN_MCU_DASH_APPS_APPS_SC_SUP_NAME "APPS_SC_Sup"
#define CAN_MCU_DASH_APPS_APPS_SC_GND_NAME "APPS_SC_GND"
#define CAN_MCU_DASH_APPS_APPS_OUT_OF_RANGE_NAME "APPS_Out_Of_Range"
#define CAN_MCU_VCU_BOOLS_BUZZER_NAME "Buzzer"
#define CAN_MCU_VCU_BOOLS_ENABLE_NAME "Enable"
#define CAN_MCU_VCU_BOOLS_SAFE_STATE_NAME "Safe_State"
#define CAN_MCU_VCU_BOOLS_AMS_NAME "AMS"
#define CAN_MCU_VCU_BOOLS_IMD_NAME "IMD"
#define CAN_MCU_VCU_BOOLS_MODE_NAME "Mode"
#define CAN_MCU_DASH_STEERING_STEERING_NAME "Steering"
#define CAN_MCU_DASH_BOOLS_START_NAME "Start"
#define CAN_MCU_DASH_BOOLS_ADD_ACT_NAME "AddAct"
#define CAN_MCU_DASH_BOOLS_STEERING_IMPLAUSIBILITY_NAME "Steering_Implausibility"
#define CAN_MCU_DASH_BOOLS_MONITOR_NAME "Monitor"
#define CAN_MCU_DASH_BOOLS_COOLING_STATUS_NAME "Cooling_status"
#define CAN_MCU_DASH_BOOLS_TS_OFF_NAME "TS_Off"
#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_NAME "Rotary_Active_Mode"
#define CAN_MCU_DASH_BOOLS_SETUP_NAME "Setup"
#define CAN_MCU_DASH_BOOLS_MAIN_MENU_NAME "Main_menu"
#define CAN_MCU_DASH_BOOLS_SUB_MENU_NAME "Sub_menu"
#define CAN_MCU_DASH_BOOLS_SCREEN_NAME "Screen"
#define CAN_MCU_DASH_BOOLS_RESET_SDC_NAME "Reset_SDC"
#define CAN_MCU_DASH_SUSP_F_SUSP_POT_FL_NAME "Susp_Pot_FL"
#define CAN_MCU_DASH_SUSP_F_SUSP_POT_FR_NAME "Susp_Pot_FR"
#define CAN_MCU_VCU_ADU_POWER_K_W_NAME "Power_kW"
#define CAN_MCU_VCU_ADU_VICOR_THERMISTOR_NAME "Vicor_Thermistor"
#define CAN_MCU_VCU_ADU_RECOM_THERMISTOR_NAME "Recom_Thermistor"
#define CAN_MCU_VCU_ADU_VELOCITY_NAME "Velocity"
#define CAN_MCU_VCU_ADU_SENSOR_ERROR_NAME "Sensor_Error"
#define CAN_MCU_VCU_ADU_INVERTER_RPM_MAX_ACTUAL_NAME "Inverter_RPM_Max_Actual"
#define CAN_MCU_VCU_ADU_TV_ON_NAME "TV_ON"
#define CAN_MCU_VCU_ADU_REGEN_ON_NAME "REGEN_ON"
#define CAN_MCU_VCU_ADU_TC_ON_NAME "TC_ON"
#define CAN_MCU_VCU_RL_INFO_IGBT_RL_NAME "IGBT_RL"
#define CAN_MCU_VCU_RL_INFO_MOTOR_TEMP_RL_NAME "Motor_Temp_RL"
#define CAN_MCU_VCU_RL_INFO_RPM_RL_NAME "RPM_RL"
#define CAN_MCU_VCU_RL_INFO_TORQUE_COMMANDED_RL_NAME "Torque_Commanded_RL"
#define CAN_MCU_VCU_RL_INFO_IRMS_RL_NAME "Irms_RL"
#define CAN_MCU_VCU_RR_INFO_IGBT_RR_NAME "IGBT_RR"
#define CAN_MCU_VCU_RR_INFO_MOTOR_TEMP_RR_NAME "Motor_Temp_RR"
#define CAN_MCU_VCU_RR_INFO_RPM_RR_NAME "RPM_RR"
#define CAN_MCU_VCU_RR_INFO_TORQUE_COMMANDED_RR_NAME "Torque_Commanded_RR"
#define CAN_MCU_VCU_RR_INFO_IRMS_RR_NAME "Irms_RR"
#define CAN_MCU_ASB_ASMS_STATE_NAME "ASMS_State"
#define CAN_MCU_ASB_TSMS_OUT_NAME "TSMS_Out"
#define CAN_MCU_ASB_ASB_LED_NAME "ASB_LED"
#define CAN_MCU_ASB_INITIAL_CHECKED_NAME "Initial_Checked"
#define CAN_MCU_ASB_MONITOR_TANK_PRESSURE_NAME "Monitor_Tank_Pressure"
#define CAN_MCU_ASB_MONITOR_BRAKE_PRESSURE_NAME "Monitor_Brake_Pressure"
#define CAN_MCU_ASB_MONITOR_SERVO_CHECK_NAME "Monitor_Servo_Check"
#define CAN_MCU_ASB_MONITOR_APU_NAME "Monitor_APU"
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_NAME "Initial_Check_Step"
#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_NAME "Service_Brake_Status"
#define CAN_MCU_ASB_EBS_STATUS_NAME "EBS_Status"
#define CAN_MCU_ASB_EBS_TANK_PRESSURE_NAME "EBS_Tank_Pressure"
#define CAN_MCU_APU_COMMAND_THROTTLE_BRAKE_COMMANDED_NAME "Throttle_Brake_Commanded"
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_NAME "AS_Mission"
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_NAME "AS_State"
#define CAN_MCU_APU_STATE_MISSION_AS_SET_FINISHED_NAME "AS_Set_Finished"
#define CAN_MCU_DASH_AMI_AMI_NAME "AMI"
#define CAN_MCU_ISABELLEN_IDC_IDC_MEASUREMENT_ERROR_NAME "Idc_Measurement_Error"
#define CAN_MCU_ISABELLEN_IDC_SYSTEM_ERROR_NAME "System_Error"
#define CAN_MCU_ISABELLEN_IDC_IDC_NAME "Idc"
#define CAN_MCU_ISABELLEN_VDC_VDC_MEASUREMENT_ERROR_NAME "Vdc_Measurement_error"
#define CAN_MCU_ISABELLEN_VDC_VDC_NAME "Vdc"
#define CAN_MCU_ISABELLEN_PDC_PDC_MEASUREMENT_ERROR_NAME "Pdc_Measurement_Error"
#define CAN_MCU_ISABELLEN_PDC_PDC_NAME "Pdc"
#define CAN_MCU_ISABELLEN_ENERGY_ENERGY_MEASUREMENT_ERROR_NAME "Energy_Measurement_Error"
#define CAN_MCU_ISABELLEN_ENERGY_ENERGY_NAME "Energy"
#define CAN_MCU_BLDC_TX_1_STATUS_WORD_NAME "StatusWord"
#define CAN_MCU_BLDC_TX_1_MODES_OF_OPERATION_DISPLAY_NAME "ModesOfOperation_Display"
#define CAN_MCU_BLDC_RX_1_CONTROLWORD_NAME "Controlword"
#define CAN_MCU_BLDC_RX_1_MODE_OF_OPERATION_NAME "ModeOfOperation"
#define CAN_MCU_BLDC_RX_1_MOTOR_DRIVE_SUBMODE_SELECT_NAME "MotorDriveSubmodeSelect"
#define CAN_MCU_BLDC_RX_2_TARGET_POSITION_NAME "Target_Position"
#define CAN_MCU_BLDC_RX_2_PROFILE_VELOCITY_NAME "Profile_Velocity"
#define CAN_MCU_BLDC_TX_2_POSITION_ACTUAL_VALUE_NAME "Position_Actual_Value"
#define CAN_MCU_BLDC_TX_3_VELOCITY_ACTUAL_VALUE_NAME "Velocity_Actual_Value"
#define CAN_MCU_BLDC_RX_3_TARGET_VELOCITY_NAME "Target_Velocity"
#define CAN_MCU_BLDC_TX_4_DIGITAL_INPUT_NAME "Digital_Input"
#define CAN_MCU_BLDC_RX_4_DIGITAL_OUTPUT_NAME "Digital_Output"
#define CAN_MCU_DASH_STEERING_COMMAND_POSITION_TARGET_NAME "Position_Target"
#define CAN_MCU_DASH_STEERING_COMMAND_VELOCITY_TARGET_NAME "Velocity_Target"
#define CAN_MCU_DASH_STEERING_COMMAND_STEERING_MODE_NAME "Steering_Mode"
#define CAN_MCU_APU_TUNING_VCU_VALUE_NAME "Value"
#define CAN_MCU_APU_TUNING_VCU_INDEX_NAME "Index"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_S1_MIN_NAME "S1_Min"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_S1_MAX_NAME "S1_Max"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_S2_MIN_NAME "S2_Min"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_S2_MAX_NAME "S2_Max"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_S3_MIN_NAME "S3_Min"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_S3_MAX_NAME "S3_Max"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_S4_MIN_NAME "S4_Min"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_S4_MAX_NAME "S4_Max"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_S5_MIN_NAME "S5_Min"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_S5_MAX_NAME "S5_Max"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_S6_MIN_NAME "S6_Min"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_S6_MAX_NAME "S6_Max"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_S7_MIN_NAME "S7_Min"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_S7_MAX_NAME "S7_Max"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_S8_MIN_NAME "S8_Min"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_S8_MAX_NAME "S8_Max"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_S9_MIN_NAME "S9_Min"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_S9_MAX_NAME "S9_Max"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_S10_MIN_NAME "S10_Min"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_S10_MAX_NAME "S10_Max"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_S11_MIN_NAME "S11_Min"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_S11_MAX_NAME "S11_Max"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_S12_MIN_NAME "S12_Min"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_S12_MAX_NAME "S12_Max"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_S1_MAX_TEMP_NAME "S1_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_S2_MAX_TEMP_NAME "S2_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_S3_MAX_TEMP_NAME "S3_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_S4_MAX_TEMP_NAME "S4_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_S5_MAX_TEMP_NAME "S5_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_S6_MAX_TEMP_NAME "S6_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_S7_MAX_TEMP_NAME "S7_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_S8_MAX_TEMP_NAME "S8_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_S9_MAX_TEMP_NAME "S9_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_S10_MAX_TEMP_NAME "S10_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_S11_MAX_TEMP_NAME "S11_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_S12_MAX_TEMP_NAME "S12_Max_Temp"
#define CAN_MCU_APU_TEMP_THA_ENHMERWTHEI_CPU_TEMP_NAME "CPU_Temp"
#define CAN_MCU_APU_TEMP_THA_ENHMERWTHEI_GPU_TEMP_NAME "GPU_Temp"
#define CAN_MCU_DASH_BRAKE_BRAKE_PRESSURE_FRONT_NAME "BRAKE_Pressure_Front"
#define CAN_MCU_DASH_BRAKE_BRAKE_PRESSURE_REAR_NAME "BRAKE_Pressure_Rear"
#define CAN_MCU_DASH_BRAKE_BRAKE_SC_GND_NAME "BRAKE_SC_GND"
#define CAN_MCU_DASH_BRAKE_BRAKE_SC_SUP_NAME "BRAKE_SC_Sup"
#define CAN_MCU_DASH_BRAKE_BRAKE_OUT_OF_RANGE_NAME "BRAKE_Out_of_Range"
#define CAN_MCU_ISABELLEN_16_BIT_VDC_16_BIT_NAME "Vdc_16_bit"
#define CAN_MCU_ISABELLEN_16_BIT_PDC_16_BIT_NAME "Pdc_16_bit"
#define CAN_MCU_ISABELLEN_16_BIT_IDC_16_BIT_NAME "Idc_16_bit"
#define CAN_MCU_VCU_APPS_APPS_NAME "APPS"
#define CAN_MCU_RES_STATUS_STOP_NAME "Stop"
#define CAN_MCU_RES_STATUS_TOGGLE_NAME "Toggle"
#define CAN_MCU_RES_STATUS_BUTTON_NAME "Button"
#define CAN_MCU_RES_STATUS_SIGNAL_STRENGTH_NAME "Signal_Strength"
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_NAME "Requested_State"
#define CAN_MCU_APU_RES_INIT_ADDRESED_NODE_NAME "Addresed_Node"
#define CAN_MCU_DASH_TUNING_VCU_GENERAL_INDEX_NAME "Index"
#define CAN_MCU_DASH_TUNING_VCU_GENERAL_VALUE_NAME "Value"
#define CAN_MCU_DASH_TUNING_VCU_CONTROL_INDEX_NAME "Index"
#define CAN_MCU_DASH_TUNING_VCU_CONTROL_VALUE_NAME "Value"
#define CAN_MCU_DASH_ADU_STEERING_16BIT_NAME "Steering_16bit"
#define CAN_MCU_VCU_FL_INFO_IGBT_FL_NAME "IGBT_FL"
#define CAN_MCU_VCU_FL_INFO_MOTOR_TEMP_FL_NAME "Motor_Temp_FL"
#define CAN_MCU_VCU_FL_INFO_RPM_FL_NAME "RPM_FL"
#define CAN_MCU_VCU_FL_INFO_TORQUE_COMMANDED_FL_NAME "Torque_Commanded_FL"
#define CAN_MCU_VCU_FL_INFO_IRMS_FL_NAME "Irms_FL"
#define CAN_MCU_VCU_FR_INFO_IGBT_FR_NAME "IGBT_FR"
#define CAN_MCU_VCU_FR_INFO_MOTOR_TEMP_FR_NAME "Motor_Temp_FR"
#define CAN_MCU_VCU_FR_INFO_RPM_FR_NAME "RPM_FR"
#define CAN_MCU_VCU_FR_INFO_TORQUE_COMMANDED_FR_NAME "Torque_Commanded_FR"
#define CAN_MCU_VCU_FR_INFO_IRMS_FR_NAME "Irms_FR"
#define CAN_MCU_DASH_SDC_DETECTION_BEFORE_INERTIA_NAME "Before_Inertia"
#define CAN_MCU_DASH_SDC_DETECTION_AFTER_BSPD_NAME "After_BSPD"
#define CAN_MCU_DASH_SDC_DETECTION_BEFORE_TSMS_NAME "Before_TSMS"
#define CAN_MCU_DASH_SDC_DETECTION_AFTER_RES_NAME "After_RES"
#define CAN_MCU_VCU_SERVO_CONTROL_SERVO_CONTROL_NAME "Servo_control"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_ALT_ALTITUDE_NAME "ALTITUDE"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_ALT_UNDULATION_NAME "UNDULATION"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_ALT_NUM_SV_NAME "NUM_SV"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_ALT_DIFF_CORR_AGE_NAME "DIFF_CORR_AGE"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_LATITUDE_NAME "LATITUDE"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_POS_LONGITUDE_NAME "LONGITUDE"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_VEL_VELOCITY_N_NAME "VELOCITY_N"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_VEL_VELOCITY_E_NAME "VELOCITY_E"
#define CAN_MCU_SBG_ECAN_MSG_GPS1_VEL_VELOCITY_D_NAME "VELOCITY_D"
#define CAN_MCU_SBG_ECAN_MSG_ODO_VEL_VELOCITY_NAME "VELOCITY"
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_BODY_VELOCITY_X_NAME "VELOCITY_X"
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_BODY_VELOCITY_Y_NAME "VELOCITY_Y"
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_BODY_VELOCITY_Z_NAME "VELOCITY_Z"
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_NED_VELOCITY_N_NAME "VELOCITY_N"
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_NED_VELOCITY_E_NAME "VELOCITY_E"
#define CAN_MCU_SBG_ECAN_MSG_EKF_VEL_NED_VELOCITY_D_NAME "VELOCITY_D"
#define CAN_MCU_SBG_ECAN_MSG_EKF_POS_LATITUDE_NAME "LATITUDE"
#define CAN_MCU_SBG_ECAN_MSG_EKF_POS_LONGITUDE_NAME "LONGITUDE"
#define CAN_MCU_SBG_ECAN_MSG_EKF_EULER_ROLL_NAME "ROLL"
#define CAN_MCU_SBG_ECAN_MSG_EKF_EULER_PITCH_NAME "PITCH"
#define CAN_MCU_SBG_ECAN_MSG_EKF_EULER_YAW_NAME "YAW"
#define CAN_MCU_SBG_ECAN_MSG_IMU_GYRO_GYRO_X_NAME "GYRO_X"
#define CAN_MCU_SBG_ECAN_MSG_IMU_GYRO_GYRO_Y_NAME "GYRO_Y"
#define CAN_MCU_SBG_ECAN_MSG_IMU_GYRO_GYRO_Z_NAME "GYRO_Z"
#define CAN_MCU_SBG_ECAN_MSG_IMU_ACCEL_ACCEL_X_NAME "ACCEL_X"
#define CAN_MCU_SBG_ECAN_MSG_IMU_ACCEL_ACCEL_Y_NAME "ACCEL_Y"
#define CAN_MCU_SBG_ECAN_MSG_IMU_ACCEL_ACCEL_Z_NAME "ACCEL_Z"
#define CAN_MCU_VCU_APPS_RAW_APPS1_RAW_MIN_NAME "APPS1_Raw_Min"
#define CAN_MCU_VCU_APPS_RAW_APPS2_RAW_MIN_NAME "APPS2_Raw_Min"
#define CAN_MCU_VCU_APPS_RAW_APPS1_RAW_MAX_NAME "APPS1_Raw_Max"
#define CAN_MCU_VCU_APPS_RAW_APPS2_RAW_MAX_NAME "APPS2_Raw_Max"
#define CAN_MCU_VCU_STEERING_CALIBRATED_STEERING_ANGLE_CALIBRATED_NAME "Steering_Angle_Calibrated"
#define CAN_MCU_VCU_STEERING_CALIBRATED_STEERING_OFFSET_NAME "Steering_Offset"
#define CAN_MCU_DV_SYSTEM_STATUS_AS_STATE_NAME "AS_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_ASB_EBS_STATE_NAME "ASB_EBS_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_NAME "AMI_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_STEERING_STATE_NAME "STEERING_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_ASB_REDUNDANCY_STATE_NAME "ASB_REDUNDANCY_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_LAP_COUNTER_NAME "LAP_COUNTER"
#define CAN_MCU_DV_SYSTEM_STATUS_CONES_COUNT_ACTUAL_NAME "CONES_COUNT_ACTUAL"
#define CAN_MCU_DV_SYSTEM_STATUS_CONES_COUNT_ALL_NAME "CONES_COUNT_ALL"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_SPEED_ACTUAL_NAME "Speed_actual"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_SPEED_TARGET_NAME "Speed_target"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_STEERING_ANGLE_ACTUAL_NAME "Steering_angle_actual"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_STEERING_ANGLE_TARGET_NAME "Steering_angle_target"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_BRAKE_HYDR_ACRTUAL_NAME "Brake_hydr_acrtual"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_BRAKE_HYDR_TARGET_NAME "Brake_hydr_target"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_MOTOR_MOMENT_ACTUAL_NAME "Motor_moment_actual"
#define CAN_MCU_DV_DRIVING_DYNAMICS_1_MOTOR_MOMENT_TARGET_NAME "Motor_moment_target"
#define CAN_MCU_DV_DRIVING_DYNAMICS_2_ACCELERATION_LONGITUDINAL_NAME "Acceleration_longitudinal"
#define CAN_MCU_DV_DRIVING_DYNAMICS_2_ACCELERATION_LATERAL_NAME "Acceleration_lateral"
#define CAN_MCU_DV_DRIVING_DYNAMICS_2_YAW_RATE_NAME "Yaw_Rate"
#define CAN_MCU_ASB_DATALOGGER_EBS_PNEUMATIC_PRESSURE_NAME "EBS_Pneumatic_Pressure"
#define CAN_MCU_ASB_DATALOGGER_BRAKE_PRESSURE_REAR_NAME "Brake_Pressure_Rear"
#define CAN_MCU_ASB_DATALOGGER_BRAKE_PRESSURE_FRONT_NAME "Brake_Pressure_Front"
#define CAN_MCU_ASB_DATALOGGER_EB_SSTATE_UNAVAILABLE_NAME "EBSstate_unavailable"
#define CAN_MCU_ASB_DATALOGGER_EB_SSTATE_ARMED_NAME "EBSstate_armed"
#define CAN_MCU_ASB_DATALOGGER_EB_SSTATE_ACTIVATED_NAME "EBSstate_activated"
#define CAN_MCU_ASB_DATALOGGER_SERVICEBRAKESTATE_DISENGAGED_NAME "Servicebrakestate_disengaged"
#define CAN_MCU_ASB_DATALOGGER_SERVICEBRAKESTATE_ENGAGED_NAME "Servicebrakestate_engaged"
#define CAN_MCU_ASB_DATALOGGER_SERVICEBRAKESTATE_AVAILABLE_NAME "Servicebrakestate_available"
#define CAN_MCU_ASB_DATALOGGER_WATCHDOG_OK_NAME "Watchdog_OK"
#define CAN_MCU_ASB_DATALOGGER_VALVE_INTERLOCK_OK_NAME "ValveInterlock_OK"
#define CAN_MCU_ASB_DATALOGGER_SERVO_INTERLOCK_OK_NAME "ServoInterlock_OK"
#define CAN_MCU_ASB_DATALOGGER_AS_STATE_NAME "AS_State"

/**
 * Signals in message VCU_SUSP_R.
 *
 * The measurements for rear suspension

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_susp_r_t {
    /**
     * Suspension Potentiometers Rear Left
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_rl;

    /**
     * Suspension Potentiometers Rear Right
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_rr;
};

/**
 * Signals in message DASH_APPS.
 *
 * APPS Raw Values & SCS states, Brake Pressure & SCS states
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_apps_t {
    /**
     * Range: 0..1 (0..1 ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps1_raw;

    /**
     * Range: 0..1 (0..1 ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps2_raw;

    /**
     * checks if APPSs's signals are short circuited
     *
     * Range: 0..1 (0..1 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_signals;

    /**
     * checks if any of the APPS signal is short circuited to supply
     *
     * Range: 0..1 (0..1 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_sup;

    /**
     * checks if any of the APPS signal is short circuited to GND
     *
     * Range: 0..1 (0..1 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_gnd;

    /**
     * checks if any of APPSs' signals is out of range
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_out_of_range;
};

/**
 * Signals in message VCU_BOOLS.
 *
 * LEDs to Dashboard and bools from ECU to ASB and AUX
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_bools_t {
    /**
     * Signal to trigger Buzzer
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t buzzer;

    /**
     * Enable ON (R2D sequence done)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable;

    /**
     * Safe State sent from Fusebox.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t safe_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ams;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message DASH_STEERING.
 *
 * Steering Sensor
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_steering_t {
    /**
     * Steering Angle Sensor value in rad
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float steering;
};

/**
 * Signals in message DASH_BOOLS.
 *
 * Dashboard buttons and toggle switches
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_bools_t {
    /**
     * Start Button on Dashboard. Start == 1 if button pressed.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t start;

    /**
     * AddAct Button signal, either from dashboard or external button, depending on vehicle Mode. AddAct == 1 if correct button pressed.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t add_act;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_implausibility;

    /**
     * Monitor place
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor;

    /**
     * Cooling enable
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cooling_status;

    /**
     * TS_Off analog signal received from Fusebox
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off;

    /**
     * Range: 0..15 (0..15 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_active_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t setup;

    /**
     * Which place is chosen
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t main_menu;

    /**
     * The current place at the secont column of the menu
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sub_menu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t screen;

    /**
     * External Reset button for SDC. Reset_SDC == 1 if button pressed.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t reset_sdc;
};

/**
 * Signals in message DASH_SUSP_F.
 *
 * Front Suspension Strain Gauges
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_susp_f_t {
    /**
     * Suspension Potentiometers Front Left
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_fl;

    /**
     * Suspension Potentiometers Front Right
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_fr;
};

/**
 * Signals in message VCU_ADU.
 *
 * Signals for use by the dashboard display

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_adu_t {
    /**
     * Final Power Target computed by VCU
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t power_k_w;

    /**
     * DCDC Vicor Thermistor Temperature
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t vicor_thermistor;

    /**
     * DCDC Recom Thermistor Temperature
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t recom_thermistor;

    /**
     * Vehicle Longitudinal Velocity in km/h
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t velocity;

    /**
     * Error detected in sensor necessary for Control Systems. Bitfield values still to be decided.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sensor_error;

    /**
     * A Percentage of 6500 RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_rpm_max_actual;

    /**
     * Torque Vectoring ON
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_on;

    /**
     * Regenerative Braking ON
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_on;

    /**
     * Traction Control ON
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_on;
};

/**
 * Signals in message VCU_RL_Info.
 *
 * RL Inverter and Motor Info
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_rl_info_t {
    /**
     * RL Inverter IGBT Temperature
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t igbt_rl;

    /**
     * RL Motor Temperature
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t motor_temp_rl;

    /**
     * RL Motor RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rpm_rl;

    /**
     * RL Motor Commanded Torque by Control
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t torque_commanded_rl;

    /**
     * RL Inverter RMS Current
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t irms_rl;
};

/**
 * Signals in message VCU_RR_Info.
 *
 * RR Inverter and Motor Info
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_rr_info_t {
    /**
     * RR Inverter IGBT Temperature
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t igbt_rr;

    /**
     * RR Motor Temperature
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t motor_temp_rr;

    /**
     * RR Motor RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rpm_rr;

    /**
     * RR Motor Commanded Torque by Control
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t torque_commanded_rr;

    /**
     * RR Inverter RMS Current
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t irms_rr;
};

/**
 * Signals in message ASB.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_asb_t {
    /**
     * It's the actual state of TSMS
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asms_state;

    /**
     * It's the actual state of TSMS
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsms_out;

    /**
     * For visible check when EBS is activated
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb_led;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t initial_checked;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_tank_pressure;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_brake_pressure;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_servo_check;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_apu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t initial_check_step;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_status;

    /**
     * Mechanical EBS' actual state
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_status;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t ebs_tank_pressure;
};

/**
 * Signals in message APU_COMMAND.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_command_t {
    /**
     * Throttle/Brake command [-1, 1]
     *
     * Range: -1.0..1.0 (-1..1 -)
     * Scale: 1
     * Offset: 0
     */
    float throttle_brake_commanded;
};

/**
 * Signals in message APU_STATE_MISSION.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_state_mission_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t as_mission;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_set_finished;
};

/**
 * Signals in message DASH_AMI.
 *
 * Autonomous Mission Indicator 
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_ami_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami;
};

/**
 * Signals in message ISABELLEN_IDC.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_idc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t idc_measurement_error;

    /**
     * Range: -
     * Scale: 7
     * Offset: 0
     */
    uint8_t system_error;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int32_t idc;
};

/**
 * Signals in message ISABELLEN_VDC.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_vdc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t vdc_measurement_error;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int32_t vdc;
};

/**
 * Signals in message ISABELLEN_PDC.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_pdc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pdc_measurement_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pdc;
};

/**
 * Signals in message ISABELLEN_ENERGY.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_energy_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t energy_measurement_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t energy;
};

/**
 * Signals in message BLDC_TX_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t status_word;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t modes_of_operation_display;
};

/**
 * Signals in message BLDC_RX_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t controlword;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode_of_operation;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_drive_submode_select;
};

/**
 * Signals in message BLDC_RX_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t target_position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t profile_velocity;
};

/**
 * Signals in message BLDC_TX_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position_actual_value;
};

/**
 * Signals in message BLDC_TX_3.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t velocity_actual_value;
};

/**
 * Signals in message BLDC_RX_3.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t target_velocity;
};

/**
 * Signals in message BLDC_TX_4.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t digital_input;
};

/**
 * Signals in message BLDC_RX_4.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t digital_output;
};

/**
 * Signals in message DASH_STEERING_COMMAND.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_steering_command_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float position_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t velocity_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_mode;
};

/**
 * Signals in message APU_Tuning_VCU.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_tuning_vcu_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t value;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t index;
};

/**
 * Signals in message BMS_MIN_MAX_S1_S2.
 *
 * Min Max Voltages for Segment 1,2
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s1_s2_t {
    /**
     * Segment 1 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s1_min;

    /**
     * Segment 1 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s1_max;

    /**
     * Segment 2 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s2_min;

    /**
     * Segment 2 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s2_max;
};

/**
 * Signals in message BMS_MIN_MAX_S3_S4.
 *
 * Min Max Voltages for Segment 3, 4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s3_s4_t {
    /**
     * Segment 3 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s3_min;

    /**
     * Segment 3 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s3_max;

    /**
     * Segment 4 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s4_min;

    /**
     * Segment 4 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s4_max;
};

/**
 * Signals in message BMS_MIN_MAX_S5_S6.
 *
 * Min Max Voltages for Segment 5, 6
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s5_s6_t {
    /**
     * Segment 5 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s5_min;

    /**
     * Segment 5 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s5_max;

    /**
     * Segment 6 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s6_min;

    /**
     * Segment 6 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s6_max;
};

/**
 * Signals in message BMS_MIN_MAX_S7_S8.
 *
 * Min Max Voltages for Segment 7, 8
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s7_s8_t {
    /**
     * Segment 7 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s7_min;

    /**
     * Segment 7 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s7_max;

    /**
     * Segment 8 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s8_min;

    /**
     * Segment 8 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s8_max;
};

/**
 * Signals in message BMS_MIN_MAX_S9_S10.
 *
 * Min Max Voltages for Segment 9, 10
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s9_s10_t {
    /**
     * Segment 9 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s9_min;

    /**
     * Segment 9 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s9_max;

    /**
     * Segment 10 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s10_min;

    /**
     * Segment 10 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s10_max;
};

/**
 * Signals in message BMS_MIN_MAX_S11_S12.
 *
 * Min Max Voltages for Segment 11, 12
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s11_s12_t {
    /**
     * Segment 11 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s11_min;

    /**
     * Segment 11 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s11_max;

    /**
     * Segment 12 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s12_min;

    /**
     * Segment 12 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s12_max;
};

/**
 * Signals in message BMS_Max_Temp_S1_S4.
 *
 * Max Temperature for Segments 1, 2, 3, 4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s1_s4_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s1_max_temp;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s2_max_temp;

    /**
     * Segment 3 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s3_max_temp;

    /**
     * Segment 4 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s4_max_temp;
};

/**
 * Signals in message BMS_Max_Temp_S5_S8.
 *
 * Max Temperature for Segments 5, 6, 7, 8
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s5_s8_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s5_max_temp;

    /**
     * Segment 6 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s6_max_temp;

    /**
     * Segment 7 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s7_max_temp;

    /**
     * Segment 8 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s8_max_temp;
};

/**
 * Signals in message BMS_Max_Temp_S9_S12.
 *
 * Max Temperature for Segments 9, 10, 11, 12

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s9_s12_t {
    /**
     * Segment 9 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s9_max_temp;

    /**
     * Segment 10 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s10_max_temp;

    /**
     * Segment 11 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s11_max_temp;

    /**
     * Segment 12 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s12_max_temp;
};

/**
 * Signals in message APU_TEMP_THA_ENHMERWTHEI.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_temp_tha_enhmerwthei_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t cpu_temp;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t gpu_temp;
};

/**
 * Signals in message DASH_BRAKE.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_brake_t {
    /**
     * Range: 0..2000000 (0..20000 bar)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t brake_pressure_front;

    /**
     * Range: 0..2000000 (0..20000 bar)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t brake_pressure_rear;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_sc_gnd;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_sc_sup;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_out_of_range;
};

/**
 * Signals in message ISABELLEN_16_bit.
 *
 * Convert Isabellen's values from 32 bit to 16 bit
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_16_bit_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t vdc_16_bit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t pdc_16_bit;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t idc_16_bit;
};

/**
 * Signals in message VCU_APPS.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_apps_t {
    /**
     * APPS Value (0-1000)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps;
};

/**
 * Signals in message RES_STATUS.
 *
 * RES Status
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_res_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t stop;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t toggle;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t button;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_strength;
};

/**
 * Signals in message APU_RES_INIT.
 *
 * A "CAN MASTER" sends this message in order to set RES CAN into operating mode
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_res_init_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t requested_state;

    /**
     * ID of addressed device. 0x11 in RES's case
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t addresed_node;
};

/**
 * Signals in message DASH_Tuning_VCUGeneral.
 *
 * VCU General Parameter tuning from dashboard display
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_tuning_vcu_general_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t index;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t value;
};

/**
 * Signals in message DASH_Tuning_VCUControl.
 *
 * VCU Control Parameter tuning from dashboard display
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_tuning_vcu_control_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t index;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t value;
};

/**
 * Signals in message DASH_ADU.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_adu_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_16bit;
};

/**
 * Signals in message VCU_FL_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_fl_info_t {
    /**
     * FL Inverter IGBT Temperature
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t igbt_fl;

    /**
     * FL Moror Temperature
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t motor_temp_fl;

    /**
     * FL Motor RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rpm_fl;

    /**
     * FL Motor Commanded Torque by Control
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t torque_commanded_fl;

    /**
     * FL Inverter RMS Current
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t irms_fl;
};

/**
 * Signals in message VCU_FR_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_fr_info_t {
    /**
     * FR Inverter IGBT Temperature
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t igbt_fr;

    /**
     * FR Motor Temperature
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t motor_temp_fr;

    /**
     * FR Motor RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rpm_fr;

    /**
     * FR Motor Commanded Torque by Control
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t torque_commanded_fr;

    /**
     * FR Inverter RMS Current
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t irms_fr;
};

/**
 * Signals in message DASH_SDC_Detection.
 *
 * 1 energized 0 non-energized.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_sdc_detection_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t before_inertia;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t after_bspd;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t before_tsms;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t after_res;
};

/**
 * Signals in message VCU_Servo_Control.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_servo_control_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_control;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t {
    /**
     * Range: -2147480000..2147480000 (-2147480..2147480 m)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t altitude;

    /**
     * Range: -32768..32767 (-163.84..163.835 m)
     * Scale: 0.005
     * Offset: 0
     */
    int16_t undulation;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t num_sv;

    /**
     * Range: 0..255 (0..255 s)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diff_corr_age;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_gps1_pos_t {
    /**
     * Range: -2147483648..2147483647 (-214.74836..214.74836 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -2147483648..2147483647 (-214.74836..214.74836 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_gps1_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_ODO_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_odo_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_ekf_vel_body_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_z;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_ekf_pos_t {
    /**
     * Range: -2147483648..2147483647 (-214.74836..214.74836 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -2147483648..2147483647 (-214.74836..214.74836 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_EULER.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_ekf_euler_t {
    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_GYRO.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_imu_gyro_t {
    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_x;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_y;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_sbg_ecan_msg_imu_accel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_z;
};

/**
 * Signals in message VCU_APPS_Raw.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_apps_raw_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps1_raw_min;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps2_raw_min;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps1_raw_max;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps2_raw_max;
};

/**
 * Signals in message VCU_Steering_Calibrated.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_vcu_steering_calibrated_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float steering_angle_calibrated;

    /**
     * Steering Sensor offset set in VCU
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_offset;
};

/**
 * Signals in message DV_SYSTEM_STATUS.
 *
 * FOR DATALOGGER
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dv_system_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb_ebs_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb_redundancy_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t cones_count_all;
};

/**
 * Signals in message DV_Driving_Dynamics_1.
 *
 * FOR DATALOGGER
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dv_driving_dynamics_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_actual;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_acrtual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_target;
};

/**
 * Signals in message DV_Driving_Dynamics_2.
 *
 * FOR DATALOGGER
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dv_driving_dynamics_2_t {
    /**
     * Range: -
     * Scale: 0.00195313
     * Offset: 0
     */
    int16_t acceleration_longitudinal;

    /**
     * Range: -
     * Scale: 0.00195313
     * Offset: 0
     */
    int16_t acceleration_lateral;

    /**
     * Range: -
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t yaw_rate;
};

/**
 * Signals in message ASB_DATALOGGER.
 *
 * ASB messages mentioned in ASF, for FSG Datalogger
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_asb_datalogger_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_pneumatic_pressure;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_rear;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_front;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t eb_sstate_unavailable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t eb_sstate_armed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t eb_sstate_activated;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servicebrakestate_disengaged;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servicebrakestate_engaged;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servicebrakestate_available;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t watchdog_ok;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t valve_interlock_ok;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_interlock_ok;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;
};

/**
 * Pack message VCU_SUSP_R.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_susp_r_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_susp_r_t *src_p,
    size_t size);

/**
 * Unpack message VCU_SUSP_R.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_susp_r_unpack(
    struct can_mcu_vcu_susp_r_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_SUSP_R.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_susp_r_init(struct can_mcu_vcu_susp_r_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_vcu_susp_r_susp_pot_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_susp_r_susp_pot_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_susp_r_susp_pot_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_vcu_susp_r_susp_pot_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_susp_r_susp_pot_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_susp_r_susp_pot_rr_is_in_range(uint16_t value);

/**
 * Pack message DASH_APPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_apps_t *src_p,
    size_t size);

/**
 * Unpack message DASH_APPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_apps_unpack(
    struct can_mcu_dash_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_APPS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_apps_init(struct can_mcu_dash_apps_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_apps_apps1_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps1_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps1_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_apps_apps2_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps2_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps2_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_apps_sc_signals_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps_sc_signals_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps_sc_signals_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_apps_sc_sup_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps_sc_sup_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps_sc_sup_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_apps_sc_gnd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps_sc_gnd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps_sc_gnd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_apps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps_out_of_range_is_in_range(uint8_t value);

/**
 * Pack message VCU_BOOLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_bools_t *src_p,
    size_t size);

/**
 * Unpack message VCU_BOOLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_bools_unpack(
    struct can_mcu_vcu_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_BOOLS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_bools_init(struct can_mcu_vcu_bools_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_bools_buzzer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_bools_buzzer_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_bools_buzzer_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_bools_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_bools_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_bools_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_bools_safe_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_bools_safe_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_bools_safe_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_bools_ams_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_bools_ams_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_bools_ams_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_bools_imd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_bools_imd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_bools_imd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_bools_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_bools_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_bools_mode_is_in_range(uint8_t value);

/**
 * Pack message DASH_STEERING.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_steering_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_steering_t *src_p,
    size_t size);

/**
 * Unpack message DASH_STEERING.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_steering_unpack(
    struct can_mcu_dash_steering_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_STEERING.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_steering_init(struct can_mcu_dash_steering_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_dash_steering_steering_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_steering_steering_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_steering_steering_is_in_range(float value);

/**
 * Pack message DASH_BOOLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_bools_t *src_p,
    size_t size);

/**
 * Unpack message DASH_BOOLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_bools_unpack(
    struct can_mcu_dash_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_BOOLS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_bools_init(struct can_mcu_dash_bools_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_start_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_start_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_add_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_add_act_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_add_act_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_steering_implausibility_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_steering_implausibility_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_steering_implausibility_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_monitor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_monitor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_monitor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_cooling_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_cooling_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_cooling_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_ts_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_ts_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_ts_off_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_rotary_active_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_rotary_active_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_rotary_active_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_setup_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_setup_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_setup_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_main_menu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_main_menu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_main_menu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_sub_menu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_sub_menu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_sub_menu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_screen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_screen_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_screen_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_reset_sdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_reset_sdc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_reset_sdc_is_in_range(uint8_t value);

/**
 * Pack message DASH_SUSP_F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_susp_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_susp_f_t *src_p,
    size_t size);

/**
 * Unpack message DASH_SUSP_F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_susp_f_unpack(
    struct can_mcu_dash_susp_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_SUSP_F.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_susp_f_init(struct can_mcu_dash_susp_f_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_susp_pot_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_susp_pot_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_susp_pot_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_susp_pot_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_susp_pot_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_susp_pot_fr_is_in_range(uint16_t value);

/**
 * Pack message VCU_ADU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_adu_t *src_p,
    size_t size);

/**
 * Unpack message VCU_ADU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_adu_unpack(
    struct can_mcu_vcu_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_ADU.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_adu_init(struct can_mcu_vcu_adu_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_vcu_adu_power_k_w_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_power_k_w_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_power_k_w_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_adu_vicor_thermistor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_vicor_thermistor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_vicor_thermistor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_adu_recom_thermistor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_recom_thermistor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_recom_thermistor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_vcu_adu_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_adu_sensor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_sensor_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_sensor_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_adu_inverter_rpm_max_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_inverter_rpm_max_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_inverter_rpm_max_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_adu_tv_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_tv_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_tv_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_adu_regen_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_regen_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_regen_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_adu_tc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_adu_tc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_adu_tc_on_is_in_range(uint8_t value);

/**
 * Pack message VCU_RL_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_rl_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_rl_info_t *src_p,
    size_t size);

/**
 * Unpack message VCU_RL_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_rl_info_unpack(
    struct can_mcu_vcu_rl_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_RL_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_rl_info_init(struct can_mcu_vcu_rl_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_rl_info_igbt_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rl_info_igbt_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rl_info_igbt_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_rl_info_motor_temp_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rl_info_motor_temp_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rl_info_motor_temp_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_rl_info_rpm_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rl_info_rpm_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rl_info_rpm_rl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_rl_info_torque_commanded_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rl_info_torque_commanded_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rl_info_torque_commanded_rl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_rl_info_irms_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rl_info_irms_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rl_info_irms_rl_is_in_range(int16_t value);

/**
 * Pack message VCU_RR_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_rr_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_rr_info_t *src_p,
    size_t size);

/**
 * Unpack message VCU_RR_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_rr_info_unpack(
    struct can_mcu_vcu_rr_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_RR_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_rr_info_init(struct can_mcu_vcu_rr_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_rr_info_igbt_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rr_info_igbt_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rr_info_igbt_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_rr_info_motor_temp_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rr_info_motor_temp_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rr_info_motor_temp_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_rr_info_rpm_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rr_info_rpm_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rr_info_rpm_rr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_rr_info_torque_commanded_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rr_info_torque_commanded_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rr_info_torque_commanded_rr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_rr_info_irms_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_rr_info_irms_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_rr_info_irms_rr_is_in_range(int16_t value);

/**
 * Pack message ASB.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_asb_pack(
    uint8_t *dst_p,
    const struct can_mcu_asb_t *src_p,
    size_t size);

/**
 * Unpack message ASB.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_asb_unpack(
    struct can_mcu_asb_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ASB.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_asb_init(struct can_mcu_asb_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_asms_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_asms_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_asms_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_tsms_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_tsms_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_tsms_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_asb_led_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_asb_led_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_asb_led_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_initial_checked_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_initial_checked_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_initial_checked_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_tank_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_tank_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_tank_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_brake_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_brake_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_brake_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_servo_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_servo_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_servo_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_apu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_apu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_apu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_asb_initial_check_step_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_initial_check_step_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_initial_check_step_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_service_brake_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_service_brake_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_service_brake_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_ebs_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_ebs_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_ebs_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_asb_ebs_tank_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_ebs_tank_pressure_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_ebs_tank_pressure_is_in_range(int16_t value);

/**
 * Pack message APU_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_command_t *src_p,
    size_t size);

/**
 * Unpack message APU_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_command_unpack(
    struct can_mcu_apu_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_COMMAND.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_command_init(struct can_mcu_apu_command_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_apu_command_throttle_brake_commanded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_command_throttle_brake_commanded_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_command_throttle_brake_commanded_is_in_range(float value);

/**
 * Pack message APU_STATE_MISSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_state_mission_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_state_mission_t *src_p,
    size_t size);

/**
 * Unpack message APU_STATE_MISSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_state_mission_unpack(
    struct can_mcu_apu_state_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_STATE_MISSION.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_state_mission_init(struct can_mcu_apu_state_mission_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_apu_state_mission_as_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_state_mission_as_mission_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_state_mission_as_mission_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_state_mission_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_state_mission_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_state_mission_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_state_mission_as_set_finished_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_state_mission_as_set_finished_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_state_mission_as_set_finished_is_in_range(uint8_t value);

/**
 * Pack message DASH_AMI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_ami_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_ami_t *src_p,
    size_t size);

/**
 * Unpack message DASH_AMI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_ami_unpack(
    struct can_mcu_dash_ami_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_AMI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_ami_init(struct can_mcu_dash_ami_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_ami_ami_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_ami_ami_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_ami_ami_is_in_range(uint8_t value);

/**
 * Pack message ISABELLEN_IDC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_idc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_idc_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_IDC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_idc_unpack(
    struct can_mcu_isabellen_idc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_IDC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_idc_init(struct can_mcu_isabellen_idc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_idc_idc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_idc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_idc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_idc_system_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_system_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_system_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_idc_idc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_idc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_idc_is_in_range(int32_t value);

/**
 * Pack message ISABELLEN_VDC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_vdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_vdc_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_VDC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_vdc_unpack(
    struct can_mcu_isabellen_vdc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_VDC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_vdc_init(struct can_mcu_isabellen_vdc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_vdc_vdc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_vdc_vdc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_vdc_vdc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_vdc_vdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_vdc_vdc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_vdc_vdc_is_in_range(int32_t value);

/**
 * Pack message ISABELLEN_PDC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_pdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_pdc_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_PDC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_pdc_unpack(
    struct can_mcu_isabellen_pdc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_PDC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_pdc_init(struct can_mcu_isabellen_pdc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_pdc_pdc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_pdc_pdc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_pdc_pdc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_pdc_pdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_pdc_pdc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_pdc_pdc_is_in_range(int32_t value);

/**
 * Pack message ISABELLEN_ENERGY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_energy_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_energy_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_ENERGY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_energy_unpack(
    struct can_mcu_isabellen_energy_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_ENERGY.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_energy_init(struct can_mcu_isabellen_energy_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_energy_energy_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_energy_energy_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_energy_energy_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_energy_energy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_energy_energy_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_energy_energy_is_in_range(int32_t value);

/**
 * Pack message BLDC_TX_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_1_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_1_unpack(
    struct can_mcu_bldc_tx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_TX_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_tx_1_init(struct can_mcu_bldc_tx_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bldc_tx_1_status_word_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_1_status_word_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_1_status_word_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_bldc_tx_1_modes_of_operation_display_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_1_modes_of_operation_display_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_1_modes_of_operation_display_is_in_range(int8_t value);

/**
 * Pack message BLDC_RX_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_1_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_1_unpack(
    struct can_mcu_bldc_rx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_RX_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_rx_1_init(struct can_mcu_bldc_rx_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bldc_rx_1_controlword_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_controlword_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_controlword_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_bldc_rx_1_mode_of_operation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_mode_of_operation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_mode_of_operation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_1_motor_drive_submode_select_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_motor_drive_submode_select_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_motor_drive_submode_select_is_in_range(uint32_t value);

/**
 * Pack message BLDC_RX_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_2_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_2_unpack(
    struct can_mcu_bldc_rx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_RX_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_rx_2_init(struct can_mcu_bldc_rx_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_bldc_rx_2_target_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_2_target_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_2_target_position_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_2_profile_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_2_profile_velocity_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_2_profile_velocity_is_in_range(uint32_t value);

/**
 * Pack message BLDC_TX_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_2_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_2_unpack(
    struct can_mcu_bldc_tx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_TX_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_tx_2_init(struct can_mcu_bldc_tx_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_bldc_tx_2_position_actual_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_2_position_actual_value_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_2_position_actual_value_is_in_range(int32_t value);

/**
 * Pack message BLDC_TX_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_3_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_3_unpack(
    struct can_mcu_bldc_tx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_TX_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_tx_3_init(struct can_mcu_bldc_tx_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_bldc_tx_3_velocity_actual_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_3_velocity_actual_value_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_3_velocity_actual_value_is_in_range(int16_t value);

/**
 * Pack message BLDC_RX_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_3_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_3_unpack(
    struct can_mcu_bldc_rx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_RX_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_rx_3_init(struct can_mcu_bldc_rx_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_bldc_rx_3_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_3_target_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_3_target_velocity_is_in_range(int16_t value);

/**
 * Pack message BLDC_TX_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_4_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_4_unpack(
    struct can_mcu_bldc_tx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_TX_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_tx_4_init(struct can_mcu_bldc_tx_4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_tx_4_digital_input_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_4_digital_input_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_4_digital_input_is_in_range(uint32_t value);

/**
 * Pack message BLDC_RX_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_4_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_4_unpack(
    struct can_mcu_bldc_rx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_RX_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_rx_4_init(struct can_mcu_bldc_rx_4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_4_digital_output_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_4_digital_output_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_4_digital_output_is_in_range(uint32_t value);

/**
 * Pack message DASH_STEERING_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_steering_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_steering_command_t *src_p,
    size_t size);

/**
 * Unpack message DASH_STEERING_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_steering_command_unpack(
    struct can_mcu_dash_steering_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_STEERING_COMMAND.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_steering_command_init(struct can_mcu_dash_steering_command_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_dash_steering_command_position_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_steering_command_position_target_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_steering_command_position_target_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_dash_steering_command_velocity_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_steering_command_velocity_target_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_steering_command_velocity_target_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_steering_command_steering_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_steering_command_steering_mode_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_steering_command_steering_mode_is_in_range(uint16_t value);

/**
 * Pack message APU_Tuning_VCU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_tuning_vcu_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_tuning_vcu_t *src_p,
    size_t size);

/**
 * Unpack message APU_Tuning_VCU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_tuning_vcu_unpack(
    struct can_mcu_apu_tuning_vcu_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_Tuning_VCU.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_tuning_vcu_init(struct can_mcu_apu_tuning_vcu_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_apu_tuning_vcu_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_tuning_vcu_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_tuning_vcu_value_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_tuning_vcu_index_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_tuning_vcu_index_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_tuning_vcu_index_is_in_range(uint8_t value);

/**
 * Pack message BMS_MIN_MAX_S1_S2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s1_s2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s1_s2_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S1_S2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s1_s2_unpack(
    struct can_mcu_bms_min_max_s1_s2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S1_S2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s1_s2_init(struct can_mcu_bms_min_max_s1_s2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s1_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s1_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s1_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s1_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s1_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s1_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s2_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s2_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s2_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s2_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s2_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s2_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S3_S4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s3_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s3_s4_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S3_S4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s3_s4_unpack(
    struct can_mcu_bms_min_max_s3_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S3_S4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s3_s4_init(struct can_mcu_bms_min_max_s3_s4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s3_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s3_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s3_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s3_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s3_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s3_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s4_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s4_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s4_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s4_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s4_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s4_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S5_S6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s5_s6_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s5_s6_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S5_S6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s5_s6_unpack(
    struct can_mcu_bms_min_max_s5_s6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S5_S6.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s5_s6_init(struct can_mcu_bms_min_max_s5_s6_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s5_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s5_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s5_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s5_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s5_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s5_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s6_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s6_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s6_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s6_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s6_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s6_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S7_S8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s7_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s7_s8_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S7_S8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s7_s8_unpack(
    struct can_mcu_bms_min_max_s7_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S7_S8.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s7_s8_init(struct can_mcu_bms_min_max_s7_s8_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s7_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s7_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s7_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s7_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s7_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s7_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s8_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s8_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s8_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s8_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s8_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s8_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S9_S10.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s9_s10_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s9_s10_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S9_S10.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s9_s10_unpack(
    struct can_mcu_bms_min_max_s9_s10_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S9_S10.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s9_s10_init(struct can_mcu_bms_min_max_s9_s10_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s9_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s9_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s9_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s9_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s9_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s9_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s10_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s10_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s10_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s10_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s10_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s10_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S11_S12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s11_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s11_s12_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S11_S12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s11_s12_unpack(
    struct can_mcu_bms_min_max_s11_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S11_S12.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s11_s12_init(struct can_mcu_bms_min_max_s11_s12_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s11_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s11_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s11_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s11_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s11_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s11_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s12_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s12_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s12_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s12_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s12_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s12_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S1_S4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s1_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s1_s4_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S1_S4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s1_s4_unpack(
    struct can_mcu_bms_max_temp_s1_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Max_Temp_S1_S4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_max_temp_s1_s4_init(struct can_mcu_bms_max_temp_s1_s4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s1_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s1_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s1_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s2_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s2_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s2_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s3_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s3_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s3_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s4_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s4_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s4_max_temp_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S5_S8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s5_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s5_s8_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S5_S8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s5_s8_unpack(
    struct can_mcu_bms_max_temp_s5_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Max_Temp_S5_S8.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_max_temp_s5_s8_init(struct can_mcu_bms_max_temp_s5_s8_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s5_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s5_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s5_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s6_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s6_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s6_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s7_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s7_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s7_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s8_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s8_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s8_max_temp_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S9_S12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s9_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s9_s12_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S9_S12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s9_s12_unpack(
    struct can_mcu_bms_max_temp_s9_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Max_Temp_S9_S12.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_max_temp_s9_s12_init(struct can_mcu_bms_max_temp_s9_s12_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s9_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s9_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s9_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s10_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s10_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s10_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s11_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s11_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s11_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s12_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s12_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s12_max_temp_is_in_range(uint16_t value);

/**
 * Pack message APU_TEMP_THA_ENHMERWTHEI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_temp_tha_enhmerwthei_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_temp_tha_enhmerwthei_t *src_p,
    size_t size);

/**
 * Unpack message APU_TEMP_THA_ENHMERWTHEI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_temp_tha_enhmerwthei_unpack(
    struct can_mcu_apu_temp_tha_enhmerwthei_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_TEMP_THA_ENHMERWTHEI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_temp_tha_enhmerwthei_init(struct can_mcu_apu_temp_tha_enhmerwthei_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_apu_temp_tha_enhmerwthei_cpu_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_temp_tha_enhmerwthei_cpu_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_temp_tha_enhmerwthei_cpu_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_apu_temp_tha_enhmerwthei_gpu_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_temp_tha_enhmerwthei_gpu_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_temp_tha_enhmerwthei_gpu_temp_is_in_range(uint16_t value);

/**
 * Pack message DASH_BRAKE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_brake_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_brake_t *src_p,
    size_t size);

/**
 * Unpack message DASH_BRAKE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_brake_unpack(
    struct can_mcu_dash_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_BRAKE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_brake_init(struct can_mcu_dash_brake_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_brake_brake_pressure_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_pressure_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_pressure_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_brake_brake_pressure_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_pressure_rear_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_pressure_rear_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_brake_brake_sc_gnd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_sc_gnd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_sc_gnd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_brake_brake_sc_sup_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_sc_sup_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_sc_sup_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_brake_brake_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_out_of_range_is_in_range(uint8_t value);

/**
 * Pack message ISABELLEN_16_bit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_16_bit_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_16_bit_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_16_bit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_16_bit_unpack(
    struct can_mcu_isabellen_16_bit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_16_bit.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_16_bit_init(struct can_mcu_isabellen_16_bit_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_isabellen_16_bit_vdc_16_bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_16_bit_vdc_16_bit_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_16_bit_vdc_16_bit_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_isabellen_16_bit_pdc_16_bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_16_bit_pdc_16_bit_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_16_bit_pdc_16_bit_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_isabellen_16_bit_idc_16_bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_16_bit_idc_16_bit_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_16_bit_idc_16_bit_is_in_range(int16_t value);

/**
 * Pack message VCU_APPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_apps_t *src_p,
    size_t size);

/**
 * Unpack message VCU_APPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_apps_unpack(
    struct can_mcu_vcu_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_APPS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_apps_init(struct can_mcu_vcu_apps_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_vcu_apps_apps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_apps_apps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_apps_apps_is_in_range(uint16_t value);

/**
 * Pack message RES_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_res_status_pack(
    uint8_t *dst_p,
    const struct can_mcu_res_status_t *src_p,
    size_t size);

/**
 * Unpack message RES_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_res_status_unpack(
    struct can_mcu_res_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RES_STATUS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_res_status_init(struct can_mcu_res_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_res_status_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_res_status_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_res_status_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_res_status_toggle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_res_status_toggle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_res_status_toggle_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_res_status_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_res_status_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_res_status_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_res_status_signal_strength_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_res_status_signal_strength_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_res_status_signal_strength_is_in_range(uint8_t value);

/**
 * Pack message APU_RES_INIT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_res_init_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_res_init_t *src_p,
    size_t size);

/**
 * Unpack message APU_RES_INIT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_res_init_unpack(
    struct can_mcu_apu_res_init_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_RES_INIT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_res_init_init(struct can_mcu_apu_res_init_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_res_init_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_res_init_requested_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_res_init_requested_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_res_init_addresed_node_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_res_init_addresed_node_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_res_init_addresed_node_is_in_range(uint8_t value);

/**
 * Pack message DASH_Tuning_VCUGeneral.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_tuning_vcu_general_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_tuning_vcu_general_t *src_p,
    size_t size);

/**
 * Unpack message DASH_Tuning_VCUGeneral.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_tuning_vcu_general_unpack(
    struct can_mcu_dash_tuning_vcu_general_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_Tuning_VCUGeneral.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_tuning_vcu_general_init(struct can_mcu_dash_tuning_vcu_general_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_tuning_vcu_general_index_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_tuning_vcu_general_index_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_tuning_vcu_general_index_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_dash_tuning_vcu_general_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_tuning_vcu_general_value_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_tuning_vcu_general_value_is_in_range(uint32_t value);

/**
 * Pack message DASH_Tuning_VCUControl.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_tuning_vcu_control_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_tuning_vcu_control_t *src_p,
    size_t size);

/**
 * Unpack message DASH_Tuning_VCUControl.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_tuning_vcu_control_unpack(
    struct can_mcu_dash_tuning_vcu_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_Tuning_VCUControl.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_tuning_vcu_control_init(struct can_mcu_dash_tuning_vcu_control_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_tuning_vcu_control_index_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_tuning_vcu_control_index_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_tuning_vcu_control_index_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_dash_tuning_vcu_control_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_tuning_vcu_control_value_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_tuning_vcu_control_value_is_in_range(uint32_t value);

/**
 * Pack message DASH_ADU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_adu_t *src_p,
    size_t size);

/**
 * Unpack message DASH_ADU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_adu_unpack(
    struct can_mcu_dash_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_ADU.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_adu_init(struct can_mcu_dash_adu_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_dash_adu_steering_16bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_adu_steering_16bit_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_adu_steering_16bit_is_in_range(int16_t value);

/**
 * Pack message VCU_FL_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_fl_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_fl_info_t *src_p,
    size_t size);

/**
 * Unpack message VCU_FL_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_fl_info_unpack(
    struct can_mcu_vcu_fl_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_FL_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_fl_info_init(struct can_mcu_vcu_fl_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_fl_info_igbt_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fl_info_igbt_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fl_info_igbt_fl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_fl_info_motor_temp_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fl_info_motor_temp_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fl_info_motor_temp_fl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_fl_info_rpm_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fl_info_rpm_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fl_info_rpm_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_fl_info_torque_commanded_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fl_info_torque_commanded_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fl_info_torque_commanded_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_fl_info_irms_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fl_info_irms_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fl_info_irms_fl_is_in_range(int16_t value);

/**
 * Pack message VCU_FR_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_fr_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_fr_info_t *src_p,
    size_t size);

/**
 * Unpack message VCU_FR_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_fr_info_unpack(
    struct can_mcu_vcu_fr_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_FR_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_fr_info_init(struct can_mcu_vcu_fr_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_fr_info_igbt_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fr_info_igbt_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fr_info_igbt_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_fr_info_motor_temp_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fr_info_motor_temp_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fr_info_motor_temp_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_fr_info_rpm_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fr_info_rpm_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fr_info_rpm_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_fr_info_torque_commanded_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fr_info_torque_commanded_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fr_info_torque_commanded_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_fr_info_irms_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_fr_info_irms_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_fr_info_irms_fr_is_in_range(int16_t value);

/**
 * Pack message DASH_SDC_Detection.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_sdc_detection_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_sdc_detection_t *src_p,
    size_t size);

/**
 * Unpack message DASH_SDC_Detection.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_sdc_detection_unpack(
    struct can_mcu_dash_sdc_detection_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_SDC_Detection.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_sdc_detection_init(struct can_mcu_dash_sdc_detection_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_sdc_detection_before_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_sdc_detection_before_inertia_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_sdc_detection_before_inertia_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_sdc_detection_after_bspd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_sdc_detection_after_bspd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_sdc_detection_after_bspd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_sdc_detection_before_tsms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_sdc_detection_before_tsms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_sdc_detection_before_tsms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_sdc_detection_after_res_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_sdc_detection_after_res_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_sdc_detection_after_res_is_in_range(uint8_t value);

/**
 * Pack message VCU_Servo_Control.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_servo_control_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_servo_control_t *src_p,
    size_t size);

/**
 * Unpack message VCU_Servo_Control.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_servo_control_unpack(
    struct can_mcu_vcu_servo_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_Servo_Control.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_servo_control_init(struct can_mcu_vcu_servo_control_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_vcu_servo_control_servo_control_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_servo_control_servo_control_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_servo_control_servo_control_is_in_range(uint8_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_gps1_pos_alt_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_gps1_pos_alt_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_gps1_pos_alt_init(struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_is_in_range(uint8_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_gps1_pos_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_gps1_pos_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_POS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_gps1_pos_init(struct can_mcu_sbg_ecan_msg_gps1_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_sbg_ecan_msg_gps1_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_sbg_ecan_msg_gps1_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_gps1_vel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_gps1_vel_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_gps1_vel_init(struct can_mcu_sbg_ecan_msg_gps1_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_odo_vel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_odo_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_odo_vel_unpack(
    struct can_mcu_sbg_ecan_msg_odo_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_odo_vel_init(struct can_mcu_sbg_ecan_msg_odo_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_odo_vel_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_odo_vel_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_odo_vel_velocity_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_ekf_vel_body_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_ekf_vel_body_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_ekf_vel_body_init(struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_ekf_vel_ned_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_ekf_vel_ned_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_ekf_vel_ned_init(struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_ekf_pos_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_ekf_pos_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_POS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_ekf_pos_init(struct can_mcu_sbg_ecan_msg_ekf_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_sbg_ecan_msg_ekf_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_sbg_ecan_msg_ekf_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_ekf_euler_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_euler_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_ekf_euler_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_euler_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_ekf_euler_init(struct can_mcu_sbg_ecan_msg_ekf_euler_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_euler_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_euler_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_euler_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_euler_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_euler_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_euler_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_ekf_euler_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_ekf_euler_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_ekf_euler_yaw_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_imu_gyro_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_imu_gyro_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_imu_gyro_unpack(
    struct can_mcu_sbg_ecan_msg_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_imu_gyro_init(struct can_mcu_sbg_ecan_msg_imu_gyro_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_sbg_ecan_msg_imu_accel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_imu_accel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_sbg_ecan_msg_imu_accel_unpack(
    struct can_mcu_sbg_ecan_msg_imu_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_sbg_ecan_msg_imu_accel_init(struct can_mcu_sbg_ecan_msg_imu_accel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_imu_accel_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_imu_accel_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_imu_accel_accel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_imu_accel_accel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_sbg_ecan_msg_imu_accel_accel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_sbg_ecan_msg_imu_accel_accel_z_is_in_range(int16_t value);

/**
 * Pack message VCU_APPS_Raw.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_apps_raw_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_apps_raw_t *src_p,
    size_t size);

/**
 * Unpack message VCU_APPS_Raw.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_apps_raw_unpack(
    struct can_mcu_vcu_apps_raw_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_APPS_Raw.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_apps_raw_init(struct can_mcu_vcu_apps_raw_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_vcu_apps_raw_apps1_raw_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_apps_raw_apps1_raw_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_apps_raw_apps1_raw_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_vcu_apps_raw_apps2_raw_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_apps_raw_apps2_raw_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_apps_raw_apps2_raw_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_vcu_apps_raw_apps1_raw_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_apps_raw_apps1_raw_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_apps_raw_apps1_raw_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_vcu_apps_raw_apps2_raw_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_apps_raw_apps2_raw_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_apps_raw_apps2_raw_max_is_in_range(uint16_t value);

/**
 * Pack message VCU_Steering_Calibrated.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_vcu_steering_calibrated_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_steering_calibrated_t *src_p,
    size_t size);

/**
 * Unpack message VCU_Steering_Calibrated.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_vcu_steering_calibrated_unpack(
    struct can_mcu_vcu_steering_calibrated_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_Steering_Calibrated.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_vcu_steering_calibrated_init(struct can_mcu_vcu_steering_calibrated_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_vcu_steering_calibrated_steering_angle_calibrated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_steering_calibrated_steering_angle_calibrated_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_steering_calibrated_steering_angle_calibrated_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_vcu_steering_calibrated_steering_offset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_vcu_steering_calibrated_steering_offset_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_vcu_steering_calibrated_steering_offset_is_in_range(int16_t value);

/**
 * Pack message DV_SYSTEM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dv_system_status_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_system_status_t *src_p,
    size_t size);

/**
 * Unpack message DV_SYSTEM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dv_system_status_unpack(
    struct can_mcu_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_SYSTEM_STATUS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dv_system_status_init(struct can_mcu_dv_system_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_asb_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_asb_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_asb_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_ami_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_steering_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_steering_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_steering_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_asb_redundancy_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_asb_redundancy_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_asb_redundancy_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_dv_system_status_cones_count_all_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_cones_count_all_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_cones_count_all_is_in_range(uint32_t value);

/**
 * Pack message DV_Driving_Dynamics_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dv_driving_dynamics_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_driving_dynamics_1_t *src_p,
    size_t size);

/**
 * Unpack message DV_Driving_Dynamics_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dv_driving_dynamics_1_unpack(
    struct can_mcu_dv_driving_dynamics_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_Driving_Dynamics_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dv_driving_dynamics_1_init(struct can_mcu_dv_driving_dynamics_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_driving_dynamics_1_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_1_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_1_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_driving_dynamics_1_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_1_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_1_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_dv_driving_dynamics_1_steering_angle_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_1_steering_angle_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_1_steering_angle_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_dv_driving_dynamics_1_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_1_steering_angle_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_1_steering_angle_target_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_driving_dynamics_1_brake_hydr_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_1_brake_hydr_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_1_brake_hydr_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_dv_driving_dynamics_1_motor_moment_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_1_motor_moment_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_1_motor_moment_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_dv_driving_dynamics_1_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_1_motor_moment_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_1_motor_moment_target_is_in_range(int8_t value);

/**
 * Pack message DV_Driving_Dynamics_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dv_driving_dynamics_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_driving_dynamics_2_t *src_p,
    size_t size);

/**
 * Unpack message DV_Driving_Dynamics_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dv_driving_dynamics_2_unpack(
    struct can_mcu_dv_driving_dynamics_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_Driving_Dynamics_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dv_driving_dynamics_2_init(struct can_mcu_dv_driving_dynamics_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_dv_driving_dynamics_2_acceleration_lateral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_2_acceleration_lateral_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_2_acceleration_lateral_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_dv_driving_dynamics_2_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_driving_dynamics_2_yaw_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_driving_dynamics_2_yaw_rate_is_in_range(int16_t value);

/**
 * Pack message ASB_DATALOGGER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_asb_datalogger_pack(
    uint8_t *dst_p,
    const struct can_mcu_asb_datalogger_t *src_p,
    size_t size);

/**
 * Unpack message ASB_DATALOGGER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_asb_datalogger_unpack(
    struct can_mcu_asb_datalogger_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ASB_DATALOGGER.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_asb_datalogger_init(struct can_mcu_asb_datalogger_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_ebs_pneumatic_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_ebs_pneumatic_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_ebs_pneumatic_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_brake_pressure_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_brake_pressure_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_brake_pressure_rear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_brake_pressure_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_brake_pressure_front_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_brake_pressure_front_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_eb_sstate_unavailable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_eb_sstate_unavailable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_eb_sstate_unavailable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_eb_sstate_armed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_eb_sstate_armed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_eb_sstate_armed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_eb_sstate_activated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_eb_sstate_activated_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_eb_sstate_activated_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_servicebrakestate_disengaged_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_servicebrakestate_disengaged_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_servicebrakestate_disengaged_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_servicebrakestate_engaged_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_servicebrakestate_engaged_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_servicebrakestate_engaged_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_servicebrakestate_available_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_servicebrakestate_available_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_servicebrakestate_available_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_watchdog_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_watchdog_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_watchdog_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_valve_interlock_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_valve_interlock_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_valve_interlock_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_servo_interlock_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_servo_interlock_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_servo_interlock_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_datalogger_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_datalogger_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_datalogger_as_state_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
