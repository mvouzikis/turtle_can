/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.13 Thu Dec 12 16:35:06 2024.
 */

#ifndef CAN_MCU_H
#define CAN_MCU_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_MCU_AUX_SUSP_R_FRAME_ID (0x1c2u)
#define CAN_MCU_DASH_APPS_FRAME_ID (0x64u)
#define CAN_MCU_DASH_HALL_F_FRAME_ID (0x15eu)
#define CAN_MCU_ECU_BOOLS_FRAME_ID (0x73u)
#define CAN_MCU_DASH_STEERING_FRAME_ID (0x190u)
#define CAN_MCU_DASH_BOOLS_FRAME_ID (0x131u)
#define CAN_MCU_DASH_SUSP_F_FRAME_ID (0x1c3u)
#define CAN_MCU_ECU_ADU_FRAME_ID (0x2bcu)
#define CAN_MCU_AUX_STATES_FRAME_ID (0x145u)
#define CAN_MCU_AUX_IR_CAMS_R1_FRAME_ID (0x2c4u)
#define CAN_MCU_AUX_IR_CAMS_R2_FRAME_ID (0x2c5u)
#define CAN_MCU_AUX_IR_CAMS_L1_FRAME_ID (0x2c2u)
#define CAN_MCU_AUX_IR_CAMS_L2_FRAME_ID (0x2c3u)
#define CAN_MCU_ADU_INVERTER_LEFT_FRAME_ID (0x2bdu)
#define CAN_MCU_ADU_INVERTER_RIGHT_FRAME_ID (0x2beu)
#define CAN_MCU_AUX_CABLES_FRAME_ID (0x1f4u)
#define CAN_MCU_ASB_FRAME_ID (0x23u)
#define CAN_MCU_APU_COMMAND_FRAME_ID (0x14u)
#define CAN_MCU_APU_STATE_MISSION_FRAME_ID (0x0au)
#define CAN_MCU_AMI_FRAME_ID (0x0bu)
#define CAN_MCU_ISABELLEN_IDC_FRAME_ID (0x521u)
#define CAN_MCU_ISABELLEN_VDC_FRAME_ID (0x522u)
#define CAN_MCU_ISABELLEN_PDC_FRAME_ID (0x526u)
#define CAN_MCU_ISABELLEN_ENERGY_FRAME_ID (0x528u)
#define CAN_MCU_BLDC_TX_1_FRAME_ID (0x200u)
#define CAN_MCU_BLDC_RX_1_FRAME_ID (0x27fu)
#define CAN_MCU_BLDC_RX_2_FRAME_ID (0x37fu)
#define CAN_MCU_BLDC_TX_2_FRAME_ID (0x2ffu)
#define CAN_MCU_BLDC_TX_3_FRAME_ID (0x3ffu)
#define CAN_MCU_BLDC_RX_3_FRAME_ID (0x47fu)
#define CAN_MCU_BLDC_TX_4_FRAME_ID (0x4ffu)
#define CAN_MCU_BLDC_RX_4_FRAME_ID (0x57fu)
#define CAN_MCU_STEERING_COMMAND_FRAME_ID (0x1eu)
#define CAN_MCU_INVERTER_RIGHT_INFO_FRAME_ID (0x2c0u)
#define CAN_MCU_INVERTER_LEFT_INFO_FRAME_ID (0x2bfu)
#define CAN_MCU_ECU_PARAM_APU_FRAME_ID (0x320u)
#define CAN_MCU_ECU_PARAM_GENERAL_FRAME_ID (0x321u)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_FRAME_ID (0x640u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_FRAME_ID (0x641u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_FRAME_ID (0x642u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_FRAME_ID (0x643u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_FRAME_ID (0x644u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_FRAME_ID (0x645u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_FRAME_ID (0x646u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_FRAME_ID (0x647u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_FRAME_ID (0x648u)
#define CAN_MCU_APU_TEMP_FRAME_ID (0x5aau)
#define CAN_MCU_DASH_BRAKE_FRAME_ID (0x65u)
#define CAN_MCU_ISABELLEN_16_BIT_FRAME_ID (0x523u)
#define CAN_MCU_COOLING_TELE_FRAME_ID (0x660u)
#define CAN_MCU_ECU_PARAM_CONTROL_FRAME_ID (0x322u)
#define CAN_MCU_IMU_ACCEL_FRAME_ID (0x121u)
#define CAN_MCU_IMU_GYRO_FRAME_ID (0x122u)
#define CAN_MCU_EKF_EULER_FRAME_ID (0x132u)
#define CAN_MCU_EKF_POS_FRAME_ID (0x134u)
#define CAN_MCU_EKF_VEL_BODY_FRAME_ID (0x139u)
#define CAN_MCU_EKF_VEL_NED_FRAME_ID (0x137u)
#define CAN_MCU_ODO_VEL_FRAME_ID (0x161u)
#define CAN_MCU_GPS1_VEL_FRAME_ID (0x171u)
#define CAN_MCU_GPS1_POS_FRAME_ID (0x175u)
#define CAN_MCU_GPS1_POS_ALT_FRAME_ID (0x176u)
#define CAN_MCU_ECU_PARAM_GENERAL_TELE_FRAME_ID (0x661u)
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_FRAME_ID (0x662u)
#define CAN_MCU_ECU_APPS_FRAME_ID (0x325u)
#define CAN_MCU_RES_STATUS_FRAME_ID (0x191u)
#define CAN_MCU_DV_SYSTEM_STATUS_FRAME_ID (0x502u)
#define CAN_MCU_APU_RES_INIT_FRAME_ID (0x00u)

/* Frame lengths in bytes. */
#define CAN_MCU_AUX_SUSP_R_LENGTH (8u)
#define CAN_MCU_DASH_APPS_LENGTH (7u)
#define CAN_MCU_DASH_HALL_F_LENGTH (4u)
#define CAN_MCU_ECU_BOOLS_LENGTH (2u)
#define CAN_MCU_DASH_STEERING_LENGTH (4u)
#define CAN_MCU_DASH_BOOLS_LENGTH (6u)
#define CAN_MCU_DASH_SUSP_F_LENGTH (8u)
#define CAN_MCU_ECU_ADU_LENGTH (8u)
#define CAN_MCU_AUX_STATES_LENGTH (6u)
#define CAN_MCU_AUX_IR_CAMS_R1_LENGTH (8u)
#define CAN_MCU_AUX_IR_CAMS_R2_LENGTH (8u)
#define CAN_MCU_AUX_IR_CAMS_L1_LENGTH (8u)
#define CAN_MCU_AUX_IR_CAMS_L2_LENGTH (8u)
#define CAN_MCU_ADU_INVERTER_LEFT_LENGTH (8u)
#define CAN_MCU_ADU_INVERTER_RIGHT_LENGTH (8u)
#define CAN_MCU_AUX_CABLES_LENGTH (4u)
#define CAN_MCU_ASB_LENGTH (8u)
#define CAN_MCU_APU_COMMAND_LENGTH (4u)
#define CAN_MCU_APU_STATE_MISSION_LENGTH (3u)
#define CAN_MCU_AMI_LENGTH (1u)
#define CAN_MCU_ISABELLEN_IDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_VDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_PDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_ENERGY_LENGTH (6u)
#define CAN_MCU_BLDC_TX_1_LENGTH (3u)
#define CAN_MCU_BLDC_RX_1_LENGTH (7u)
#define CAN_MCU_BLDC_RX_2_LENGTH (8u)
#define CAN_MCU_BLDC_TX_2_LENGTH (4u)
#define CAN_MCU_BLDC_TX_3_LENGTH (2u)
#define CAN_MCU_BLDC_RX_3_LENGTH (2u)
#define CAN_MCU_BLDC_TX_4_LENGTH (4u)
#define CAN_MCU_BLDC_RX_4_LENGTH (4u)
#define CAN_MCU_STEERING_COMMAND_LENGTH (8u)
#define CAN_MCU_INVERTER_RIGHT_INFO_LENGTH (8u)
#define CAN_MCU_INVERTER_LEFT_INFO_LENGTH (8u)
#define CAN_MCU_ECU_PARAM_APU_LENGTH (8u)
#define CAN_MCU_ECU_PARAM_GENERAL_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_LENGTH (8u)
#define CAN_MCU_APU_TEMP_LENGTH (4u)
#define CAN_MCU_DASH_BRAKE_LENGTH (8u)
#define CAN_MCU_ISABELLEN_16_BIT_LENGTH (8u)
#define CAN_MCU_COOLING_TELE_LENGTH (8u)
#define CAN_MCU_ECU_PARAM_CONTROL_LENGTH (8u)
#define CAN_MCU_IMU_ACCEL_LENGTH (6u)
#define CAN_MCU_IMU_GYRO_LENGTH (6u)
#define CAN_MCU_EKF_EULER_LENGTH (6u)
#define CAN_MCU_EKF_POS_LENGTH (8u)
#define CAN_MCU_EKF_VEL_BODY_LENGTH (6u)
#define CAN_MCU_EKF_VEL_NED_LENGTH (6u)
#define CAN_MCU_ODO_VEL_LENGTH (2u)
#define CAN_MCU_GPS1_VEL_LENGTH (6u)
#define CAN_MCU_GPS1_POS_LENGTH (8u)
#define CAN_MCU_GPS1_POS_ALT_LENGTH (8u)
#define CAN_MCU_ECU_PARAM_GENERAL_TELE_LENGTH (8u)
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_LENGTH (8u)
#define CAN_MCU_ECU_APPS_LENGTH (8u)
#define CAN_MCU_RES_STATUS_LENGTH (8u)
#define CAN_MCU_DV_SYSTEM_STATUS_LENGTH (5u)
#define CAN_MCU_APU_RES_INIT_LENGTH (2u)

/* Extended or standard frame types. */
#define CAN_MCU_AUX_SUSP_R_IS_EXTENDED (0)
#define CAN_MCU_DASH_APPS_IS_EXTENDED (0)
#define CAN_MCU_DASH_HALL_F_IS_EXTENDED (0)
#define CAN_MCU_ECU_BOOLS_IS_EXTENDED (0)
#define CAN_MCU_DASH_STEERING_IS_EXTENDED (0)
#define CAN_MCU_DASH_BOOLS_IS_EXTENDED (0)
#define CAN_MCU_DASH_SUSP_F_IS_EXTENDED (0)
#define CAN_MCU_ECU_ADU_IS_EXTENDED (0)
#define CAN_MCU_AUX_STATES_IS_EXTENDED (0)
#define CAN_MCU_AUX_IR_CAMS_R1_IS_EXTENDED (0)
#define CAN_MCU_AUX_IR_CAMS_R2_IS_EXTENDED (0)
#define CAN_MCU_AUX_IR_CAMS_L1_IS_EXTENDED (0)
#define CAN_MCU_AUX_IR_CAMS_L2_IS_EXTENDED (0)
#define CAN_MCU_ADU_INVERTER_LEFT_IS_EXTENDED (0)
#define CAN_MCU_ADU_INVERTER_RIGHT_IS_EXTENDED (0)
#define CAN_MCU_AUX_CABLES_IS_EXTENDED (0)
#define CAN_MCU_ASB_IS_EXTENDED (0)
#define CAN_MCU_APU_COMMAND_IS_EXTENDED (0)
#define CAN_MCU_APU_STATE_MISSION_IS_EXTENDED (0)
#define CAN_MCU_AMI_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_IDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_VDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_PDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_ENERGY_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_1_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_1_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_2_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_2_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_3_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_3_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_4_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_4_IS_EXTENDED (0)
#define CAN_MCU_STEERING_COMMAND_IS_EXTENDED (0)
#define CAN_MCU_INVERTER_RIGHT_INFO_IS_EXTENDED (0)
#define CAN_MCU_INVERTER_LEFT_INFO_IS_EXTENDED (0)
#define CAN_MCU_ECU_PARAM_APU_IS_EXTENDED (0)
#define CAN_MCU_ECU_PARAM_GENERAL_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_IS_EXTENDED (0)
#define CAN_MCU_APU_TEMP_IS_EXTENDED (0)
#define CAN_MCU_DASH_BRAKE_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_16_BIT_IS_EXTENDED (0)
#define CAN_MCU_COOLING_TELE_IS_EXTENDED (0)
#define CAN_MCU_ECU_PARAM_CONTROL_IS_EXTENDED (0)
#define CAN_MCU_IMU_ACCEL_IS_EXTENDED (0)
#define CAN_MCU_IMU_GYRO_IS_EXTENDED (0)
#define CAN_MCU_EKF_EULER_IS_EXTENDED (0)
#define CAN_MCU_EKF_POS_IS_EXTENDED (0)
#define CAN_MCU_EKF_VEL_BODY_IS_EXTENDED (0)
#define CAN_MCU_EKF_VEL_NED_IS_EXTENDED (0)
#define CAN_MCU_ODO_VEL_IS_EXTENDED (0)
#define CAN_MCU_GPS1_VEL_IS_EXTENDED (0)
#define CAN_MCU_GPS1_POS_IS_EXTENDED (0)
#define CAN_MCU_GPS1_POS_ALT_IS_EXTENDED (0)
#define CAN_MCU_ECU_PARAM_GENERAL_TELE_IS_EXTENDED (0)
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_IS_EXTENDED (0)
#define CAN_MCU_ECU_APPS_IS_EXTENDED (0)
#define CAN_MCU_RES_STATUS_IS_EXTENDED (0)
#define CAN_MCU_DV_SYSTEM_STATUS_IS_EXTENDED (0)
#define CAN_MCU_APU_RES_INIT_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define CAN_MCU_AUX_SUSP_R_CYCLE_TIME_MS (10u)
#define CAN_MCU_DASH_APPS_CYCLE_TIME_MS (2u)
#define CAN_MCU_DASH_HALL_F_CYCLE_TIME_MS (10u)
#define CAN_MCU_ECU_BOOLS_CYCLE_TIME_MS (100u)
#define CAN_MCU_DASH_STEERING_CYCLE_TIME_MS (10u)
#define CAN_MCU_DASH_BOOLS_CYCLE_TIME_MS (100u)
#define CAN_MCU_DASH_SUSP_F_CYCLE_TIME_MS (10u)
#define CAN_MCU_ECU_ADU_CYCLE_TIME_MS (100u)
#define CAN_MCU_AUX_STATES_CYCLE_TIME_MS (10u)
#define CAN_MCU_AUX_IR_CAMS_R1_CYCLE_TIME_MS (1000u)
#define CAN_MCU_AUX_IR_CAMS_R2_CYCLE_TIME_MS (1000u)
#define CAN_MCU_AUX_IR_CAMS_L1_CYCLE_TIME_MS (1000u)
#define CAN_MCU_AUX_IR_CAMS_L2_CYCLE_TIME_MS (1000u)
#define CAN_MCU_ADU_INVERTER_LEFT_CYCLE_TIME_MS (10u)
#define CAN_MCU_ADU_INVERTER_RIGHT_CYCLE_TIME_MS (10u)
#define CAN_MCU_AUX_CABLES_CYCLE_TIME_MS (500u)
#define CAN_MCU_ASB_CYCLE_TIME_MS (50u)
#define CAN_MCU_APU_COMMAND_CYCLE_TIME_MS (20u)
#define CAN_MCU_APU_STATE_MISSION_CYCLE_TIME_MS (125u)
#define CAN_MCU_AMI_CYCLE_TIME_MS (20u)
#define CAN_MCU_STEERING_COMMAND_CYCLE_TIME_MS (20u)
#define CAN_MCU_INVERTER_RIGHT_INFO_CYCLE_TIME_MS (50u)
#define CAN_MCU_INVERTER_LEFT_INFO_CYCLE_TIME_MS (50u)
#define CAN_MCU_ECU_PARAM_APU_CYCLE_TIME_MS (100u)
#define CAN_MCU_ECU_PARAM_GENERAL_CYCLE_TIME_MS (10u)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_CYCLE_TIME_MS (1000u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_CYCLE_TIME_MS (1000u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_CYCLE_TIME_MS (1000u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_CYCLE_TIME_MS (1000u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_CYCLE_TIME_MS (1000u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_CYCLE_TIME_MS (1000u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_CYCLE_TIME_MS (1000u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_CYCLE_TIME_MS (1000u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_CYCLE_TIME_MS (1000u)
#define CAN_MCU_DASH_BRAKE_CYCLE_TIME_MS (20u)
#define CAN_MCU_ECU_PARAM_CONTROL_CYCLE_TIME_MS (10u)
#define CAN_MCU_IMU_ACCEL_CYCLE_TIME_MS (100u)
#define CAN_MCU_IMU_GYRO_CYCLE_TIME_MS (100u)
#define CAN_MCU_EKF_EULER_CYCLE_TIME_MS (100u)
#define CAN_MCU_EKF_POS_CYCLE_TIME_MS (50u)
#define CAN_MCU_EKF_VEL_BODY_CYCLE_TIME_MS (50u)
#define CAN_MCU_EKF_VEL_NED_CYCLE_TIME_MS (50u)
#define CAN_MCU_ODO_VEL_CYCLE_TIME_MS (50u)
#define CAN_MCU_GPS1_VEL_CYCLE_TIME_MS (50u)
#define CAN_MCU_GPS1_POS_CYCLE_TIME_MS (50u)
#define CAN_MCU_GPS1_POS_ALT_CYCLE_TIME_MS (50u)
#define CAN_MCU_ECU_APPS_CYCLE_TIME_MS (10u)
#define CAN_MCU_RES_STATUS_CYCLE_TIME_MS (30u)
#define CAN_MCU_DV_SYSTEM_STATUS_CYCLE_TIME_MS (100u)
#define CAN_MCU_APU_RES_INIT_CYCLE_TIME_MS (1000u)

/* Signal choices. */
#define CAN_MCU_DASH_APPS_APPS1_RAW_LOWER_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS1_RAW_HIGHER_CHOICE (4095u)

#define CAN_MCU_DASH_APPS_APPS2_RAW_LOWER_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS2_RAW_HIGHER_CHOICE (4095u)

#define CAN_MCU_DASH_APPS_APPS_SC_SIGNALS_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS_SC_SIGNALS_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_APPS_SC_SUP_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS_SC_SUP_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_APPS_SC_GND_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS_SC_GND_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_APPS_OUT_OF_RANGE_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_APPS_OUT_OF_RANGE_ERROR_CHOICE (1u)

#define CAN_MCU_ECU_BOOLS_BRAKELIGHT_DISABLE_CHOICE (0u)
#define CAN_MCU_ECU_BOOLS_BRAKELIGHT_ENABLE_CHOICE (1u)

#define CAN_MCU_ECU_BOOLS_SERVO_COMMANDED_DE_ACTIVATED_CHOICE (0u)
#define CAN_MCU_ECU_BOOLS_SERVO_COMMANDED_ACTIVATED_CHOICE (1u)

#define CAN_MCU_ECU_BOOLS_AS_MODE_DRIVERLESS_CHOICE (0u)
#define CAN_MCU_ECU_BOOLS_AS_MODE_DRIVER_CHOICE (1u)

#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_REGEN_CHOICE (1u)
#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_TRACTION_CONTROL_CHOICE (2u)
#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_DIFFERENTIAL_CHOICE (3u)
#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_MENU_CHOICE (4u)

#define CAN_MCU_DASH_BOOLS_COOLING_STATUS_COOLING_DISABLE_CHOICE (0u)
#define CAN_MCU_DASH_BOOLS_COOLING_STATUS_COOLING_ENABLE_CHOICE (1u)

#define CAN_MCU_ECU_ADU_POWER_FAULT_NO__ERROR_CHOICE (0u)
#define CAN_MCU_ECU_ADU_POWER_FAULT_ERROR_CHOICE (1u)

#define CAN_MCU_AUX_STATES_GREEN_TSAL_DISABLE_CHOICE (0u)
#define CAN_MCU_AUX_STATES_GREEN_TSAL_ENABLE_CHOICE (1u)

#define CAN_MCU_AUX_STATES_SAFE_STATE_DISABLE_CHOICE (0u)
#define CAN_MCU_AUX_STATES_SAFE_STATE_ENABLE_CHOICE (1u)

#define CAN_MCU_AUX_STATES_TS_OFF_DISABLE_CHOICE (0u)
#define CAN_MCU_AUX_STATES_TS_OFF_ENABLE_CHOICE (1u)

#define CAN_MCU_ASB_ASMS_STATE_ASMS_OPENED_CHOICE (0u)
#define CAN_MCU_ASB_ASMS_STATE_ASMS_CLOSED_CHOICE (1u)

#define CAN_MCU_ASB_TSMS_OUT_TSMS_OPENED_CHOICE (0u)
#define CAN_MCU_ASB_TSMS_OUT_TSMS_CLOSED_CHOICE (1u)

#define CAN_MCU_ASB_ASB_LED_ASB_LED_OFF_CHOICE (0u)
#define CAN_MCU_ASB_ASB_LED_ASB_LED_ON_CHOICE (1u)

#define CAN_MCU_ASB_INITIAL_CHECKED_INITIAL_CHECK_FAILED_CHOICE (0u)
#define CAN_MCU_ASB_INITIAL_CHECKED_INITIAL_CHECK_SUCCESSFUL_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_TANK_PRESSURE_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_TANK_PRESSURE_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_BRAKE_PRESSURE_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_BRAKE_PRESSURE_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_SERVO_CHECK_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_SERVO_CHECK_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_APU_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_APU_OK_CHOICE (1u)

#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CLOSE_RES_RELAIS_AND_SDC_BEFORE_AS_RELAY_CHOICE (0)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_NOT_IN_INITIAL_CHECK_CHOICE (1)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_RE_ENABLE_WATCHDOG_CHOICE (2)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_TANK___BRAKE_PRESSURE_CHOICE (3)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CLOSE_SDC_CHOICE (4)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_EBS_ARMING_CHOICE (5)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_DE_ENERGIZE_EBS_ELECTRIC_VALVE_CHOICE (6)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_SERVICE_BRAKE_CHOICE (7)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_COMMUNICATION_WITH_APU_CHOICE (8)

#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_DISENGAGED_CHOICE (1u)
#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_ENGAGED_CHOICE (2u)
#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_AVAILABLE_CHOICE (3u)

#define CAN_MCU_ASB_EBS_STATUS_UNAVAILABLE_CHOICE (1u)
#define CAN_MCU_ASB_EBS_STATUS_ARMED_CHOICE (2u)
#define CAN_MCU_ASB_EBS_STATUS_TRIGGERED_CHOICE (3u)

#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_NO_MISSION_CHOICE (0)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_ACCELERATION_CHOICE (1)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_SKIDPAD_CHOICE (2)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_AUTOCROSS_CHOICE (3)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_TRACKDRIVE_CHOICE (4)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_EBSTEST_CHOICE (5)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_INSPECTION_CHOICE (6)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_MANUAL_DRIVING_CHOICE (7)

#define CAN_MCU_APU_STATE_MISSION_AS_STATE_MANUAL_DRIVING_CHOICE (0u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_OFF_CHOICE (1u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_READY_CHOICE (2u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_DRIVING_CHOICE (3u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_FINISHED_CHOICE (4u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_EMERGENCY_CHOICE (5u)

#define CAN_MCU_APU_STATE_MISSION_AS_SET_FINISHED_SET__FINISHED__FALSE_CHOICE (0u)
#define CAN_MCU_APU_STATE_MISSION_AS_SET_FINISHED_SET__FINISHED__TRUE_CHOICE (1u)

#define CAN_MCU_AMI_AMI_NO__MISSION_CHOICE (0u)
#define CAN_MCU_AMI_AMI_ACCELERATION_CHOICE (1u)
#define CAN_MCU_AMI_AMI_SKIDPAD_CHOICE (2u)
#define CAN_MCU_AMI_AMI_AUTOCROSS_CHOICE (3u)
#define CAN_MCU_AMI_AMI_TRACKDRIVE_CHOICE (4u)
#define CAN_MCU_AMI_AMI_EBS__TEST__CHOICE (5u)
#define CAN_MCU_AMI_AMI_INSPECTION_CHOICE (6u)
#define CAN_MCU_AMI_AMI_MANUAL__MISSION_CHOICE (7u)

#define CAN_MCU_STEERING_COMMAND_STEERING_MODE_CYCLIC_SYCHRONOUS_POSITION_MODE_CHOICE (8u)
#define CAN_MCU_STEERING_COMMAND_STEERING_MODE_CYCLIC_SYCHRONOUS_VELOCITY_MODE_CHOICE (9u)

#define CAN_MCU_RES_STATUS_STOP_ON_CHOICE (0u)
#define CAN_MCU_RES_STATUS_STOP_OFF_CHOICE (1u)

#define CAN_MCU_RES_STATUS_TOGGLE_OFF_CHOICE (0u)
#define CAN_MCU_RES_STATUS_TOGGLE_ON_CHOICE (1u)

#define CAN_MCU_RES_STATUS_BUTTON_OFF_CHOICE (0u)
#define CAN_MCU_RES_STATUS_BUTTON_ON_CHOICE (1u)

#define CAN_MCU_DV_SYSTEM_STATUS_ASSI_STATE_OFF_CHOICE (1u)
#define CAN_MCU_DV_SYSTEM_STATUS_ASSI_STATE_READY_CHOICE (2u)
#define CAN_MCU_DV_SYSTEM_STATUS_ASSI_STATE_DRIVING_CHOICE (3u)
#define CAN_MCU_DV_SYSTEM_STATUS_ASSI_STATE_EMERGENCY_BRAKE_CHOICE (4u)
#define CAN_MCU_DV_SYSTEM_STATUS_ASSI_STATE_FINISH_CHOICE (5u)

#define CAN_MCU_DV_SYSTEM_STATUS_EBS_STATE_UNAVAILABLE_CHOICE (1u)
#define CAN_MCU_DV_SYSTEM_STATUS_EBS_STATE_ARMED_CHOICE (2u)
#define CAN_MCU_DV_SYSTEM_STATUS_EBS_STATE_TRIGGERED_CHOICE (3u)

#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_ACCELERATION_CHOICE (1u)
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_SKIDPAD_CHOICE (2u)
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_TRACKDRIVE_CHOICE (3u)
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_BRAKETEST_CHOICE (4u)

#define CAN_MCU_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_DISENGAGED_CHOICE (1u)
#define CAN_MCU_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_ENGAGED_CHOICE (2u)
#define CAN_MCU_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_AVAILABLE_CHOICE (3u)

#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_OPERATIONAL_CHOICE (1u)
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_STOPPED_CHOICE (2u)
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_PRE_OPERATIONAL_CHOICE (128u)
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_RESET_NODE_CHOICE (129u)
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_RESET_COMM_CHOICE (130u)

#define CAN_MCU_APU_RES_INIT_ADDRESED_NODE_RES_ADDRESS_CHOICE (17u)

/* Frame Names. */
#define CAN_MCU_AUX_SUSP_R_NAME "AUX_SUSP_R"
#define CAN_MCU_DASH_APPS_NAME "DASH_APPS"
#define CAN_MCU_DASH_HALL_F_NAME "DASH_HALL_F"
#define CAN_MCU_ECU_BOOLS_NAME "ECU_BOOLS"
#define CAN_MCU_DASH_STEERING_NAME "DASH_STEERING"
#define CAN_MCU_DASH_BOOLS_NAME "DASH_BOOLS"
#define CAN_MCU_DASH_SUSP_F_NAME "DASH_SUSP_F"
#define CAN_MCU_ECU_ADU_NAME "ECU_ADU"
#define CAN_MCU_AUX_STATES_NAME "AUX_STATES"
#define CAN_MCU_AUX_IR_CAMS_R1_NAME "AUX_IR_CAMS_R1"
#define CAN_MCU_AUX_IR_CAMS_R2_NAME "AUX_IR_CAMS_R2"
#define CAN_MCU_AUX_IR_CAMS_L1_NAME "AUX_IR_CAMS_L1"
#define CAN_MCU_AUX_IR_CAMS_L2_NAME "AUX_IR_CAMS_L2"
#define CAN_MCU_ADU_INVERTER_LEFT_NAME "ADU_INVERTER_LEFT"
#define CAN_MCU_ADU_INVERTER_RIGHT_NAME "ADU_INVERTER_RIGHT"
#define CAN_MCU_AUX_CABLES_NAME "AUX_CABLES"
#define CAN_MCU_ASB_NAME "ASB"
#define CAN_MCU_APU_COMMAND_NAME "APU_COMMAND"
#define CAN_MCU_APU_STATE_MISSION_NAME "APU_STATE_MISSION"
#define CAN_MCU_AMI_NAME "AMI"
#define CAN_MCU_ISABELLEN_IDC_NAME "ISABELLEN_IDC"
#define CAN_MCU_ISABELLEN_VDC_NAME "ISABELLEN_VDC"
#define CAN_MCU_ISABELLEN_PDC_NAME "ISABELLEN_PDC"
#define CAN_MCU_ISABELLEN_ENERGY_NAME "ISABELLEN_ENERGY"
#define CAN_MCU_BLDC_TX_1_NAME "BLDC_TX_1"
#define CAN_MCU_BLDC_RX_1_NAME "BLDC_RX_1"
#define CAN_MCU_BLDC_RX_2_NAME "BLDC_RX_2"
#define CAN_MCU_BLDC_TX_2_NAME "BLDC_TX_2"
#define CAN_MCU_BLDC_TX_3_NAME "BLDC_TX_3"
#define CAN_MCU_BLDC_RX_3_NAME "BLDC_RX_3"
#define CAN_MCU_BLDC_TX_4_NAME "BLDC_TX_4"
#define CAN_MCU_BLDC_RX_4_NAME "BLDC_RX_4"
#define CAN_MCU_STEERING_COMMAND_NAME "STEERING_COMMAND"
#define CAN_MCU_INVERTER_RIGHT_INFO_NAME "INVERTER_RIGHT_INFO"
#define CAN_MCU_INVERTER_LEFT_INFO_NAME "INVERTER_LEFT_INFO"
#define CAN_MCU_ECU_PARAM_APU_NAME "ECU_PARAM_APU"
#define CAN_MCU_ECU_PARAM_GENERAL_NAME "ECU_PARAM_GENERAL"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_NAME "BMS_MIN_MAX_S1_S2"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_NAME "BMS_MIN_MAX_S3_S4"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_NAME "BMS_MIN_MAX_S5_S6"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_NAME "BMS_MIN_MAX_S7_S8"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_NAME "BMS_MIN_MAX_S9_S10"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_NAME "BMS_MIN_MAX_S11_S12"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_NAME "BMS_Max_Temp_S1_S4"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_NAME "BMS_Max_Temp_S5_S8"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_NAME "BMS_Max_Temp_S9_S12"
#define CAN_MCU_APU_TEMP_NAME "APU_TEMP"
#define CAN_MCU_DASH_BRAKE_NAME "DASH_BRAKE"
#define CAN_MCU_ISABELLEN_16_BIT_NAME "ISABELLEN_16_bit"
#define CAN_MCU_COOLING_TELE_NAME "COOLING_TELE"
#define CAN_MCU_ECU_PARAM_CONTROL_NAME "ECU_PARAM_CONTROL"
#define CAN_MCU_IMU_ACCEL_NAME "IMU_ACCEL"
#define CAN_MCU_IMU_GYRO_NAME "IMU_GYRO"
#define CAN_MCU_EKF_EULER_NAME "EKF_EULER"
#define CAN_MCU_EKF_POS_NAME "EKF_POS"
#define CAN_MCU_EKF_VEL_BODY_NAME "EKF_VEL_BODY"
#define CAN_MCU_EKF_VEL_NED_NAME "EKF_VEL_NED"
#define CAN_MCU_ODO_VEL_NAME "ODO_VEL"
#define CAN_MCU_GPS1_VEL_NAME "GPS1_VEL"
#define CAN_MCU_GPS1_POS_NAME "GPS1_POS"
#define CAN_MCU_GPS1_POS_ALT_NAME "GPS1_POS_ALT"
#define CAN_MCU_ECU_PARAM_GENERAL_TELE_NAME "ECU_PARAM_GENERAL_TELE"
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_NAME "ECU_PARAM_CONTROL_TELE"
#define CAN_MCU_ECU_APPS_NAME "ECU_APPS"
#define CAN_MCU_RES_STATUS_NAME "RES_STATUS"
#define CAN_MCU_DV_SYSTEM_STATUS_NAME "DV_SYSTEM_STATUS"
#define CAN_MCU_APU_RES_INIT_NAME "APU_RES_INIT"

/* Signal Names. */
#define CAN_MCU_AUX_SUSP_R_SUSP_POT_RL_NAME "Susp_Pot_RL"
#define CAN_MCU_AUX_SUSP_R_SUSP_POT_RR_NAME "Susp_Pot_RR"
#define CAN_MCU_AUX_SUSP_R_SUSP_SG_RL_NAME "Susp_SG_RL"
#define CAN_MCU_AUX_SUSP_R_SUSP_SG_RR_NAME "Susp_SG_RR"
#define CAN_MCU_DASH_APPS_APPS1_RAW_NAME "APPS1_Raw"
#define CAN_MCU_DASH_APPS_APPS2_RAW_NAME "APPS2_Raw"
#define CAN_MCU_DASH_APPS_APPS_SC_SIGNALS_NAME "APPS_SC_Signals"
#define CAN_MCU_DASH_APPS_APPS_SC_SUP_NAME "APPS_SC_Sup"
#define CAN_MCU_DASH_APPS_APPS_SC_GND_NAME "APPS_SC_GND"
#define CAN_MCU_DASH_APPS_APPS_OUT_OF_RANGE_NAME "APPS_Out_Of_Range"
#define CAN_MCU_DASH_HALL_F_HALL_FL_NAME "HALL_FL"
#define CAN_MCU_DASH_HALL_F_HALL_FR_NAME "HALL_FR"
#define CAN_MCU_ECU_BOOLS_BUZZER_NAME "Buzzer"
#define CAN_MCU_ECU_BOOLS_ENABLE_NAME "Enable"
#define CAN_MCU_ECU_BOOLS_SENSOR_ERROR_NAME "Sensor_Error"
#define CAN_MCU_ECU_BOOLS_BRAKELIGHT_NAME "Brakelight"
#define CAN_MCU_ECU_BOOLS_IMD_NAME "IMD"
#define CAN_MCU_ECU_BOOLS_AMS_NAME "AMS"
#define CAN_MCU_ECU_BOOLS_SERVO_COMMANDED_NAME "Servo_Commanded"
#define CAN_MCU_ECU_BOOLS_AS_MODE_NAME "AS_mode"
#define CAN_MCU_ECU_BOOLS_TS_OFF_NAME "TS_OFF"
#define CAN_MCU_DASH_STEERING_STEERING_NAME "Steering"
#define CAN_MCU_DASH_BOOLS_AD_ACT_NAME "Ad_Act"
#define CAN_MCU_DASH_BOOLS_ENABLE_REQUEST_NAME "Enable_Request"
#define CAN_MCU_DASH_BOOLS_START_NAME "Start"
#define CAN_MCU_DASH_BOOLS_SDC_STATE_NAME "SDC_State"
#define CAN_MCU_DASH_BOOLS_STEERING_IMPLAUSIBILITY_NAME "Steering_Implausibility"
#define CAN_MCU_DASH_BOOLS_PLUS_BUTTON_NAME "Plus_Button"
#define CAN_MCU_DASH_BOOLS_MINUS_BUTTON_NAME "Minus_Button"
#define CAN_MCU_DASH_BOOLS_ENTER_BUTTON_NAME "Enter_Button"
#define CAN_MCU_DASH_BOOLS_TRACTION_CONTROL_MODE_NAME "Traction_Control_Mode"
#define CAN_MCU_DASH_BOOLS_DIFFERENTIAL_MODE_NAME "Differential_Mode"
#define CAN_MCU_DASH_BOOLS_REGEN_MODE_NAME "Regen_Mode"
#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_NAME "Rotary_Active_Mode"
#define CAN_MCU_DASH_BOOLS_SETUP_NAME "Setup"
#define CAN_MCU_DASH_BOOLS_MAIN_MENU_NAME "Main_menu"
#define CAN_MCU_DASH_BOOLS_SUB_MENU_NAME "Sub_menu"
#define CAN_MCU_DASH_BOOLS_DEFAULT_SCREEN_NAME "Default_screen"
#define CAN_MCU_DASH_BOOLS_MONITOR_NAME "Monitor"
#define CAN_MCU_DASH_BOOLS_COOLING_STATUS_NAME "Cooling_status"
#define CAN_MCU_DASH_BOOLS_COOLING_BUTTON_NAME "Cooling_Button"
#define CAN_MCU_DASH_SUSP_F_SUSP_POT_FL_NAME "Susp_Pot_FL"
#define CAN_MCU_DASH_SUSP_F_SUSP_POT_FR_NAME "Susp_Pot_FR"
#define CAN_MCU_DASH_SUSP_F_SUSP_SG_FR_NAME "Susp_SG_FR"
#define CAN_MCU_DASH_SUSP_F_SUSP_SG_FL_NAME "Susp_SG_FL"
#define CAN_MCU_ECU_ADU_POWER_K_W_NAME "Power_kW"
#define CAN_MCU_ECU_ADU_PL_ACTIVE_NAME "PL_Active"
#define CAN_MCU_ECU_ADU_REGEN_ACTIVE_NAME "Regen_Active"
#define CAN_MCU_ECU_ADU_DIFFERENTIAL_ACTIVE_NAME "Differential_Active"
#define CAN_MCU_ECU_ADU_TC_ACTIVE_NAME "TC_Active"
#define CAN_MCU_ECU_ADU_POWER_FAULT_NAME "PowerFault"
#define CAN_MCU_ECU_ADU_VICOR_THERMISTOR_NAME "Vicor_Thermistor"
#define CAN_MCU_ECU_ADU_RECOM_THERMISTOR_NAME "Recom_Thermistor"
#define CAN_MCU_ECU_ADU_VELOCITY_NAME "Velocity"
#define CAN_MCU_ECU_ADU_STEERING_OFFSET_NAME "Steering_Offset"
#define CAN_MCU_AUX_STATES_GREEN_TSAL_NAME "Green_TSAL"
#define CAN_MCU_AUX_STATES_SAFE_STATE_NAME "Safe_State"
#define CAN_MCU_AUX_STATES_TS_OFF_NAME "TS_Off"
#define CAN_MCU_AUX_STATES_DC_LINK_VOLTAGE_NAME "DC_Link_Voltage"
#define CAN_MCU_AUX_IR_CAMS_R1_ZONE_RR1_NAME "Zone_RR1"
#define CAN_MCU_AUX_IR_CAMS_R1_ZONE_RR2_NAME "Zone_RR2"
#define CAN_MCU_AUX_IR_CAMS_R1_ZONE_RR3_NAME "Zone_RR3"
#define CAN_MCU_AUX_IR_CAMS_R1_ZONE_RR4_NAME "Zone_RR4"
#define CAN_MCU_AUX_IR_CAMS_R2_ZONE_RR5_NAME "Zone_RR5"
#define CAN_MCU_AUX_IR_CAMS_R2_ZONE_RR6_NAME "Zone_RR6"
#define CAN_MCU_AUX_IR_CAMS_R2_ZONE_RR7_NAME "Zone_RR7"
#define CAN_MCU_AUX_IR_CAMS_R2_ZONE_RR8_NAME "Zone_RR8"
#define CAN_MCU_AUX_IR_CAMS_L1_ZONE_RL1_NAME "Zone_RL1"
#define CAN_MCU_AUX_IR_CAMS_L1_ZONE_RL2_NAME "Zone_RL2"
#define CAN_MCU_AUX_IR_CAMS_L1_ZONE_RL3_NAME "Zone_RL3"
#define CAN_MCU_AUX_IR_CAMS_L1_ZONE_RL4_NAME "Zone_RL4"
#define CAN_MCU_AUX_IR_CAMS_L2_ZONE_RL5_NAME "Zone_RL5"
#define CAN_MCU_AUX_IR_CAMS_L2_ZONE_RL6_NAME "Zone_RL6"
#define CAN_MCU_AUX_IR_CAMS_L2_ZONE_RL7_NAME "Zone_RL7"
#define CAN_MCU_AUX_IR_CAMS_L2_ZONE_RL8_NAME "Zone_RL8"
#define CAN_MCU_ADU_INVERTER_LEFT_IGBT_L_NAME "IGBT_L"
#define CAN_MCU_ADU_INVERTER_LEFT_MOTOR_L_NAME "Motor_L"
#define CAN_MCU_ADU_INVERTER_LEFT_RPM_L_NAME "RPM_L"
#define CAN_MCU_ADU_INVERTER_LEFT_TORQUE_L_NAME "Torque_L"
#define CAN_MCU_ADU_INVERTER_LEFT_IDC_INTEGER_NAME "Idc_Integer"
#define CAN_MCU_ADU_INVERTER_LEFT_AC_TEMPERATURE_NAME "AC_Temperature"
#define CAN_MCU_ADU_INVERTER_RIGHT_IGBT_R_NAME "IGBT_R"
#define CAN_MCU_ADU_INVERTER_RIGHT_MOTOR_R_NAME "Motor_R"
#define CAN_MCU_ADU_INVERTER_RIGHT_RPM_R_NAME "RPM_R"
#define CAN_MCU_ADU_INVERTER_RIGHT_TORQUE_R_NAME "Torque_R"
#define CAN_MCU_ADU_INVERTER_RIGHT_ISA_VDC_NAME "Isa_Vdc"
#define CAN_MCU_AUX_CABLES_HV_CABLE1_NAME "HV_Cable1"
#define CAN_MCU_AUX_CABLES_HV_CABLE2_NAME "HV_Cable2"
#define CAN_MCU_ASB_ASMS_STATE_NAME "ASMS_State"
#define CAN_MCU_ASB_TSMS_OUT_NAME "TSMS_Out"
#define CAN_MCU_ASB_ASB_LED_NAME "ASB_LED"
#define CAN_MCU_ASB_INITIAL_CHECKED_NAME "Initial_Checked"
#define CAN_MCU_ASB_MONITOR_TANK_PRESSURE_NAME "Monitor_Tank_Pressure"
#define CAN_MCU_ASB_MONITOR_BRAKE_PRESSURE_NAME "Monitor_Brake_Pressure"
#define CAN_MCU_ASB_MONITOR_SERVO_CHECK_NAME "Monitor_Servo_Check"
#define CAN_MCU_ASB_MONITOR_APU_NAME "Monitor_APU"
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_NAME "Initial_Check_Step"
#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_NAME "Service_Brake_Status"
#define CAN_MCU_ASB_EBS_STATUS_NAME "EBS_Status"
#define CAN_MCU_ASB_EBS_TANK_PRESSURE_NAME "EBS_Tank_Pressure"
#define CAN_MCU_APU_COMMAND_THROTTLE_BRAKE_COMMANDED_NAME "Throttle_Brake_Commanded"
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_NAME "AS_Mission"
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_NAME "AS_State"
#define CAN_MCU_APU_STATE_MISSION_AS_SET_FINISHED_NAME "AS_Set_Finished"
#define CAN_MCU_AMI_AMI_NAME "AMI"
#define CAN_MCU_ISABELLEN_IDC_IDC_MEASUREMENT_ERROR_NAME "Idc_Measurement_Error"
#define CAN_MCU_ISABELLEN_IDC_SYSTEM_ERROR_NAME "System_Error"
#define CAN_MCU_ISABELLEN_IDC_IDC_NAME "Idc"
#define CAN_MCU_ISABELLEN_VDC_VDC_MEASUREMENT_ERROR_NAME "Vdc_Measurement_error"
#define CAN_MCU_ISABELLEN_VDC_VDC_NAME "Vdc"
#define CAN_MCU_ISABELLEN_PDC_PDC_MEASUREMENT_ERROR_NAME "Pdc_Measurement_Error"
#define CAN_MCU_ISABELLEN_PDC_PDC_NAME "Pdc"
#define CAN_MCU_ISABELLEN_ENERGY_ENERGY_MEASUREMENT_ERROR_NAME "Energy_Measurement_Error"
#define CAN_MCU_ISABELLEN_ENERGY_ENERGY_NAME "Energy"
#define CAN_MCU_BLDC_TX_1_STATUS_WORD_NAME "StatusWord"
#define CAN_MCU_BLDC_TX_1_MODES_OF_OPERATION_DISPLAY_NAME "ModesOfOperation_Display"
#define CAN_MCU_BLDC_RX_1_CONTROLWORD_NAME "Controlword"
#define CAN_MCU_BLDC_RX_1_MODE_OF_OPERATION_NAME "ModeOfOperation"
#define CAN_MCU_BLDC_RX_1_MOTOR_DRIVE_SUBMODE_SELECT_NAME "MotorDriveSubmodeSelect"
#define CAN_MCU_BLDC_RX_2_TARGET_POSITION_NAME "Target_Position"
#define CAN_MCU_BLDC_RX_2_PROFILE_VELOCITY_NAME "Profile_Velocity"
#define CAN_MCU_BLDC_TX_2_POSITION_ACTUAL_VALUE_NAME "Position_Actual_Value"
#define CAN_MCU_BLDC_TX_3_VELOCITY_ACTUAL_VALUE_NAME "Velocity_Actual_Value"
#define CAN_MCU_BLDC_RX_3_TARGET_VELOCITY_NAME "Target_Velocity"
#define CAN_MCU_BLDC_TX_4_DIGITAL_INPUT_NAME "Digital_Input"
#define CAN_MCU_BLDC_RX_4_DIGITAL_OUTPUT_NAME "Digital_Output"
#define CAN_MCU_STEERING_COMMAND_POSITION_TARGET_NAME "Position_Target"
#define CAN_MCU_STEERING_COMMAND_VELOCITY_TARGET_NAME "Velocity_Target"
#define CAN_MCU_STEERING_COMMAND_STEERING_MODE_NAME "Steering_Mode"
#define CAN_MCU_INVERTER_RIGHT_INFO_IRMS_MAX_R_NAME "Irms_Max_R"
#define CAN_MCU_INVERTER_RIGHT_INFO_I_LIM_IN_USE_R_NAME "I_lim_in_use_R"
#define CAN_MCU_INVERTER_RIGHT_INFO_IRMS_R_NAME "Irms_R"
#define CAN_MCU_INVERTER_RIGHT_INFO_RPM_MAX_R_NAME "RPM_Max_R"
#define CAN_MCU_INVERTER_LEFT_INFO_IRMS_MAX_L_NAME "Irms_Max_L"
#define CAN_MCU_INVERTER_LEFT_INFO_I_LIM_IN_USE_L_NAME "I_lim_in_use_L"
#define CAN_MCU_INVERTER_LEFT_INFO_IRMS_L_NAME "Irms_L"
#define CAN_MCU_INVERTER_LEFT_INFO_RPM_MAX_L_NAME "RPM_Max_L"
#define CAN_MCU_ECU_PARAM_APU_INVERTER_RPM_PERCENTAGE_NAME "Inverter_RPM_Percentage"
#define CAN_MCU_ECU_PARAM_APU_INVERTER_IRMS_MAX_NAME "Inverter_Irms_Max"
#define CAN_MCU_ECU_PARAM_APU_POWER_TARGET_NAME "Power_Target"
#define CAN_MCU_ECU_PARAM_APU_SERVO_START_SPEED_NAME "Servo_Start_Speed"
#define CAN_MCU_ECU_PARAM_APU_REGEN_MIN_SPEED_NAME "Regen_Min_Speed"
#define CAN_MCU_ECU_PARAM_APU_ED_ENABLE_NAME "ED_Enable"
#define CAN_MCU_ECU_PARAM_APU_TC_ENABLE_NAME "TC_Enable"
#define CAN_MCU_ECU_PARAM_GENERAL_INVERTER_RPM_MAX_ACTUAL_NAME "Inverter_RPM_Max_Actual"
#define CAN_MCU_ECU_PARAM_GENERAL_INVERTER_IRMS_MAX_ACTUAL_NAME "Inverter_Irms_Max_Actual"
#define CAN_MCU_ECU_PARAM_GENERAL_POWER_TARGET_ACTUAL_NAME "Power_Target_Actual"
#define CAN_MCU_ECU_PARAM_GENERAL_SERVO_START_SPEED_ACTUAL_NAME "Servo_Start_Speed_Actual"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_S1_MIN_NAME "S1_Min"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_S1_MAX_NAME "S1_Max"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_S2_MIN_NAME "S2_Min"
#define CAN_MCU_BMS_MIN_MAX_S1_S2_S2_MAX_NAME "S2_Max"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_S3_MIN_NAME "S3_Min"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_S3_MAX_NAME "S3_Max"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_S4_MIN_NAME "S4_Min"
#define CAN_MCU_BMS_MIN_MAX_S3_S4_S4_MAX_NAME "S4_Max"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_S5_MIN_NAME "S5_Min"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_S5_MAX_NAME "S5_Max"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_S6_MIN_NAME "S6_Min"
#define CAN_MCU_BMS_MIN_MAX_S5_S6_S6_MAX_NAME "S6_Max"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_S7_MIN_NAME "S7_Min"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_S7_MAX_NAME "S7_Max"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_S8_MIN_NAME "S8_Min"
#define CAN_MCU_BMS_MIN_MAX_S7_S8_S8_MAX_NAME "S8_Max"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_S9_MIN_NAME "S9_Min"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_S9_MAX_NAME "S9_Max"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_S10_MIN_NAME "S10_Min"
#define CAN_MCU_BMS_MIN_MAX_S9_S10_S10_MAX_NAME "S10_Max"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_S11_MIN_NAME "S11_Min"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_S11_MAX_NAME "S11_Max"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_S12_MIN_NAME "S12_Min"
#define CAN_MCU_BMS_MIN_MAX_S11_S12_S12_MAX_NAME "S12_Max"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_S1_MAX_TEMP_NAME "S1_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_S2_MAX_TEMP_NAME "S2_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_S3_MAX_TEMP_NAME "S3_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_S4_MAX_TEMP_NAME "S4_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_S5_MAX_TEMP_NAME "S5_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_S6_MAX_TEMP_NAME "S6_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_S7_MAX_TEMP_NAME "S7_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_S8_MAX_TEMP_NAME "S8_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_S9_MAX_TEMP_NAME "S9_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_S10_MAX_TEMP_NAME "S10_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_S11_MAX_TEMP_NAME "S11_Max_Temp"
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_S12_MAX_TEMP_NAME "S12_Max_Temp"
#define CAN_MCU_APU_TEMP_CPU_TEMP_NAME "CPU_Temp"
#define CAN_MCU_APU_TEMP_GPU_TEMP_NAME "GPU_Temp"
#define CAN_MCU_DASH_BRAKE_BRAKE_PRESSURE_NAME "BRAKE_Pressure"
#define CAN_MCU_DASH_BRAKE_BRAKE_PRESSURE_SPARE_NAME "BRAKE_Pressure_Spare"
#define CAN_MCU_DASH_BRAKE_BRAKE_SC_GND_NAME "BRAKE_SC_GND"
#define CAN_MCU_DASH_BRAKE_BRAKE_SC_SUP_NAME "BRAKE_SC_Sup"
#define CAN_MCU_DASH_BRAKE_BRAKE_OUT_OF_RANGE_NAME "BRAKE_Out_of_Range"
#define CAN_MCU_ISABELLEN_16_BIT_VDC_16_BIT_NAME "Vdc_16_bit"
#define CAN_MCU_ISABELLEN_16_BIT_PDC_16_BIT_NAME "Pdc_16_bit"
#define CAN_MCU_ISABELLEN_16_BIT_IDC_16_BIT_NAME "Idc_16_bit"
#define CAN_MCU_COOLING_TELE_PUMP_SIGNAL_DAC_NAME "Pump_Signal_DAC"
#define CAN_MCU_COOLING_TELE_TSAC_FANS_PWM_NAME "TSAC_Fans_PWM"
#define CAN_MCU_COOLING_TELE_HALL_FANS_PWM_NAME "Hall_Fans_PWM"
#define CAN_MCU_COOLING_TELE_CHASSIS_FANS_PWM_NAME "Chassis_Fans_PWM"
#define CAN_MCU_COOLING_TELE_RADIATOR_FANS_PWM_NAME "Radiator_Fans_PWM"
#define CAN_MCU_COOLING_TELE_RADIATOR_FANS_ENABLE_NAME "Radiator_Fans_Enable"
#define CAN_MCU_COOLING_TELE_CHASSIS_FANS_ENABLE_NAME "Chassis_Fans_Enable"
#define CAN_MCU_COOLING_TELE_HALL_FANS_ENABLE_NAME "Hall_Fans_Enable"
#define CAN_MCU_COOLING_TELE_TSAC_FANS_ENABLE_NAME "TSAC_Fans_Enable"
#define CAN_MCU_COOLING_TELE_PUMP_SIGNAL_ENABLE_NAME "Pump_Signal_Enable"
#define CAN_MCU_ECU_PARAM_CONTROL_ED_ENABLE_ACTUAL_NAME "ED_Enable_Actual"
#define CAN_MCU_ECU_PARAM_CONTROL_TC_ENABLE_ACTUAL_NAME "TC_Enable_Actual"
#define CAN_MCU_ECU_PARAM_CONTROL_REGEN_ENABLE_ACTUAL_NAME "Regen_Enable_Actual"
#define CAN_MCU_ECU_PARAM_CONTROL_ED_A_ACTUAL_NAME "ED_A_Actual"
#define CAN_MCU_ECU_PARAM_CONTROL_ED_D_ACTUAL_NAME "ED_D_Actual"
#define CAN_MCU_ECU_PARAM_CONTROL_ED_STEERING_DEADZONE_ACTUAL_NAME "ED_Steering_Deadzone_Actual"
#define CAN_MCU_ECU_PARAM_CONTROL_REGEN_MIN_SPEED_ACTUAL_NAME "Regen_Min_Speed_Actual"
#define CAN_MCU_IMU_ACCEL_ACCEL_X_NAME "ACCEL_X"
#define CAN_MCU_IMU_ACCEL_ACCEL_Y_NAME "ACCEL_Y"
#define CAN_MCU_IMU_ACCEL_ACCEL_Z_NAME "ACCEL_Z"
#define CAN_MCU_IMU_GYRO_GYRO_X_NAME "GYRO_X"
#define CAN_MCU_IMU_GYRO_GYRO_Y_NAME "GYRO_Y"
#define CAN_MCU_IMU_GYRO_GYRO_Z_NAME "GYRO_Z"
#define CAN_MCU_EKF_EULER_ROLL_NAME "ROLL"
#define CAN_MCU_EKF_EULER_PITCH_NAME "PITCH"
#define CAN_MCU_EKF_EULER_YAW_NAME "YAW"
#define CAN_MCU_EKF_POS_LONGITUDE_NAME "LONGITUDE"
#define CAN_MCU_EKF_POS_LATITUDE_NAME "LATITUDE"
#define CAN_MCU_EKF_VEL_BODY_VELOCITY_X_NAME "VELOCITY_X"
#define CAN_MCU_EKF_VEL_BODY_VELOCITY_Y_NAME "VELOCITY_Y"
#define CAN_MCU_EKF_VEL_BODY_VELOCITY_Z_NAME "VELOCITY_Z"
#define CAN_MCU_EKF_VEL_NED_VELOCITY_N_NAME "VELOCITY_N"
#define CAN_MCU_EKF_VEL_NED_VELOCITY_E_NAME "VELOCITY_E"
#define CAN_MCU_EKF_VEL_NED_VELOCITY_D_NAME "VELOCITY_D"
#define CAN_MCU_ODO_VEL_VELOCITY_NAME "VELOCITY"
#define CAN_MCU_GPS1_VEL_GPS_VELOCITY_N_NAME "GPS_VELOCITY_N"
#define CAN_MCU_GPS1_VEL_GPS_VELOCITY_E_NAME "GPS_VELOCITY_E"
#define CAN_MCU_GPS1_VEL_GPS_VELOCITY_D_NAME "GPS_VELOCITY_D"
#define CAN_MCU_GPS1_POS_GPS_LATITUDE_NAME "GPS_LATITUDE"
#define CAN_MCU_GPS1_POS_GPS_LONGITUDE_NAME "GPS_LONGITUDE"
#define CAN_MCU_GPS1_POS_ALT_GPS_ALTITUDE_NAME "GPS_ALTITUDE"
#define CAN_MCU_ECU_PARAM_GENERAL_TELE_INVERTER_RPM_MAX_TELEMETRY_NAME "Inverter_RPM_Max_Telemetry"
#define CAN_MCU_ECU_PARAM_GENERAL_TELE_INVERTER_IRMS_MAX_TELEMETRY_NAME "Inverter_Irms_Max_Telemetry"
#define CAN_MCU_ECU_PARAM_GENERAL_TELE_POWER_TARGET_TELEMETRY_NAME "Power_Target_Telemetry"
#define CAN_MCU_ECU_PARAM_GENERAL_TELE_SERVO_START_SPEED_TELEMETRY_NAME "Servo_Start_Speed_Telemetry"
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_ED_ENABLE_TELEMETRY_NAME "ED_Enable_Telemetry"
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_TC_ENABLE_TELEMETRY_NAME "TC_Enable_Telemetry"
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_REGEN_ENABLE_TELEMETRY_NAME "Regen_Enable_Telemetry"
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_ED_A_TELEMETRY_NAME "ED_A_Telemetry"
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_ED_D_TELEMETRY_NAME "ED_D_Telemetry"
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_ED_STEERING_DEADZONE_TELEMETRY_NAME "ED_Steering_Deadzone_Telemetry"
#define CAN_MCU_ECU_PARAM_CONTROL_TELE_REGEN_MIN_SPEED_TELEMETRY_NAME "Regen_Min_Speed_Telemetry"
#define CAN_MCU_ECU_APPS_APPS_NAME "APPS"
#define CAN_MCU_RES_STATUS_STOP_NAME "Stop"
#define CAN_MCU_RES_STATUS_TOGGLE_NAME "Toggle"
#define CAN_MCU_RES_STATUS_BUTTON_NAME "Button"
#define CAN_MCU_RES_STATUS_SIGNAL_STRENGTH_NAME "Signal_Strength"
#define CAN_MCU_DV_SYSTEM_STATUS_ASSI_STATE_NAME "ASSI_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_EBS_STATE_NAME "EBS_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_AMI_STATE_NAME "AMI_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_STEERING_STATE_NAME "STEERING_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_NAME "SERVICE_BRAKE_STATE"
#define CAN_MCU_DV_SYSTEM_STATUS_LAP_COUNTER_NAME "LAP_COUNTER"
#define CAN_MCU_DV_SYSTEM_STATUS_CONES_COUNT_ACTUAL_NAME "CONES_COUNT_ACTUAL"
#define CAN_MCU_DV_SYSTEM_STATUS_CONES_COUNT_ALL_NAME "CONES_COUNT_ALL"
#define CAN_MCU_APU_RES_INIT_REQUESTED_STATE_NAME "Requested_State"
#define CAN_MCU_APU_RES_INIT_ADDRESED_NODE_NAME "Addresed_Node"

/**
 * Signals in message AUX_SUSP_R.
 *
 * The measurements for rear suspension

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_susp_r_t {
    /**
     * Suspension Potentiometers Rear Left
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_rl;

    /**
     * Suspension Potentiometers Rear Right
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_rr;

    /**
     * Suspension Strain Gauges Rear Left
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_sg_rl;

    /**
     * Suspension Strain Gauges Rear Right
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_sg_rr;
};

/**
 * Signals in message DASH_APPS.
 *
 * APPS Raw Values & SCS states, Brake Pressure & SCS states
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_apps_t {
    /**
     * Range: 0..1 (0..1 ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps1_raw;

    /**
     * Range: 0..1 (0..1 ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps2_raw;

    /**
     * checks if APPSs's signals are short circuited
     *
     * Range: 0..1 (0..1 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_signals;

    /**
     * checks if any of the APPS signal is short circuited to supply
     *
     * Range: 0..1 (0..1 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_sup;

    /**
     * checks if any of the APPS signal is short circuited to GND
     *
     * Range: 0..1 (0..1 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_gnd;

    /**
     * checks if any of APPSs' signals is out of range
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_out_of_range;
};

/**
 * Signals in message DASH_HALL_F.
 *
 * Front Hall Effect Sensors
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_hall_f_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t hall_fl;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t hall_fr;
};

/**
 * Signals in message ECU_BOOLS.
 *
 * LEDs to Dashboard and bools from ECU to ASB and AUX
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_bools_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t buzzer;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sensor_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brakelight;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ams;

    /**
     * Activates the Service Brake if commanded from ECU
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_commanded;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off;
};

/**
 * Signals in message DASH_STEERING.
 *
 * Steering Sensor
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_steering_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float steering;
};

/**
 * Signals in message DASH_BOOLS.
 *
 * Dashboard buttons and toggle switches
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_bools_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ad_act;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_request;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t start;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_implausibility;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t plus_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t minus_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enter_button;

    /**
     * Range: 0..15 (0..15 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t traction_control_mode;

    /**
     * Range: 0..15 (0..15 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t differential_mode;

    /**
     * Range: 0..15 (0..15 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_mode;

    /**
     * Range: 0..15 (0..15 Boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_active_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t setup;

    /**
     * Which place is chosen
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t main_menu;

    /**
     * The current place at the secont column of the menu
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sub_menu;

    /**
     * Default place
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t default_screen;

    /**
     * Monitor place
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor;

    /**
     * Cooling enable
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cooling_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cooling_button;
};

/**
 * Signals in message DASH_SUSP_F.
 *
 * Front Suspension Strain Gauges
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_susp_f_t {
    /**
     * Suspension Potentiometers Front Left
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_fl;

    /**
     * Suspension Potentiometers Front Right
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_fr;

    /**
     * Suspension Strain Gauge Front Right
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_sg_fr;

    /**
     * Suspension Strain Gauge Front Left
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_sg_fl;
};

/**
 * Signals in message ECU_ADU.
 *
 * Signals for use by the ADU
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_adu_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t power_k_w;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pl_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t differential_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_fault;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t vicor_thermistor;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t recom_thermistor;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t velocity;

    /**
     * Steering sensor offset multiplied by 100
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_offset;
};

/**
 * Signals in message AUX_STATES.
 *
 * Aux uController States
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_states_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t green_tsal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t safe_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off;

    /**
     * 0...4095
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_link_voltage;
};

/**
 * Signals in message AUX_IR_CAMS_R1.
 *
 * IR Cameras - Rear Right Wheel - Zones 1-4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_ir_cams_r1_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr1;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr2;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr3;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr4;
};

/**
 * Signals in message AUX_IR_CAMS_R2.
 *
 * IR Cameras - Rear Right Wheel - Zones 5-8
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_ir_cams_r2_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr5;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr6;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr7;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr8;
};

/**
 * Signals in message AUX_IR_CAMS_L1.
 *
 * IR Cameras - Rear Left Wheel - Zones 1-4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_ir_cams_l1_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl1;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl2;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl3;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl4;
};

/**
 * Signals in message AUX_IR_CAMS_L2.
 *
 * IR Cameras - Rear Left Wheel - Zones 5-8
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_ir_cams_l2_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl5;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl6;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl7;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl8;
};

/**
 * Signals in message ADU_INVERTER_LEFT.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_adu_inverter_left_t {
    /**
     * Range: -
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t igbt_l;

    /**
     * Range: -
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t motor_l;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rpm_l;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t torque_l;

    /**
     * Integer part of the DC Current
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t idc_integer;

    /**
     * Max temperature from Accumulator
     *
     * Range: 0..198 (0..99 C)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ac_temperature;
};

/**
 * Signals in message ADU_INVERTER_RIGHT.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_adu_inverter_right_t {
    /**
     * Range: -
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t igbt_r;

    /**
     * Range: -
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t motor_r;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rpm_r;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t torque_r;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t isa_vdc;
};

/**
 * Signals in message AUX_CABLES.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_cables_t {
    /**
     * Thermistor in DC HV cables
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t hv_cable1;

    /**
     * Thermistor in AC HV cables
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t hv_cable2;
};

/**
 * Signals in message ASB.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_asb_t {
    /**
     * It's the actual state of TSMS
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asms_state;

    /**
     * It's the actual state of TSMS
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsms_out;

    /**
     * For visible check when EBS is activated
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb_led;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t initial_checked;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_tank_pressure;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_brake_pressure;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_servo_check;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_apu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t initial_check_step;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_status;

    /**
     * Mechanical EBS' actual state
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_status;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t ebs_tank_pressure;
};

/**
 * Signals in message APU_COMMAND.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_command_t {
    /**
     * Throttle/Brake command [-1, 1]
     *
     * Range: -1.0..1.0 (-1..1 -)
     * Scale: 1
     * Offset: 0
     */
    float throttle_brake_commanded;
};

/**
 * Signals in message APU_STATE_MISSION.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_state_mission_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t as_mission;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_set_finished;
};

/**
 * Signals in message AMI.
 *
 * Autonomous Mission Indicator 
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ami_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami;
};

/**
 * Signals in message ISABELLEN_IDC.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_idc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t idc_measurement_error;

    /**
     * Range: -
     * Scale: 7
     * Offset: 0
     */
    uint8_t system_error;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int32_t idc;
};

/**
 * Signals in message ISABELLEN_VDC.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_vdc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t vdc_measurement_error;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int32_t vdc;
};

/**
 * Signals in message ISABELLEN_PDC.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_pdc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pdc_measurement_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pdc;
};

/**
 * Signals in message ISABELLEN_ENERGY.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_energy_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t energy_measurement_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t energy;
};

/**
 * Signals in message BLDC_TX_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t status_word;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t modes_of_operation_display;
};

/**
 * Signals in message BLDC_RX_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t controlword;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode_of_operation;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_drive_submode_select;
};

/**
 * Signals in message BLDC_RX_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t target_position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t profile_velocity;
};

/**
 * Signals in message BLDC_TX_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position_actual_value;
};

/**
 * Signals in message BLDC_TX_3.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t velocity_actual_value;
};

/**
 * Signals in message BLDC_RX_3.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t target_velocity;
};

/**
 * Signals in message BLDC_TX_4.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t digital_input;
};

/**
 * Signals in message BLDC_RX_4.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t digital_output;
};

/**
 * Signals in message STEERING_COMMAND.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_steering_command_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float position_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t velocity_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_mode;
};

/**
 * Signals in message INVERTER_RIGHT_INFO.
 *
 * Values for the Inverters necessary for Telemetry
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_inverter_right_info_t {
    /**
     * The max Irms that is set for the right inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t irms_max_r;

    /**
     * The current limit that the right inverter sets at a specific time
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t i_lim_in_use_r;

    /**
     * The actual current at the moment of the left inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t irms_r;

    /**
     * The RPM threshold that is set for the right inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t rpm_max_r;
};

/**
 * Signals in message INVERTER_LEFT_INFO.
 *
 * Values for the Inverters necessary for Telemetry
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_inverter_left_info_t {
    /**
     * The max Irms that is set for the left inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t irms_max_l;

    /**
     * The current limit that the left inverter sets at a specific time
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t i_lim_in_use_l;

    /**
     * The actual current at the moment of the left inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t irms_l;

    /**
     * The RPM threshold that is set for the left inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t rpm_max_l;
};

/**
 * Signals in message ECU_PARAM_APU.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_param_apu_t {
    /**
     * A percentage of 6500 RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_rpm_percentage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_irms_max;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_start_speed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_min_speed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_enable;
};

/**
 * Signals in message ECU_PARAM_GENERAL.
 *
 * General ECU Parameters

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_param_general_t {
    /**
     * A percentage of 6500 RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_rpm_max_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_irms_max_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_target_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_start_speed_actual;
};

/**
 * Signals in message BMS_MIN_MAX_S1_S2.
 *
 * Min Max Voltages for Segment 1,2
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s1_s2_t {
    /**
     * Segment 1 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s1_min;

    /**
     * Segment 1 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s1_max;

    /**
     * Segment 2 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s2_min;

    /**
     * Segment 2 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s2_max;
};

/**
 * Signals in message BMS_MIN_MAX_S3_S4.
 *
 * Min Max Voltages for Segment 3, 4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s3_s4_t {
    /**
     * Segment 3 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s3_min;

    /**
     * Segment 3 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s3_max;

    /**
     * Segment 4 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s4_min;

    /**
     * Segment 4 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s4_max;
};

/**
 * Signals in message BMS_MIN_MAX_S5_S6.
 *
 * Min Max Voltages for Segment 5, 6
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s5_s6_t {
    /**
     * Segment 5 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s5_min;

    /**
     * Segment 5 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s5_max;

    /**
     * Segment 6 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s6_min;

    /**
     * Segment 6 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s6_max;
};

/**
 * Signals in message BMS_MIN_MAX_S7_S8.
 *
 * Min Max Voltages for Segment 7, 8
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s7_s8_t {
    /**
     * Segment 7 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s7_min;

    /**
     * Segment 7 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s7_max;

    /**
     * Segment 8 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s8_min;

    /**
     * Segment 8 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s8_max;
};

/**
 * Signals in message BMS_MIN_MAX_S9_S10.
 *
 * Min Max Voltages for Segment 9, 10
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s9_s10_t {
    /**
     * Segment 9 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s9_min;

    /**
     * Segment 9 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s9_max;

    /**
     * Segment 10 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s10_min;

    /**
     * Segment 10 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s10_max;
};

/**
 * Signals in message BMS_MIN_MAX_S11_S12.
 *
 * Min Max Voltages for Segment 11, 12
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s11_s12_t {
    /**
     * Segment 11 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s11_min;

    /**
     * Segment 11 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s11_max;

    /**
     * Segment 12 Min Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s12_min;

    /**
     * Segment 12 Max Voltage
     *
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t s12_max;
};

/**
 * Signals in message BMS_Max_Temp_S1_S4.
 *
 * Max Temperature for Segments 1, 2, 3, 4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s1_s4_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s1_max_temp;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s2_max_temp;

    /**
     * Segment 3 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s3_max_temp;

    /**
     * Segment 4 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s4_max_temp;
};

/**
 * Signals in message BMS_Max_Temp_S5_S8.
 *
 * Max Temperature for Segments 5, 6, 7, 8
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s5_s8_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s5_max_temp;

    /**
     * Segment 6 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s6_max_temp;

    /**
     * Segment 7 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s7_max_temp;

    /**
     * Segment 8 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s8_max_temp;
};

/**
 * Signals in message BMS_Max_Temp_S9_S12.
 *
 * Max Temperature for Segments 9, 10, 11, 12

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s9_s12_t {
    /**
     * Segment 9 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s9_max_temp;

    /**
     * Segment 10 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s10_max_temp;

    /**
     * Segment 11 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s11_max_temp;

    /**
     * Segment 12 Max Temperature
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t s12_max_temp;
};

/**
 * Signals in message APU_TEMP.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_temp_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t cpu_temp;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t gpu_temp;
};

/**
 * Signals in message DASH_BRAKE.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_brake_t {
    /**
     * Range: 0..2000000 (0..20000 bar)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t brake_pressure;

    /**
     * Range: 0..2000000 (0..20000 bar)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t brake_pressure_spare;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_sc_gnd;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_sc_sup;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_out_of_range;
};

/**
 * Signals in message ISABELLEN_16_bit.
 *
 * Convert Isabellen's values from 32 bit to 16 bit
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_16_bit_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t vdc_16_bit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t pdc_16_bit;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t idc_16_bit;
};

/**
 * Signals in message COOLING_TELE.
 *
 * PWM and power on/off control
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_cooling_tele_t {
    /**
     * Range: 0..5 (0..5 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pump_signal_dac;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsac_fans_pwm;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hall_fans_pwm;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t chassis_fans_pwm;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t radiator_fans_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t radiator_fans_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t chassis_fans_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t hall_fans_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsac_fans_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pump_signal_enable;
};

/**
 * Signals in message ECU_PARAM_CONTROL.
 *
 * ECU Parameters related to the Control Systems

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_param_control_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_enable_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_enable_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_enable_actual;

    /**
     * Converted to an integer, from range (0 - 2.0) to (0, 255).
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_a_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_d_actual;

    /**
     * Range: 0..30 (0..30 Degrees)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_steering_deadzone_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_min_speed_actual;
};

/**
 * Signals in message IMU_ACCEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_imu_accel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_z;
};

/**
 * Signals in message IMU_GYRO.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_imu_gyro_t {
    /**
     * Range: -32768000..32767000 (-32768..32767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_x;

    /**
     * Range: -32768000..32767000 (-32768..32767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_y;

    /**
     * Range: -32768000..32767000 (-32768..32767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_z;
};

/**
 * Signals in message EKF_EULER.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ekf_euler_t {
    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message EKF_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ekf_pos_t {
    /**
     * Range: -2147480000000..2147480000000 (-214748..214748 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;

    /**
     * Range: -2147480000000..2147480000000 (-214748..214748 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;
};

/**
 * Signals in message EKF_VEL_BODY.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ekf_vel_body_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_z;
};

/**
 * Signals in message EKF_VEL_NED.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ekf_vel_ned_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message ODO_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_odo_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity;
};

/**
 * Signals in message GPS1_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_gps1_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t gps_velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t gps_velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t gps_velocity_d;
};

/**
 * Signals in message GPS1_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_gps1_pos_t {
    /**
     * Range: -2147480000..2147480000 (-214.748..214.748 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t gps_latitude;

    /**
     * Range: -2147480000..2147480000 (-214.748..214.748 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t gps_longitude;
};

/**
 * Signals in message GPS1_POS_ALT.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_gps1_pos_alt_t {
    /**
     * Range: -2147480000..2147480000 (-2147480..2147480 m)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t gps_altitude;
};

/**
 * Signals in message ECU_PARAM_GENERAL_TELE.
 *
 * General ECU Parameters, as requested by Telemetry

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_param_general_tele_t {
    /**
     * A percentage of 6500 RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_rpm_max_telemetry;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_irms_max_telemetry;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_target_telemetry;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_start_speed_telemetry;
};

/**
 * Signals in message ECU_PARAM_CONTROL_TELE.
 *
 * ECU Parameters related to the Control Systems, as requested by Telemetry
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_param_control_tele_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_enable_telemetry;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_enable_telemetry;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_enable_telemetry;

    /**
     * Converted to an integer, from range (0 - 2.0) to (0, 255).
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_a_telemetry;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_d_telemetry;

    /**
     * Range: 0..30 (0..30 Degrees)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_steering_deadzone_telemetry;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_min_speed_telemetry;
};

/**
 * Signals in message ECU_APPS.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_apps_t {
    /**
     * APPS Value (0-1000)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps;
};

/**
 * Signals in message RES_STATUS.
 *
 * RES Status
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_res_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t stop;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t toggle;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t button;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_strength;
};

/**
 * Signals in message DV_SYSTEM_STATUS.
 *
 * Data for the Datalogger
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dv_system_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t cones_count_all;
};

/**
 * Signals in message APU_RES_INIT.
 *
 * A "CAN MASTER" sends this message in order to set RES CAN into operating mode
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_res_init_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t requested_state;

    /**
     * ID of addressed device. 0x11 in RES's case
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t addresed_node;
};

/**
 * Pack message AUX_SUSP_R.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_susp_r_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_susp_r_t *src_p,
    size_t size);

/**
 * Unpack message AUX_SUSP_R.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_susp_r_unpack(
    struct can_mcu_aux_susp_r_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AUX_SUSP_R.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_aux_susp_r_init(struct can_mcu_aux_susp_r_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_susp_r_susp_pot_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_susp_r_susp_pot_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_susp_r_susp_pot_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_susp_r_susp_pot_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_susp_r_susp_pot_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_susp_r_susp_pot_rr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_susp_r_susp_sg_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_susp_r_susp_sg_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_susp_r_susp_sg_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_susp_r_susp_sg_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_susp_r_susp_sg_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_susp_r_susp_sg_rr_is_in_range(uint16_t value);

/**
 * Pack message DASH_APPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_apps_t *src_p,
    size_t size);

/**
 * Unpack message DASH_APPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_apps_unpack(
    struct can_mcu_dash_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_APPS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_apps_init(struct can_mcu_dash_apps_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_apps_apps1_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps1_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps1_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_apps_apps2_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps2_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps2_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_apps_sc_signals_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps_sc_signals_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps_sc_signals_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_apps_sc_sup_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps_sc_sup_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps_sc_sup_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_apps_sc_gnd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps_sc_gnd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps_sc_gnd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_apps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_apps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_apps_out_of_range_is_in_range(uint8_t value);

/**
 * Pack message DASH_HALL_F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_hall_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_hall_f_t *src_p,
    size_t size);

/**
 * Unpack message DASH_HALL_F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_hall_f_unpack(
    struct can_mcu_dash_hall_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_HALL_F.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_hall_f_init(struct can_mcu_dash_hall_f_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_hall_f_hall_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_hall_f_hall_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_hall_f_hall_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_hall_f_hall_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_hall_f_hall_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_hall_f_hall_fr_is_in_range(uint16_t value);

/**
 * Pack message ECU_BOOLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_bools_t *src_p,
    size_t size);

/**
 * Unpack message ECU_BOOLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_bools_unpack(
    struct can_mcu_ecu_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ECU_BOOLS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ecu_bools_init(struct can_mcu_ecu_bools_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_buzzer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_buzzer_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_buzzer_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_sensor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_sensor_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_sensor_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_brakelight_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_brakelight_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_brakelight_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_imd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_imd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_imd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_ams_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_ams_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_ams_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_servo_commanded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_servo_commanded_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_servo_commanded_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_as_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_as_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_as_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_ts_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_ts_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_ts_off_is_in_range(uint8_t value);

/**
 * Pack message DASH_STEERING.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_steering_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_steering_t *src_p,
    size_t size);

/**
 * Unpack message DASH_STEERING.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_steering_unpack(
    struct can_mcu_dash_steering_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_STEERING.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_steering_init(struct can_mcu_dash_steering_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_dash_steering_steering_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_steering_steering_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_steering_steering_is_in_range(float value);

/**
 * Pack message DASH_BOOLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_bools_t *src_p,
    size_t size);

/**
 * Unpack message DASH_BOOLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_bools_unpack(
    struct can_mcu_dash_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_BOOLS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_bools_init(struct can_mcu_dash_bools_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_ad_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_ad_act_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_ad_act_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_enable_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_enable_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_enable_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_start_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_start_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_sdc_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_sdc_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_sdc_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_steering_implausibility_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_steering_implausibility_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_steering_implausibility_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_plus_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_plus_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_plus_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_minus_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_minus_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_minus_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_enter_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_enter_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_enter_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_traction_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_traction_control_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_traction_control_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_differential_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_differential_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_differential_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_regen_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_regen_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_regen_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_rotary_active_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_rotary_active_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_rotary_active_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_setup_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_setup_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_setup_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_main_menu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_main_menu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_main_menu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_sub_menu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_sub_menu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_sub_menu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_default_screen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_default_screen_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_default_screen_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_monitor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_monitor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_monitor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_cooling_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_cooling_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_cooling_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_cooling_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_cooling_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_cooling_button_is_in_range(uint8_t value);

/**
 * Pack message DASH_SUSP_F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_susp_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_susp_f_t *src_p,
    size_t size);

/**
 * Unpack message DASH_SUSP_F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_susp_f_unpack(
    struct can_mcu_dash_susp_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_SUSP_F.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_susp_f_init(struct can_mcu_dash_susp_f_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_susp_pot_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_susp_pot_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_susp_pot_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_susp_pot_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_susp_pot_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_susp_pot_fr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_susp_sg_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_susp_sg_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_susp_sg_fr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_susp_sg_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_susp_sg_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_susp_sg_fl_is_in_range(uint16_t value);

/**
 * Pack message ECU_ADU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_adu_t *src_p,
    size_t size);

/**
 * Unpack message ECU_ADU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_adu_unpack(
    struct can_mcu_ecu_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ECU_ADU.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ecu_adu_init(struct can_mcu_ecu_adu_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_ecu_adu_power_k_w_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_power_k_w_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_power_k_w_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_pl_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_pl_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_pl_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_regen_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_regen_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_regen_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_differential_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_differential_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_differential_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_tc_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_tc_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_tc_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_power_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_power_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_power_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_vicor_thermistor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_vicor_thermistor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_vicor_thermistor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_recom_thermistor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_recom_thermistor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_recom_thermistor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_adu_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ecu_adu_steering_offset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_steering_offset_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_steering_offset_is_in_range(int16_t value);

/**
 * Pack message AUX_STATES.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_states_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_states_t *src_p,
    size_t size);

/**
 * Unpack message AUX_STATES.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_states_unpack(
    struct can_mcu_aux_states_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AUX_STATES.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_aux_states_init(struct can_mcu_aux_states_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_aux_states_green_tsal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_states_green_tsal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_states_green_tsal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_aux_states_safe_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_states_safe_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_states_safe_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_aux_states_ts_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_states_ts_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_states_ts_off_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_states_dc_link_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_states_dc_link_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_states_dc_link_voltage_is_in_range(uint16_t value);

/**
 * Pack message AUX_IR_CAMS_R1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_ir_cams_r1_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_r1_t *src_p,
    size_t size);

/**
 * Unpack message AUX_IR_CAMS_R1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_ir_cams_r1_unpack(
    struct can_mcu_aux_ir_cams_r1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AUX_IR_CAMS_R1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_aux_ir_cams_r1_init(struct can_mcu_aux_ir_cams_r1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r1_zone_rr1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r1_zone_rr1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r1_zone_rr1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r1_zone_rr2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r1_zone_rr2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r1_zone_rr2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r1_zone_rr3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r1_zone_rr3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r1_zone_rr3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r1_zone_rr4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r1_zone_rr4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r1_zone_rr4_is_in_range(uint16_t value);

/**
 * Pack message AUX_IR_CAMS_R2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_ir_cams_r2_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_r2_t *src_p,
    size_t size);

/**
 * Unpack message AUX_IR_CAMS_R2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_ir_cams_r2_unpack(
    struct can_mcu_aux_ir_cams_r2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AUX_IR_CAMS_R2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_aux_ir_cams_r2_init(struct can_mcu_aux_ir_cams_r2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r2_zone_rr5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r2_zone_rr5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r2_zone_rr5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r2_zone_rr6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r2_zone_rr6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r2_zone_rr6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r2_zone_rr7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r2_zone_rr7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r2_zone_rr7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r2_zone_rr8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r2_zone_rr8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r2_zone_rr8_is_in_range(uint16_t value);

/**
 * Pack message AUX_IR_CAMS_L1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_ir_cams_l1_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_l1_t *src_p,
    size_t size);

/**
 * Unpack message AUX_IR_CAMS_L1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_ir_cams_l1_unpack(
    struct can_mcu_aux_ir_cams_l1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AUX_IR_CAMS_L1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_aux_ir_cams_l1_init(struct can_mcu_aux_ir_cams_l1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l1_zone_rl1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l1_zone_rl1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l1_zone_rl1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l1_zone_rl2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l1_zone_rl2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l1_zone_rl2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l1_zone_rl3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l1_zone_rl3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l1_zone_rl3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l1_zone_rl4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l1_zone_rl4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l1_zone_rl4_is_in_range(uint16_t value);

/**
 * Pack message AUX_IR_CAMS_L2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_ir_cams_l2_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_l2_t *src_p,
    size_t size);

/**
 * Unpack message AUX_IR_CAMS_L2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_ir_cams_l2_unpack(
    struct can_mcu_aux_ir_cams_l2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AUX_IR_CAMS_L2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_aux_ir_cams_l2_init(struct can_mcu_aux_ir_cams_l2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l2_zone_rl5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l2_zone_rl5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l2_zone_rl5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l2_zone_rl6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l2_zone_rl6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l2_zone_rl6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l2_zone_rl7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l2_zone_rl7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l2_zone_rl7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l2_zone_rl8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l2_zone_rl8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l2_zone_rl8_is_in_range(uint16_t value);

/**
 * Pack message ADU_INVERTER_LEFT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_adu_inverter_left_pack(
    uint8_t *dst_p,
    const struct can_mcu_adu_inverter_left_t *src_p,
    size_t size);

/**
 * Unpack message ADU_INVERTER_LEFT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_adu_inverter_left_unpack(
    struct can_mcu_adu_inverter_left_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADU_INVERTER_LEFT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_adu_inverter_left_init(struct can_mcu_adu_inverter_left_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_left_igbt_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_igbt_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_igbt_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_left_motor_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_motor_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_motor_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_adu_inverter_left_rpm_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_rpm_l_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_rpm_l_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_adu_inverter_left_torque_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_torque_l_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_torque_l_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_adu_inverter_left_idc_integer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_idc_integer_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_idc_integer_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_left_ac_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_ac_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_ac_temperature_is_in_range(uint8_t value);

/**
 * Pack message ADU_INVERTER_RIGHT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_adu_inverter_right_pack(
    uint8_t *dst_p,
    const struct can_mcu_adu_inverter_right_t *src_p,
    size_t size);

/**
 * Unpack message ADU_INVERTER_RIGHT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_adu_inverter_right_unpack(
    struct can_mcu_adu_inverter_right_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ADU_INVERTER_RIGHT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_adu_inverter_right_init(struct can_mcu_adu_inverter_right_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_right_igbt_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_igbt_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_igbt_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_right_motor_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_motor_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_motor_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_adu_inverter_right_rpm_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_rpm_r_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_rpm_r_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_adu_inverter_right_torque_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_torque_r_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_torque_r_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_adu_inverter_right_isa_vdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_isa_vdc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_isa_vdc_is_in_range(uint16_t value);

/**
 * Pack message AUX_CABLES.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_cables_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_cables_t *src_p,
    size_t size);

/**
 * Unpack message AUX_CABLES.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_cables_unpack(
    struct can_mcu_aux_cables_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AUX_CABLES.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_aux_cables_init(struct can_mcu_aux_cables_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_cables_hv_cable1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_cables_hv_cable1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_cables_hv_cable1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_cables_hv_cable2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_cables_hv_cable2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_cables_hv_cable2_is_in_range(uint16_t value);

/**
 * Pack message ASB.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_asb_pack(
    uint8_t *dst_p,
    const struct can_mcu_asb_t *src_p,
    size_t size);

/**
 * Unpack message ASB.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_asb_unpack(
    struct can_mcu_asb_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ASB.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_asb_init(struct can_mcu_asb_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_asms_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_asms_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_asms_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_tsms_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_tsms_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_tsms_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_asb_led_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_asb_led_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_asb_led_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_initial_checked_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_initial_checked_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_initial_checked_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_tank_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_tank_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_tank_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_brake_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_brake_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_brake_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_servo_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_servo_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_servo_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_apu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_apu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_apu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_asb_initial_check_step_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_initial_check_step_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_initial_check_step_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_service_brake_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_service_brake_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_service_brake_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_ebs_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_ebs_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_ebs_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_asb_ebs_tank_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_ebs_tank_pressure_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_ebs_tank_pressure_is_in_range(int16_t value);

/**
 * Pack message APU_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_command_t *src_p,
    size_t size);

/**
 * Unpack message APU_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_command_unpack(
    struct can_mcu_apu_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_COMMAND.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_command_init(struct can_mcu_apu_command_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_apu_command_throttle_brake_commanded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_command_throttle_brake_commanded_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_command_throttle_brake_commanded_is_in_range(float value);

/**
 * Pack message APU_STATE_MISSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_state_mission_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_state_mission_t *src_p,
    size_t size);

/**
 * Unpack message APU_STATE_MISSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_state_mission_unpack(
    struct can_mcu_apu_state_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_STATE_MISSION.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_state_mission_init(struct can_mcu_apu_state_mission_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_apu_state_mission_as_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_state_mission_as_mission_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_state_mission_as_mission_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_state_mission_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_state_mission_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_state_mission_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_state_mission_as_set_finished_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_state_mission_as_set_finished_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_state_mission_as_set_finished_is_in_range(uint8_t value);

/**
 * Pack message AMI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ami_pack(
    uint8_t *dst_p,
    const struct can_mcu_ami_t *src_p,
    size_t size);

/**
 * Unpack message AMI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ami_unpack(
    struct can_mcu_ami_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AMI.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ami_init(struct can_mcu_ami_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ami_ami_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ami_ami_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ami_ami_is_in_range(uint8_t value);

/**
 * Pack message ISABELLEN_IDC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_idc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_idc_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_IDC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_idc_unpack(
    struct can_mcu_isabellen_idc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_IDC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_idc_init(struct can_mcu_isabellen_idc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_idc_idc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_idc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_idc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_idc_system_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_system_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_system_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_idc_idc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_idc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_idc_is_in_range(int32_t value);

/**
 * Pack message ISABELLEN_VDC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_vdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_vdc_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_VDC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_vdc_unpack(
    struct can_mcu_isabellen_vdc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_VDC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_vdc_init(struct can_mcu_isabellen_vdc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_vdc_vdc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_vdc_vdc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_vdc_vdc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_vdc_vdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_vdc_vdc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_vdc_vdc_is_in_range(int32_t value);

/**
 * Pack message ISABELLEN_PDC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_pdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_pdc_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_PDC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_pdc_unpack(
    struct can_mcu_isabellen_pdc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_PDC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_pdc_init(struct can_mcu_isabellen_pdc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_pdc_pdc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_pdc_pdc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_pdc_pdc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_pdc_pdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_pdc_pdc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_pdc_pdc_is_in_range(int32_t value);

/**
 * Pack message ISABELLEN_ENERGY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_energy_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_energy_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_ENERGY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_energy_unpack(
    struct can_mcu_isabellen_energy_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_ENERGY.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_energy_init(struct can_mcu_isabellen_energy_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_energy_energy_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_energy_energy_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_energy_energy_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_energy_energy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_energy_energy_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_energy_energy_is_in_range(int32_t value);

/**
 * Pack message BLDC_TX_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_1_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_1_unpack(
    struct can_mcu_bldc_tx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_TX_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_tx_1_init(struct can_mcu_bldc_tx_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bldc_tx_1_status_word_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_1_status_word_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_1_status_word_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_bldc_tx_1_modes_of_operation_display_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_1_modes_of_operation_display_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_1_modes_of_operation_display_is_in_range(int8_t value);

/**
 * Pack message BLDC_RX_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_1_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_1_unpack(
    struct can_mcu_bldc_rx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_RX_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_rx_1_init(struct can_mcu_bldc_rx_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bldc_rx_1_controlword_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_controlword_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_controlword_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_bldc_rx_1_mode_of_operation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_mode_of_operation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_mode_of_operation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_1_motor_drive_submode_select_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_motor_drive_submode_select_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_motor_drive_submode_select_is_in_range(uint32_t value);

/**
 * Pack message BLDC_RX_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_2_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_2_unpack(
    struct can_mcu_bldc_rx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_RX_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_rx_2_init(struct can_mcu_bldc_rx_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_bldc_rx_2_target_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_2_target_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_2_target_position_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_2_profile_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_2_profile_velocity_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_2_profile_velocity_is_in_range(uint32_t value);

/**
 * Pack message BLDC_TX_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_2_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_2_unpack(
    struct can_mcu_bldc_tx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_TX_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_tx_2_init(struct can_mcu_bldc_tx_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_bldc_tx_2_position_actual_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_2_position_actual_value_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_2_position_actual_value_is_in_range(int32_t value);

/**
 * Pack message BLDC_TX_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_3_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_3_unpack(
    struct can_mcu_bldc_tx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_TX_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_tx_3_init(struct can_mcu_bldc_tx_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_bldc_tx_3_velocity_actual_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_3_velocity_actual_value_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_3_velocity_actual_value_is_in_range(int16_t value);

/**
 * Pack message BLDC_RX_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_3_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_3_unpack(
    struct can_mcu_bldc_rx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_RX_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_rx_3_init(struct can_mcu_bldc_rx_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_bldc_rx_3_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_3_target_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_3_target_velocity_is_in_range(int16_t value);

/**
 * Pack message BLDC_TX_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_4_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_4_unpack(
    struct can_mcu_bldc_tx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_TX_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_tx_4_init(struct can_mcu_bldc_tx_4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_tx_4_digital_input_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_4_digital_input_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_4_digital_input_is_in_range(uint32_t value);

/**
 * Pack message BLDC_RX_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_4_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_4_unpack(
    struct can_mcu_bldc_rx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BLDC_RX_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bldc_rx_4_init(struct can_mcu_bldc_rx_4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_4_digital_output_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_4_digital_output_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_4_digital_output_is_in_range(uint32_t value);

/**
 * Pack message STEERING_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_steering_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_steering_command_t *src_p,
    size_t size);

/**
 * Unpack message STEERING_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_steering_command_unpack(
    struct can_mcu_steering_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from STEERING_COMMAND.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_steering_command_init(struct can_mcu_steering_command_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_steering_command_position_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_steering_command_position_target_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_steering_command_position_target_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_steering_command_velocity_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_steering_command_velocity_target_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_steering_command_velocity_target_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_steering_command_steering_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_steering_command_steering_mode_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_steering_command_steering_mode_is_in_range(uint16_t value);

/**
 * Pack message INVERTER_RIGHT_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_inverter_right_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_inverter_right_info_t *src_p,
    size_t size);

/**
 * Unpack message INVERTER_RIGHT_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_inverter_right_info_unpack(
    struct can_mcu_inverter_right_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from INVERTER_RIGHT_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_inverter_right_info_init(struct can_mcu_inverter_right_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_right_info_irms_max_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_right_info_irms_max_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_right_info_irms_max_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_right_info_i_lim_in_use_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_right_info_i_lim_in_use_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_right_info_i_lim_in_use_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_right_info_irms_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_right_info_irms_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_right_info_irms_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_right_info_rpm_max_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_right_info_rpm_max_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_right_info_rpm_max_r_is_in_range(uint16_t value);

/**
 * Pack message INVERTER_LEFT_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_inverter_left_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_inverter_left_info_t *src_p,
    size_t size);

/**
 * Unpack message INVERTER_LEFT_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_inverter_left_info_unpack(
    struct can_mcu_inverter_left_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from INVERTER_LEFT_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_inverter_left_info_init(struct can_mcu_inverter_left_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_left_info_irms_max_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_left_info_irms_max_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_left_info_irms_max_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_left_info_i_lim_in_use_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_left_info_i_lim_in_use_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_left_info_i_lim_in_use_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_left_info_irms_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_left_info_irms_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_left_info_irms_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_left_info_rpm_max_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_left_info_rpm_max_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_left_info_rpm_max_l_is_in_range(uint16_t value);

/**
 * Pack message ECU_PARAM_APU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_param_apu_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_param_apu_t *src_p,
    size_t size);

/**
 * Unpack message ECU_PARAM_APU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_param_apu_unpack(
    struct can_mcu_ecu_param_apu_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ECU_PARAM_APU.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ecu_param_apu_init(struct can_mcu_ecu_param_apu_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_param_apu_inverter_rpm_percentage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_apu_inverter_rpm_percentage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_apu_inverter_rpm_percentage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_param_apu_inverter_irms_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_apu_inverter_irms_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_apu_inverter_irms_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_apu_power_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_apu_power_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_apu_power_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_apu_servo_start_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_apu_servo_start_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_apu_servo_start_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_apu_regen_min_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_apu_regen_min_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_apu_regen_min_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_apu_ed_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_apu_ed_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_apu_ed_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_apu_tc_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_apu_tc_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_apu_tc_enable_is_in_range(uint8_t value);

/**
 * Pack message ECU_PARAM_GENERAL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_param_general_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_param_general_t *src_p,
    size_t size);

/**
 * Unpack message ECU_PARAM_GENERAL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_param_general_unpack(
    struct can_mcu_ecu_param_general_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ECU_PARAM_GENERAL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ecu_param_general_init(struct can_mcu_ecu_param_general_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_general_inverter_rpm_max_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_general_inverter_rpm_max_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_general_inverter_rpm_max_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_general_inverter_irms_max_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_general_inverter_irms_max_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_general_inverter_irms_max_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_general_power_target_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_general_power_target_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_general_power_target_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_general_servo_start_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_general_servo_start_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_general_servo_start_speed_actual_is_in_range(uint8_t value);

/**
 * Pack message BMS_MIN_MAX_S1_S2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s1_s2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s1_s2_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S1_S2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s1_s2_unpack(
    struct can_mcu_bms_min_max_s1_s2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S1_S2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s1_s2_init(struct can_mcu_bms_min_max_s1_s2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s1_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s1_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s1_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s1_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s1_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s1_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s2_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s2_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s2_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s2_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s2_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s2_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S3_S4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s3_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s3_s4_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S3_S4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s3_s4_unpack(
    struct can_mcu_bms_min_max_s3_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S3_S4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s3_s4_init(struct can_mcu_bms_min_max_s3_s4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s3_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s3_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s3_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s3_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s3_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s3_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s4_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s4_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s4_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s4_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s4_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s4_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S5_S6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s5_s6_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s5_s6_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S5_S6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s5_s6_unpack(
    struct can_mcu_bms_min_max_s5_s6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S5_S6.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s5_s6_init(struct can_mcu_bms_min_max_s5_s6_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s5_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s5_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s5_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s5_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s5_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s5_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s6_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s6_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s6_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s6_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s6_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s6_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S7_S8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s7_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s7_s8_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S7_S8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s7_s8_unpack(
    struct can_mcu_bms_min_max_s7_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S7_S8.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s7_s8_init(struct can_mcu_bms_min_max_s7_s8_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s7_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s7_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s7_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s7_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s7_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s7_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s8_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s8_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s8_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s8_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s8_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s8_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S9_S10.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s9_s10_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s9_s10_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S9_S10.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s9_s10_unpack(
    struct can_mcu_bms_min_max_s9_s10_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S9_S10.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s9_s10_init(struct can_mcu_bms_min_max_s9_s10_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s9_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s9_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s9_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s9_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s9_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s9_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s10_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s10_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s10_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s10_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s10_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s10_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S11_S12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s11_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s11_s12_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S11_S12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s11_s12_unpack(
    struct can_mcu_bms_min_max_s11_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_MIN_MAX_S11_S12.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_min_max_s11_s12_init(struct can_mcu_bms_min_max_s11_s12_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s11_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s11_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s11_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s11_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s11_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s11_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s12_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s12_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s12_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s12_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s12_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s12_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S1_S4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s1_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s1_s4_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S1_S4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s1_s4_unpack(
    struct can_mcu_bms_max_temp_s1_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Max_Temp_S1_S4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_max_temp_s1_s4_init(struct can_mcu_bms_max_temp_s1_s4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s1_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s1_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s1_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s2_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s2_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s2_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s3_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s3_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s3_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s4_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s4_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s4_max_temp_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S5_S8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s5_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s5_s8_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S5_S8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s5_s8_unpack(
    struct can_mcu_bms_max_temp_s5_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Max_Temp_S5_S8.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_max_temp_s5_s8_init(struct can_mcu_bms_max_temp_s5_s8_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s5_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s5_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s5_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s6_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s6_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s6_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s7_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s7_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s7_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s8_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s8_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s8_max_temp_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S9_S12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s9_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s9_s12_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S9_S12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s9_s12_unpack(
    struct can_mcu_bms_max_temp_s9_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Max_Temp_S9_S12.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_bms_max_temp_s9_s12_init(struct can_mcu_bms_max_temp_s9_s12_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s9_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s9_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s9_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s10_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s10_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s10_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s11_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s11_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s11_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s12_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s12_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s12_max_temp_is_in_range(uint16_t value);

/**
 * Pack message APU_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_temp_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_temp_t *src_p,
    size_t size);

/**
 * Unpack message APU_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_temp_unpack(
    struct can_mcu_apu_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_TEMP.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_temp_init(struct can_mcu_apu_temp_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_apu_temp_cpu_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_temp_cpu_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_temp_cpu_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_apu_temp_gpu_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_temp_gpu_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_temp_gpu_temp_is_in_range(uint16_t value);

/**
 * Pack message DASH_BRAKE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_brake_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_brake_t *src_p,
    size_t size);

/**
 * Unpack message DASH_BRAKE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_brake_unpack(
    struct can_mcu_dash_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH_BRAKE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dash_brake_init(struct can_mcu_dash_brake_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_brake_brake_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_pressure_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_pressure_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_brake_brake_pressure_spare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_pressure_spare_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_pressure_spare_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_brake_brake_sc_gnd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_sc_gnd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_sc_gnd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_brake_brake_sc_sup_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_sc_sup_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_sc_sup_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_brake_brake_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_brake_brake_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_brake_brake_out_of_range_is_in_range(uint8_t value);

/**
 * Pack message ISABELLEN_16_bit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_16_bit_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_16_bit_t *src_p,
    size_t size);

/**
 * Unpack message ISABELLEN_16_bit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_16_bit_unpack(
    struct can_mcu_isabellen_16_bit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ISABELLEN_16_bit.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_isabellen_16_bit_init(struct can_mcu_isabellen_16_bit_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_isabellen_16_bit_vdc_16_bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_16_bit_vdc_16_bit_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_16_bit_vdc_16_bit_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_isabellen_16_bit_pdc_16_bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_16_bit_pdc_16_bit_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_16_bit_pdc_16_bit_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_isabellen_16_bit_idc_16_bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_16_bit_idc_16_bit_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_16_bit_idc_16_bit_is_in_range(int16_t value);

/**
 * Pack message COOLING_TELE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_cooling_tele_pack(
    uint8_t *dst_p,
    const struct can_mcu_cooling_tele_t *src_p,
    size_t size);

/**
 * Unpack message COOLING_TELE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_cooling_tele_unpack(
    struct can_mcu_cooling_tele_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from COOLING_TELE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_cooling_tele_init(struct can_mcu_cooling_tele_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_pump_signal_dac_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_pump_signal_dac_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_pump_signal_dac_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_tsac_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_tsac_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_tsac_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_hall_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_hall_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_hall_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_chassis_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_chassis_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_chassis_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_radiator_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_radiator_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_radiator_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_radiator_fans_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_radiator_fans_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_radiator_fans_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_chassis_fans_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_chassis_fans_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_chassis_fans_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_hall_fans_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_hall_fans_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_hall_fans_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_tsac_fans_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_tsac_fans_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_tsac_fans_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tele_pump_signal_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tele_pump_signal_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tele_pump_signal_enable_is_in_range(uint8_t value);

/**
 * Pack message ECU_PARAM_CONTROL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_param_control_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_param_control_t *src_p,
    size_t size);

/**
 * Unpack message ECU_PARAM_CONTROL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_param_control_unpack(
    struct can_mcu_ecu_param_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ECU_PARAM_CONTROL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ecu_param_control_init(struct can_mcu_ecu_param_control_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_ed_enable_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_ed_enable_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_ed_enable_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_tc_enable_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_tc_enable_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_tc_enable_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_regen_enable_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_regen_enable_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_regen_enable_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_ed_a_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_ed_a_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_ed_a_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_ed_d_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_ed_d_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_ed_d_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_ed_steering_deadzone_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_ed_steering_deadzone_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_ed_steering_deadzone_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_regen_min_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_regen_min_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_regen_min_speed_actual_is_in_range(uint8_t value);

/**
 * Pack message IMU_ACCEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_imu_accel_pack(
    uint8_t *dst_p,
    const struct can_mcu_imu_accel_t *src_p,
    size_t size);

/**
 * Unpack message IMU_ACCEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_imu_accel_unpack(
    struct can_mcu_imu_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU_ACCEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_imu_accel_init(struct can_mcu_imu_accel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_imu_accel_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_imu_accel_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_imu_accel_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_imu_accel_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_imu_accel_accel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_imu_accel_accel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_imu_accel_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_imu_accel_accel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_imu_accel_accel_z_is_in_range(int16_t value);

/**
 * Pack message IMU_GYRO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_imu_gyro_pack(
    uint8_t *dst_p,
    const struct can_mcu_imu_gyro_t *src_p,
    size_t size);

/**
 * Unpack message IMU_GYRO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_imu_gyro_unpack(
    struct can_mcu_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU_GYRO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_imu_gyro_init(struct can_mcu_imu_gyro_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_imu_gyro_gyro_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_imu_gyro_gyro_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_imu_gyro_gyro_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_imu_gyro_gyro_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_imu_gyro_gyro_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_imu_gyro_gyro_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_imu_gyro_gyro_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_imu_gyro_gyro_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_imu_gyro_gyro_z_is_in_range(int16_t value);

/**
 * Pack message EKF_EULER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ekf_euler_pack(
    uint8_t *dst_p,
    const struct can_mcu_ekf_euler_t *src_p,
    size_t size);

/**
 * Unpack message EKF_EULER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ekf_euler_unpack(
    struct can_mcu_ekf_euler_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EKF_EULER.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ekf_euler_init(struct can_mcu_ekf_euler_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_euler_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_euler_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_euler_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_euler_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_euler_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_euler_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_euler_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_euler_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_euler_yaw_is_in_range(int16_t value);

/**
 * Pack message EKF_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ekf_pos_pack(
    uint8_t *dst_p,
    const struct can_mcu_ekf_pos_t *src_p,
    size_t size);

/**
 * Unpack message EKF_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ekf_pos_unpack(
    struct can_mcu_ekf_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EKF_POS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ekf_pos_init(struct can_mcu_ekf_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_ekf_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_pos_longitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_ekf_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_pos_latitude_is_in_range(int32_t value);

/**
 * Pack message EKF_VEL_BODY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ekf_vel_body_pack(
    uint8_t *dst_p,
    const struct can_mcu_ekf_vel_body_t *src_p,
    size_t size);

/**
 * Unpack message EKF_VEL_BODY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ekf_vel_body_unpack(
    struct can_mcu_ekf_vel_body_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EKF_VEL_BODY.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ekf_vel_body_init(struct can_mcu_ekf_vel_body_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_vel_body_velocity_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_vel_body_velocity_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_vel_body_velocity_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_vel_body_velocity_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_vel_body_velocity_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_vel_body_velocity_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_vel_body_velocity_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_vel_body_velocity_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_vel_body_velocity_z_is_in_range(int16_t value);

/**
 * Pack message EKF_VEL_NED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ekf_vel_ned_pack(
    uint8_t *dst_p,
    const struct can_mcu_ekf_vel_ned_t *src_p,
    size_t size);

/**
 * Unpack message EKF_VEL_NED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ekf_vel_ned_unpack(
    struct can_mcu_ekf_vel_ned_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EKF_VEL_NED.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ekf_vel_ned_init(struct can_mcu_ekf_vel_ned_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_vel_ned_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_vel_ned_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_vel_ned_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_vel_ned_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_vel_ned_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_vel_ned_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_ekf_vel_ned_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ekf_vel_ned_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ekf_vel_ned_velocity_d_is_in_range(int16_t value);

/**
 * Pack message ODO_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_odo_vel_pack(
    uint8_t *dst_p,
    const struct can_mcu_odo_vel_t *src_p,
    size_t size);

/**
 * Unpack message ODO_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_odo_vel_unpack(
    struct can_mcu_odo_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ODO_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_odo_vel_init(struct can_mcu_odo_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_odo_vel_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_odo_vel_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_odo_vel_velocity_is_in_range(int16_t value);

/**
 * Pack message GPS1_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_gps1_vel_pack(
    uint8_t *dst_p,
    const struct can_mcu_gps1_vel_t *src_p,
    size_t size);

/**
 * Unpack message GPS1_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_gps1_vel_unpack(
    struct can_mcu_gps1_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GPS1_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_gps1_vel_init(struct can_mcu_gps1_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_gps1_vel_gps_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_gps1_vel_gps_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_gps1_vel_gps_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_gps1_vel_gps_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_gps1_vel_gps_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_gps1_vel_gps_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_gps1_vel_gps_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_gps1_vel_gps_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_gps1_vel_gps_velocity_d_is_in_range(int16_t value);

/**
 * Pack message GPS1_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_gps1_pos_pack(
    uint8_t *dst_p,
    const struct can_mcu_gps1_pos_t *src_p,
    size_t size);

/**
 * Unpack message GPS1_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_gps1_pos_unpack(
    struct can_mcu_gps1_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GPS1_POS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_gps1_pos_init(struct can_mcu_gps1_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_gps1_pos_gps_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_gps1_pos_gps_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_gps1_pos_gps_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_gps1_pos_gps_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_gps1_pos_gps_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_gps1_pos_gps_longitude_is_in_range(int32_t value);

/**
 * Pack message GPS1_POS_ALT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_gps1_pos_alt_pack(
    uint8_t *dst_p,
    const struct can_mcu_gps1_pos_alt_t *src_p,
    size_t size);

/**
 * Unpack message GPS1_POS_ALT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_gps1_pos_alt_unpack(
    struct can_mcu_gps1_pos_alt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GPS1_POS_ALT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_gps1_pos_alt_init(struct can_mcu_gps1_pos_alt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_gps1_pos_alt_gps_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_gps1_pos_alt_gps_altitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_gps1_pos_alt_gps_altitude_is_in_range(int32_t value);

/**
 * Pack message ECU_PARAM_GENERAL_TELE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_param_general_tele_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_param_general_tele_t *src_p,
    size_t size);

/**
 * Unpack message ECU_PARAM_GENERAL_TELE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_param_general_tele_unpack(
    struct can_mcu_ecu_param_general_tele_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ECU_PARAM_GENERAL_TELE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ecu_param_general_tele_init(struct can_mcu_ecu_param_general_tele_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_general_tele_inverter_rpm_max_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_general_tele_inverter_rpm_max_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_general_tele_inverter_rpm_max_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_general_tele_inverter_irms_max_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_general_tele_inverter_irms_max_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_general_tele_inverter_irms_max_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_general_tele_power_target_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_general_tele_power_target_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_general_tele_power_target_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_general_tele_servo_start_speed_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_general_tele_servo_start_speed_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_general_tele_servo_start_speed_telemetry_is_in_range(uint8_t value);

/**
 * Pack message ECU_PARAM_CONTROL_TELE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_param_control_tele_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_param_control_tele_t *src_p,
    size_t size);

/**
 * Unpack message ECU_PARAM_CONTROL_TELE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_param_control_tele_unpack(
    struct can_mcu_ecu_param_control_tele_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ECU_PARAM_CONTROL_TELE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ecu_param_control_tele_init(struct can_mcu_ecu_param_control_tele_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_tele_ed_enable_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_tele_ed_enable_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_tele_ed_enable_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_tele_tc_enable_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_tele_tc_enable_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_tele_tc_enable_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_tele_regen_enable_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_tele_regen_enable_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_tele_regen_enable_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_tele_ed_a_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_tele_ed_a_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_tele_ed_a_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_tele_ed_d_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_tele_ed_d_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_tele_ed_d_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_tele_ed_steering_deadzone_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_tele_ed_steering_deadzone_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_tele_ed_steering_deadzone_telemetry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_param_control_tele_regen_min_speed_telemetry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_param_control_tele_regen_min_speed_telemetry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_param_control_tele_regen_min_speed_telemetry_is_in_range(uint8_t value);

/**
 * Pack message ECU_APPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_apps_t *src_p,
    size_t size);

/**
 * Unpack message ECU_APPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_apps_unpack(
    struct can_mcu_ecu_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ECU_APPS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_ecu_apps_init(struct can_mcu_ecu_apps_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_apps_apps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_apps_apps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_apps_apps_is_in_range(uint16_t value);

/**
 * Pack message RES_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_res_status_pack(
    uint8_t *dst_p,
    const struct can_mcu_res_status_t *src_p,
    size_t size);

/**
 * Unpack message RES_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_res_status_unpack(
    struct can_mcu_res_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RES_STATUS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_res_status_init(struct can_mcu_res_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_res_status_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_res_status_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_res_status_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_res_status_toggle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_res_status_toggle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_res_status_toggle_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_res_status_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_res_status_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_res_status_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_res_status_signal_strength_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_res_status_signal_strength_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_res_status_signal_strength_is_in_range(uint8_t value);

/**
 * Pack message DV_SYSTEM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dv_system_status_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_system_status_t *src_p,
    size_t size);

/**
 * Unpack message DV_SYSTEM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dv_system_status_unpack(
    struct can_mcu_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DV_SYSTEM_STATUS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_dv_system_status_init(struct can_mcu_dv_system_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_assi_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_assi_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_assi_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_ami_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_steering_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_steering_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_steering_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_service_brake_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_service_brake_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_service_brake_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dv_system_status_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_dv_system_status_cones_count_all_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dv_system_status_cones_count_all_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dv_system_status_cones_count_all_is_in_range(uint32_t value);

/**
 * Pack message APU_RES_INIT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_res_init_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_res_init_t *src_p,
    size_t size);

/**
 * Unpack message APU_RES_INIT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_res_init_unpack(
    struct can_mcu_apu_res_init_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from APU_RES_INIT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_mcu_apu_res_init_init(struct can_mcu_apu_res_init_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_res_init_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_res_init_requested_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_res_init_requested_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_res_init_addresed_node_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_res_init_addresed_node_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_res_init_addresed_node_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
