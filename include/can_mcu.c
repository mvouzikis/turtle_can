/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Mar  7 13:55:55 2023.
 */

#include <string.h>

#include "can_mcu.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int can_mcu_aux_susp_r_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_susp_r_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->susp_pot_rl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->susp_pot_rl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->susp_pot_rr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->susp_pot_rr, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->susp_sg_rl, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->susp_sg_rl, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->susp_sg_rr, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->susp_sg_rr, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_susp_r_unpack(
    struct can_mcu_aux_susp_r_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->susp_pot_rl = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->susp_pot_rl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->susp_pot_rr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->susp_pot_rr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->susp_sg_rl = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->susp_sg_rl |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->susp_sg_rr = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->susp_sg_rr |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_aux_susp_r_susp_pot_rl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_susp_r_susp_pot_rl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_susp_r_susp_pot_rl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_susp_r_susp_pot_rr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_susp_r_susp_pot_rr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_susp_r_susp_pot_rr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_susp_r_susp_sg_rl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_susp_r_susp_sg_rl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_susp_r_susp_sg_rl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_susp_r_susp_sg_rr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_susp_r_susp_sg_rr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_susp_r_susp_sg_rr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_apps_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u16(src_p->apps1_raw, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->apps1_raw, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->apps2_raw, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->apps2_raw, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_signals, 0u, 0x01u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_sup, 1u, 0x02u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_gnd, 2u, 0x04u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_out_of_range, 3u, 0x08u);

    return (7);
}

int can_mcu_dash_apps_unpack(
    struct can_mcu_dash_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    dst_p->apps1_raw = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->apps1_raw |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->apps2_raw = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->apps2_raw |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->apps_sc_signals = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->apps_sc_sup = unpack_right_shift_u8(src_p[4], 1u, 0x02u);
    dst_p->apps_sc_gnd = unpack_right_shift_u8(src_p[4], 2u, 0x04u);
    dst_p->apps_out_of_range = unpack_right_shift_u8(src_p[4], 3u, 0x08u);

    return (0);
}

uint16_t can_mcu_dash_apps_apps1_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_apps_apps1_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps1_raw_is_in_range(uint16_t value)
{
    return (value <= 1u);
}

uint16_t can_mcu_dash_apps_apps2_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_apps_apps2_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps2_raw_is_in_range(uint16_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_signals_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_signals_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_signals_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_sup_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_sup_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_sup_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_gnd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_gnd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_gnd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_out_of_range_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_out_of_range_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_out_of_range_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_dash_hall_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_hall_f_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->hall_fl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->hall_fl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->hall_fr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->hall_fr, 8u, 0xffu);

    return (4);
}

int can_mcu_dash_hall_f_unpack(
    struct can_mcu_dash_hall_f_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->hall_fl = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->hall_fl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->hall_fr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->hall_fr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_dash_hall_f_hall_fl_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can_mcu_dash_hall_f_hall_fl_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_dash_hall_f_hall_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_hall_f_hall_fr_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can_mcu_dash_hall_f_hall_fr_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_dash_hall_f_hall_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_bools_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->buzzer, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->enable, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->sensor_error, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->brakelight, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->imd, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->ams, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->servo_commanded, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->radiator_fans_left, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->radiator_fans_right, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->as_mode, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->ts_off, 2u, 0x04u);

    return (2);
}

int can_mcu_ecu_bools_unpack(
    struct can_mcu_ecu_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->buzzer = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->enable = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->sensor_error = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->brakelight = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->imd = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->ams = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->servo_commanded = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->radiator_fans_left = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->radiator_fans_right = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->as_mode = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->ts_off = unpack_right_shift_u8(src_p[1], 2u, 0x04u);

    return (0);
}

uint8_t can_mcu_ecu_bools_buzzer_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_buzzer_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_buzzer_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_sensor_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_sensor_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_sensor_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_brakelight_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_brakelight_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_brakelight_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_imd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_imd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_imd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_ams_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_ams_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_ams_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_servo_commanded_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_servo_commanded_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_servo_commanded_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_radiator_fans_left_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_radiator_fans_left_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_radiator_fans_left_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_radiator_fans_right_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_radiator_fans_right_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_radiator_fans_right_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_as_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_as_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_as_mode_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_ts_off_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_ts_off_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_ts_off_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_dash_steering_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_steering_t *src_p,
    size_t size)
{
    uint32_t steering;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&steering, &src_p->steering, sizeof(steering));
    dst_p[0] |= pack_left_shift_u32(steering, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(steering, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(steering, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(steering, 24u, 0xffu);

    return (4);
}

int can_mcu_dash_steering_unpack(
    struct can_mcu_dash_steering_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t steering;

    if (size < 4u) {
        return (-EINVAL);
    }

    steering = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->steering, &steering, sizeof(dst_p->steering));

    return (0);
}

float can_mcu_dash_steering_steering_encode(double value)
{
    return (float)(value);
}

double can_mcu_dash_steering_steering_decode(float value)
{
    return ((double)value);
}

bool can_mcu_dash_steering_steering_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_bools_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u8(src_p->ad_act, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->enable_request, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->start, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->sdc_state, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->steering_implausibility, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->plus_button, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->minus_button, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->enter_button, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->traction_control_mode, 0u, 0x0fu);
    dst_p[1] |= pack_left_shift_u8(src_p->differential_mode, 4u, 0xf0u);
    dst_p[2] |= pack_left_shift_u8(src_p->regen_mode, 0u, 0x0fu);
    dst_p[2] |= pack_left_shift_u8(src_p->rotary_active_mode, 4u, 0xf0u);
    dst_p[3] |= pack_left_shift_u8(src_p->driver, 0u, 0x0fu);
    dst_p[3] |= pack_left_shift_u8(src_p->main_menu, 4u, 0xf0u);
    dst_p[4] |= pack_left_shift_u8(src_p->sub_menu, 0u, 0x0fu);
    dst_p[4] |= pack_left_shift_u8(src_p->default_screen, 4u, 0x10u);
    dst_p[4] |= pack_left_shift_u8(src_p->monitor, 5u, 0x20u);
    dst_p[4] |= pack_left_shift_u8(src_p->cooling_status, 6u, 0x40u);
    dst_p[4] |= pack_left_shift_u8(src_p->cooling_button, 7u, 0x80u);

    return (6);
}

int can_mcu_dash_bools_unpack(
    struct can_mcu_dash_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->ad_act = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->enable_request = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->start = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->sdc_state = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->steering_implausibility = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->plus_button = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->minus_button = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->enter_button = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->traction_control_mode = unpack_right_shift_u8(src_p[1], 0u, 0x0fu);
    dst_p->differential_mode = unpack_right_shift_u8(src_p[1], 4u, 0xf0u);
    dst_p->regen_mode = unpack_right_shift_u8(src_p[2], 0u, 0x0fu);
    dst_p->rotary_active_mode = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    dst_p->driver = unpack_right_shift_u8(src_p[3], 0u, 0x0fu);
    dst_p->main_menu = unpack_right_shift_u8(src_p[3], 4u, 0xf0u);
    dst_p->sub_menu = unpack_right_shift_u8(src_p[4], 0u, 0x0fu);
    dst_p->default_screen = unpack_right_shift_u8(src_p[4], 4u, 0x10u);
    dst_p->monitor = unpack_right_shift_u8(src_p[4], 5u, 0x20u);
    dst_p->cooling_status = unpack_right_shift_u8(src_p[4], 6u, 0x40u);
    dst_p->cooling_button = unpack_right_shift_u8(src_p[4], 7u, 0x80u);

    return (0);
}

uint8_t can_mcu_dash_bools_ad_act_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_ad_act_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_ad_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_enable_request_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_enable_request_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_enable_request_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_start_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_start_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_start_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_sdc_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_sdc_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_sdc_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_steering_implausibility_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_steering_implausibility_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_steering_implausibility_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_plus_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_plus_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_plus_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_minus_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_minus_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_minus_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_enter_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_enter_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_enter_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_traction_control_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_traction_control_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_traction_control_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_differential_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_differential_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_differential_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_regen_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_regen_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_regen_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_rotary_active_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_rotary_active_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_rotary_active_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_driver_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_driver_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_driver_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_main_menu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_main_menu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_main_menu_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_sub_menu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_sub_menu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_sub_menu_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_default_screen_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_default_screen_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_default_screen_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_monitor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_monitor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_monitor_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_cooling_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_cooling_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_cooling_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_cooling_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_cooling_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_cooling_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_dash_susp_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_susp_f_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->susp_fl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->susp_fl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->susp_fr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->susp_fr, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->strai_gauge_fr, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->strai_gauge_fr, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->strain_gauge_fl, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->strain_gauge_fl, 8u, 0xffu);

    return (8);
}

int can_mcu_dash_susp_f_unpack(
    struct can_mcu_dash_susp_f_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->susp_fl = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->susp_fl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->susp_fr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->susp_fr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->strai_gauge_fr = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->strai_gauge_fr |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->strain_gauge_fl = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->strain_gauge_fl |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_dash_susp_f_susp_fl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_susp_fl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_susp_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_susp_f_susp_fr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_susp_fr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_susp_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_susp_f_strai_gauge_fr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_strai_gauge_fr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_strai_gauge_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_susp_f_strain_gauge_fl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_strain_gauge_fl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_strain_gauge_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_adu_t *src_p,
    size_t size)
{
    uint16_t steering_offset;
    uint8_t power_k_w;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    power_k_w = (uint8_t)src_p->power_k_w;
    dst_p[0] |= pack_left_shift_u8(power_k_w, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->pl_active, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->regen_active, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->differential_active, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->tc_active, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->power_fault, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->vicor_thermistor, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->recom_thermistor, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->velocity, 8u, 0xffu);
    steering_offset = (uint16_t)src_p->steering_offset;
    dst_p[6] |= pack_left_shift_u16(steering_offset, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(steering_offset, 8u, 0xffu);

    return (8);
}

int can_mcu_ecu_adu_unpack(
    struct can_mcu_ecu_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t steering_offset;
    uint8_t power_k_w;

    if (size < 8u) {
        return (-EINVAL);
    }

    power_k_w = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->power_k_w = (int8_t)power_k_w;
    dst_p->pl_active = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->regen_active = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->differential_active = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->tc_active = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->power_fault = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->vicor_thermistor = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->recom_thermistor = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->velocity = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->velocity |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    steering_offset = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    steering_offset |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->steering_offset = (int16_t)steering_offset;

    return (0);
}

int8_t can_mcu_ecu_adu_power_k_w_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_ecu_adu_power_k_w_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_power_k_w_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_adu_pl_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_pl_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_pl_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_regen_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_regen_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_regen_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_differential_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_differential_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_differential_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_tc_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_tc_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_tc_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_power_fault_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_power_fault_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_power_fault_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_vicor_thermistor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_vicor_thermistor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_vicor_thermistor_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_adu_recom_thermistor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_recom_thermistor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_recom_thermistor_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_ecu_adu_velocity_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_ecu_adu_velocity_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_ecu_adu_velocity_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_ecu_adu_steering_offset_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_ecu_adu_steering_offset_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_steering_offset_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_states_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_states_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u8(src_p->green_tsal, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->safe_state, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->ts_off, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u16(src_p->dc_link_voltage, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->dc_link_voltage, 8u, 0xffu);

    return (6);
}

int can_mcu_aux_states_unpack(
    struct can_mcu_aux_states_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->green_tsal = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->safe_state = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->ts_off = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->dc_link_voltage = unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->dc_link_voltage |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);

    return (0);
}

uint8_t can_mcu_aux_states_green_tsal_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_aux_states_green_tsal_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_aux_states_green_tsal_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_aux_states_safe_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_aux_states_safe_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_aux_states_safe_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_aux_states_ts_off_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_aux_states_ts_off_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_aux_states_ts_off_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t can_mcu_aux_states_dc_link_voltage_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_states_dc_link_voltage_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_states_dc_link_voltage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_ir_cams_r1_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_r1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->zone_rr1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->zone_rr1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->zone_rr2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->zone_rr2, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->zone_rr3, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->zone_rr3, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->zone_rr4, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->zone_rr4, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_ir_cams_r1_unpack(
    struct can_mcu_aux_ir_cams_r1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->zone_rr1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->zone_rr1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->zone_rr2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->zone_rr2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->zone_rr3 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->zone_rr3 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->zone_rr4 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->zone_rr4 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_aux_ir_cams_r1_zone_rr1_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r1_zone_rr1_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r1_zone_rr1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r1_zone_rr2_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r1_zone_rr2_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r1_zone_rr2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r1_zone_rr3_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r1_zone_rr3_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r1_zone_rr3_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r1_zone_rr4_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r1_zone_rr4_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r1_zone_rr4_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_ir_cams_r2_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_r2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->zone_rr5, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->zone_rr5, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->zone_rr6, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->zone_rr6, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->zone_rr7, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->zone_rr7, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->zone_rr8, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->zone_rr8, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_ir_cams_r2_unpack(
    struct can_mcu_aux_ir_cams_r2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->zone_rr5 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->zone_rr5 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->zone_rr6 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->zone_rr6 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->zone_rr7 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->zone_rr7 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->zone_rr8 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->zone_rr8 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_aux_ir_cams_r2_zone_rr5_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r2_zone_rr5_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r2_zone_rr5_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r2_zone_rr6_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r2_zone_rr6_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r2_zone_rr6_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r2_zone_rr7_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r2_zone_rr7_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r2_zone_rr7_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r2_zone_rr8_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r2_zone_rr8_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r2_zone_rr8_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_ir_cams_l1_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_l1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->zone_rl1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->zone_rl1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->zone_rl2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->zone_rl2, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->zone_rl3, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->zone_rl3, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->zone_rl4, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->zone_rl4, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_ir_cams_l1_unpack(
    struct can_mcu_aux_ir_cams_l1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->zone_rl1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->zone_rl1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->zone_rl2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->zone_rl2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->zone_rl3 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->zone_rl3 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->zone_rl4 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->zone_rl4 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_aux_ir_cams_l1_zone_rl1_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l1_zone_rl1_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l1_zone_rl1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l1_zone_rl2_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l1_zone_rl2_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l1_zone_rl2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l1_zone_rl3_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l1_zone_rl3_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l1_zone_rl3_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l1_zone_rl4_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l1_zone_rl4_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l1_zone_rl4_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_ir_cams_l2_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_l2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->zone_rl5, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->zone_rl5, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->zone_rl6, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->zone_rl6, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->zone_rl7, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->zone_rl7, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->zone_rl8, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->zone_rl8, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_ir_cams_l2_unpack(
    struct can_mcu_aux_ir_cams_l2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->zone_rl5 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->zone_rl5 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->zone_rl6 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->zone_rl6 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->zone_rl7 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->zone_rl7 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->zone_rl8 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->zone_rl8 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_aux_ir_cams_l2_zone_rl5_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l2_zone_rl5_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l2_zone_rl5_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l2_zone_rl6_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l2_zone_rl6_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l2_zone_rl6_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l2_zone_rl7_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l2_zone_rl7_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l2_zone_rl7_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l2_zone_rl8_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l2_zone_rl8_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l2_zone_rl8_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_adu_inverter_left_pack(
    uint8_t *dst_p,
    const struct can_mcu_adu_inverter_left_t *src_p,
    size_t size)
{
    uint16_t rpm_l;
    uint16_t torque_l;
    uint8_t idc_integer;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->igbt_l, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->motor_l, 0u, 0xffu);
    rpm_l = (uint16_t)src_p->rpm_l;
    dst_p[2] |= pack_left_shift_u16(rpm_l, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(rpm_l, 8u, 0xffu);
    torque_l = (uint16_t)src_p->torque_l;
    dst_p[4] |= pack_left_shift_u16(torque_l, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(torque_l, 8u, 0xffu);
    idc_integer = (uint8_t)src_p->idc_integer;
    dst_p[6] |= pack_left_shift_u8(idc_integer, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->ac_temparature, 0u, 0xffu);

    return (8);
}

int can_mcu_adu_inverter_left_unpack(
    struct can_mcu_adu_inverter_left_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t rpm_l;
    uint16_t torque_l;
    uint8_t idc_integer;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->igbt_l = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->motor_l = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    rpm_l = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    rpm_l |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rpm_l = (int16_t)rpm_l;
    torque_l = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    torque_l |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_l = (int16_t)torque_l;
    idc_integer = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->idc_integer = (int8_t)idc_integer;
    dst_p->ac_temparature = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

uint8_t can_mcu_adu_inverter_left_igbt_l_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double can_mcu_adu_inverter_left_igbt_l_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool can_mcu_adu_inverter_left_igbt_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_adu_inverter_left_motor_l_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double can_mcu_adu_inverter_left_motor_l_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool can_mcu_adu_inverter_left_motor_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_adu_inverter_left_rpm_l_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_adu_inverter_left_rpm_l_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_adu_inverter_left_rpm_l_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_adu_inverter_left_torque_l_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_mcu_adu_inverter_left_torque_l_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_adu_inverter_left_torque_l_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_adu_inverter_left_idc_integer_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_adu_inverter_left_idc_integer_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_adu_inverter_left_idc_integer_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_adu_inverter_left_ac_temparature_encode(double value)
{
    return (uint8_t)(value / 0.5);
}

double can_mcu_adu_inverter_left_ac_temparature_decode(uint8_t value)
{
    return ((double)value * 0.5);
}

bool can_mcu_adu_inverter_left_ac_temparature_is_in_range(uint8_t value)
{
    return (value <= 198u);
}

int can_mcu_adu_inverter_right_pack(
    uint8_t *dst_p,
    const struct can_mcu_adu_inverter_right_t *src_p,
    size_t size)
{
    uint16_t rpm_r;
    uint16_t torque_r;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->igbt_r, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->motor_r, 0u, 0xffu);
    rpm_r = (uint16_t)src_p->rpm_r;
    dst_p[2] |= pack_left_shift_u16(rpm_r, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(rpm_r, 8u, 0xffu);
    torque_r = (uint16_t)src_p->torque_r;
    dst_p[4] |= pack_left_shift_u16(torque_r, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(torque_r, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->isa_vdc, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->isa_vdc, 8u, 0xffu);

    return (8);
}

int can_mcu_adu_inverter_right_unpack(
    struct can_mcu_adu_inverter_right_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t rpm_r;
    uint16_t torque_r;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->igbt_r = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->motor_r = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    rpm_r = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    rpm_r |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rpm_r = (int16_t)rpm_r;
    torque_r = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    torque_r |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_r = (int16_t)torque_r;
    dst_p->isa_vdc = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->isa_vdc |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint8_t can_mcu_adu_inverter_right_igbt_r_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double can_mcu_adu_inverter_right_igbt_r_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool can_mcu_adu_inverter_right_igbt_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_adu_inverter_right_motor_r_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double can_mcu_adu_inverter_right_motor_r_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool can_mcu_adu_inverter_right_motor_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_adu_inverter_right_rpm_r_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_adu_inverter_right_rpm_r_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_adu_inverter_right_rpm_r_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_adu_inverter_right_torque_r_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_mcu_adu_inverter_right_torque_r_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_adu_inverter_right_torque_r_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_adu_inverter_right_isa_vdc_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can_mcu_adu_inverter_right_isa_vdc_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_adu_inverter_right_isa_vdc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_cables_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_cables_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->hv_cable1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->hv_cable1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->hv_cable2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->hv_cable2, 8u, 0xffu);

    return (4);
}

int can_mcu_aux_cables_unpack(
    struct can_mcu_aux_cables_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->hv_cable1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->hv_cable1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->hv_cable2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->hv_cable2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_aux_cables_hv_cable1_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_cables_hv_cable1_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_cables_hv_cable1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_cables_hv_cable2_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_cables_hv_cable2_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_cables_hv_cable2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_asb_pack(
    uint8_t *dst_p,
    const struct can_mcu_asb_t *src_p,
    size_t size)
{
    uint16_t ebs_tank_pressure;
    uint8_t initial_check_step;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->asms_state, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->tsms_out, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->asb_led, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->initial_checked, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_tank_pressure, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_brake_pressure, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_servo_check, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_apu, 7u, 0x80u);
    initial_check_step = (uint8_t)src_p->initial_check_step;
    dst_p[1] |= pack_left_shift_u8(initial_check_step, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->service_brake_status, 0u, 0x0fu);
    dst_p[2] |= pack_left_shift_u8(src_p->ebs_status, 4u, 0xf0u);
    ebs_tank_pressure = (uint16_t)src_p->ebs_tank_pressure;
    dst_p[3] |= pack_left_shift_u16(ebs_tank_pressure, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(ebs_tank_pressure, 8u, 0xffu);

    return (8);
}

int can_mcu_asb_unpack(
    struct can_mcu_asb_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t ebs_tank_pressure;
    uint8_t initial_check_step;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->asms_state = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->tsms_out = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->asb_led = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->initial_checked = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->monitor_tank_pressure = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->monitor_brake_pressure = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->monitor_servo_check = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->monitor_apu = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    initial_check_step = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->initial_check_step = (int8_t)initial_check_step;
    dst_p->service_brake_status = unpack_right_shift_u8(src_p[2], 0u, 0x0fu);
    dst_p->ebs_status = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    ebs_tank_pressure = unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    ebs_tank_pressure |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->ebs_tank_pressure = (int16_t)ebs_tank_pressure;

    return (0);
}

uint8_t can_mcu_asb_asms_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_asms_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_asms_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_tsms_out_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_tsms_out_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_tsms_out_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_asb_led_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_asb_led_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_asb_led_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_initial_checked_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_initial_checked_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_initial_checked_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_tank_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_tank_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_tank_pressure_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_brake_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_brake_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_brake_pressure_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_servo_check_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_servo_check_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_servo_check_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_apu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_apu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_apu_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int8_t can_mcu_asb_initial_check_step_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_asb_initial_check_step_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_initial_check_step_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_asb_service_brake_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_service_brake_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_service_brake_status_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_asb_ebs_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_ebs_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_ebs_status_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

int16_t can_mcu_asb_ebs_tank_pressure_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_asb_ebs_tank_pressure_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_asb_ebs_tank_pressure_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_apu_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_command_t *src_p,
    size_t size)
{
    uint32_t throttle_brake_commanded;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&throttle_brake_commanded, &src_p->throttle_brake_commanded, sizeof(throttle_brake_commanded));
    dst_p[0] |= pack_left_shift_u32(throttle_brake_commanded, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(throttle_brake_commanded, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(throttle_brake_commanded, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(throttle_brake_commanded, 24u, 0xffu);

    return (4);
}

int can_mcu_apu_command_unpack(
    struct can_mcu_apu_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t throttle_brake_commanded;

    if (size < 4u) {
        return (-EINVAL);
    }

    throttle_brake_commanded = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->throttle_brake_commanded, &throttle_brake_commanded, sizeof(dst_p->throttle_brake_commanded));

    return (0);
}

float can_mcu_apu_command_throttle_brake_commanded_encode(double value)
{
    return (float)(value);
}

double can_mcu_apu_command_throttle_brake_commanded_decode(float value)
{
    return ((double)value);
}

bool can_mcu_apu_command_throttle_brake_commanded_is_in_range(float value)
{
    return ((value >= -1.0f) && (value <= 1.0f));
}

int can_mcu_apu_state_mission_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_state_mission_t *src_p,
    size_t size)
{
    uint8_t as_mission;

    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    as_mission = (uint8_t)src_p->as_mission;
    dst_p[0] |= pack_left_shift_u8(as_mission, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->as_state, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->as_set_finished, 0u, 0x01u);

    return (3);
}

int can_mcu_apu_state_mission_unpack(
    struct can_mcu_apu_state_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t as_mission;

    if (size < 3u) {
        return (-EINVAL);
    }

    as_mission = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->as_mission = (int8_t)as_mission;
    dst_p->as_state = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->as_set_finished = unpack_right_shift_u8(src_p[2], 0u, 0x01u);

    return (0);
}

int8_t can_mcu_apu_state_mission_as_mission_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_apu_state_mission_as_mission_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_mission_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_apu_state_mission_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_state_mission_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_apu_state_mission_as_set_finished_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_state_mission_as_set_finished_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_set_finished_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_ami_pack(
    uint8_t *dst_p,
    const struct can_mcu_ami_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->ami, 0u, 0xffu);

    return (1);
}

int can_mcu_ami_unpack(
    struct can_mcu_ami_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->ami = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_mcu_ami_ami_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ami_ami_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ami_ami_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_idc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_idc_t *src_p,
    size_t size)
{
    uint32_t idc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->idc_measurement_error, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->system_error, 7u, 0x80u);
    idc = (uint32_t)src_p->idc;
    dst_p[2] |= pack_left_shift_u32(idc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(idc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(idc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(idc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_idc_unpack(
    struct can_mcu_isabellen_idc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t idc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->idc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->system_error = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    idc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->idc = (int32_t)idc;

    return (0);
}

uint8_t can_mcu_isabellen_idc_idc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_idc_idc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_idc_idc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_isabellen_idc_system_error_encode(double value)
{
    return (uint8_t)(value / 7.0);
}

double can_mcu_isabellen_idc_system_error_decode(uint8_t value)
{
    return ((double)value * 7.0);
}

bool can_mcu_isabellen_idc_system_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_idc_idc_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_isabellen_idc_idc_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_isabellen_idc_idc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_vdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_vdc_t *src_p,
    size_t size)
{
    uint32_t vdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->vdc_measurement_error, 5u, 0x20u);
    vdc = (uint32_t)src_p->vdc;
    dst_p[2] |= pack_left_shift_u32(vdc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vdc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(vdc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vdc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_vdc_unpack(
    struct can_mcu_isabellen_vdc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->vdc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    vdc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->vdc = (int32_t)vdc;

    return (0);
}

uint8_t can_mcu_isabellen_vdc_vdc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_vdc_vdc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_vdc_vdc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_vdc_vdc_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_isabellen_vdc_vdc_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_isabellen_vdc_vdc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_pdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_pdc_t *src_p,
    size_t size)
{
    uint32_t pdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->pdc_measurement_error, 5u, 0x20u);
    pdc = (uint32_t)src_p->pdc;
    dst_p[2] |= pack_left_shift_u32(pdc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pdc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(pdc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(pdc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_pdc_unpack(
    struct can_mcu_isabellen_pdc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->pdc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    pdc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->pdc = (int32_t)pdc;

    return (0);
}

uint8_t can_mcu_isabellen_pdc_pdc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_pdc_pdc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_pdc_pdc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_pdc_pdc_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_isabellen_pdc_pdc_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_pdc_pdc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_energy_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_energy_t *src_p,
    size_t size)
{
    uint32_t energy;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->energy_measurent_error, 5u, 0x20u);
    energy = (uint32_t)src_p->energy;
    dst_p[2] |= pack_left_shift_u32(energy, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(energy, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(energy, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(energy, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_energy_unpack(
    struct can_mcu_isabellen_energy_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t energy;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->energy_measurent_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    energy = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->energy = (int32_t)energy;

    return (0);
}

uint8_t can_mcu_isabellen_energy_energy_measurent_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_energy_energy_measurent_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_energy_energy_measurent_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_energy_energy_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_isabellen_energy_energy_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_energy_energy_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_1_t *src_p,
    size_t size)
{
    uint8_t modes_of_operation_display;

    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u16(src_p->status_word, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->status_word, 8u, 0xffu);
    modes_of_operation_display = (uint8_t)src_p->modes_of_operation_display;
    dst_p[2] |= pack_left_shift_u8(modes_of_operation_display, 0u, 0xffu);

    return (3);
}

int can_mcu_bldc_tx_1_unpack(
    struct can_mcu_bldc_tx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t modes_of_operation_display;

    if (size < 3u) {
        return (-EINVAL);
    }

    dst_p->status_word = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->status_word |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    modes_of_operation_display = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->modes_of_operation_display = (int8_t)modes_of_operation_display;

    return (0);
}

uint16_t can_mcu_bldc_tx_1_status_word_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_bldc_tx_1_status_word_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_1_status_word_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_bldc_tx_1_modes_of_operation_display_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_bldc_tx_1_modes_of_operation_display_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_1_modes_of_operation_display_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_1_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u16(src_p->controlword, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->controlword, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->mode_of_operation, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->motor_drive_submode_select, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 8u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 24u, 0xffu);

    return (7);
}

int can_mcu_bldc_rx_1_unpack(
    struct can_mcu_bldc_rx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    dst_p->controlword = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->controlword |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->mode_of_operation = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->motor_drive_submode_select = unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[4], 8u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[6], 24u, 0xffu);

    return (0);
}

uint16_t can_mcu_bldc_rx_1_controlword_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_bldc_rx_1_controlword_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_controlword_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_bldc_rx_1_mode_of_operation_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_bldc_rx_1_mode_of_operation_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_mode_of_operation_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_bldc_rx_1_motor_drive_submode_select_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_1_motor_drive_submode_select_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_motor_drive_submode_select_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_2_t *src_p,
    size_t size)
{
    uint32_t target_position;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    target_position = (uint32_t)src_p->target_position;
    dst_p[0] |= pack_left_shift_u32(target_position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(target_position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(target_position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(target_position, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->profile_velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->profile_velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->profile_velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->profile_velocity, 24u, 0xffu);

    return (8);
}

int can_mcu_bldc_rx_2_unpack(
    struct can_mcu_bldc_rx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t target_position;

    if (size < 8u) {
        return (-EINVAL);
    }

    target_position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->target_position = (int32_t)target_position;
    dst_p->profile_velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int32_t can_mcu_bldc_rx_2_target_position_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_bldc_rx_2_target_position_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_2_target_position_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_bldc_rx_2_profile_velocity_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_2_profile_velocity_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_2_profile_velocity_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_2_t *src_p,
    size_t size)
{
    uint32_t position_actual_value;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    position_actual_value = (uint32_t)src_p->position_actual_value;
    dst_p[0] |= pack_left_shift_u32(position_actual_value, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_actual_value, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_actual_value, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position_actual_value, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_tx_2_unpack(
    struct can_mcu_bldc_tx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position_actual_value;

    if (size < 4u) {
        return (-EINVAL);
    }

    position_actual_value = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->position_actual_value = (int32_t)position_actual_value;

    return (0);
}

int32_t can_mcu_bldc_tx_2_position_actual_value_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_bldc_tx_2_position_actual_value_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_2_position_actual_value_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_3_t *src_p,
    size_t size)
{
    uint16_t velocity_actual_value;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    velocity_actual_value = (uint16_t)src_p->velocity_actual_value;
    dst_p[0] |= pack_left_shift_u16(velocity_actual_value, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_actual_value, 8u, 0xffu);

    return (2);
}

int can_mcu_bldc_tx_3_unpack(
    struct can_mcu_bldc_tx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_actual_value;

    if (size < 2u) {
        return (-EINVAL);
    }

    velocity_actual_value = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_actual_value |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_actual_value = (int16_t)velocity_actual_value;

    return (0);
}

int16_t can_mcu_bldc_tx_3_velocity_actual_value_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_bldc_tx_3_velocity_actual_value_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_3_velocity_actual_value_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_3_t *src_p,
    size_t size)
{
    uint16_t target_velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    target_velocity = (uint16_t)src_p->target_velocity;
    dst_p[0] |= pack_left_shift_u16(target_velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(target_velocity, 8u, 0xffu);

    return (2);
}

int can_mcu_bldc_rx_3_unpack(
    struct can_mcu_bldc_rx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t target_velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    target_velocity = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    target_velocity |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->target_velocity = (int16_t)target_velocity;

    return (0);
}

int16_t can_mcu_bldc_rx_3_target_velocity_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_bldc_rx_3_target_velocity_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_3_target_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_4_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->digital_input, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->digital_input, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->digital_input, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->digital_input, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_tx_4_unpack(
    struct can_mcu_bldc_tx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->digital_input = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t can_mcu_bldc_tx_4_digital_input_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_tx_4_digital_input_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_4_digital_input_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_4_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->digital_output, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->digital_output, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->digital_output, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->digital_output, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_rx_4_unpack(
    struct can_mcu_bldc_rx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->digital_output = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t can_mcu_bldc_rx_4_digital_output_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_4_digital_output_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_4_digital_output_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_steering_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_steering_command_t *src_p,
    size_t size)
{
    uint16_t velocity_target;
    uint32_t position_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position_target, &src_p->position_target, sizeof(position_target));
    dst_p[0] |= pack_left_shift_u32(position_target, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_target, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_target, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position_target, 24u, 0xffu);
    velocity_target = (uint16_t)src_p->velocity_target;
    dst_p[4] |= pack_left_shift_u16(velocity_target, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_target, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->steering_mode, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->steering_mode, 8u, 0xffu);

    return (8);
}

int can_mcu_steering_command_unpack(
    struct can_mcu_steering_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_target;
    uint32_t position_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    position_target = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position_target, &position_target, sizeof(dst_p->position_target));
    velocity_target = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_target |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_target = (int16_t)velocity_target;
    dst_p->steering_mode = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->steering_mode |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

float can_mcu_steering_command_position_target_encode(double value)
{
    return (float)(value);
}

double can_mcu_steering_command_position_target_decode(float value)
{
    return ((double)value);
}

bool can_mcu_steering_command_position_target_is_in_range(float value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_steering_command_velocity_target_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_steering_command_velocity_target_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_steering_command_velocity_target_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_steering_command_steering_mode_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_steering_command_steering_mode_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_steering_command_steering_mode_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_inverter_right_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_inverter_right_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->irms_max_right, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->irms_max_right, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->i_lim_in_use_right, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->i_lim_in_use_right, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->irm_right, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->irm_right, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->max_rpm_right, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->max_rpm_right, 8u, 0xffu);

    return (8);
}

int can_mcu_inverter_right_info_unpack(
    struct can_mcu_inverter_right_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->irms_max_right = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->irms_max_right |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->i_lim_in_use_right = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->i_lim_in_use_right |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->irm_right = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->irm_right |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->max_rpm_right = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->max_rpm_right |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_inverter_right_info_irms_max_right_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_right_info_irms_max_right_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_right_info_irms_max_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_right_info_i_lim_in_use_right_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_right_info_i_lim_in_use_right_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_right_info_i_lim_in_use_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_right_info_irm_right_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_right_info_irm_right_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_right_info_irm_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_right_info_max_rpm_right_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_right_info_max_rpm_right_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_right_info_max_rpm_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_cooling_pack(
    uint8_t *dst_p,
    const struct can_mcu_cooling_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->pump_signal, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->tsac_fans, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->hall_fans, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->chassis_fans, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->radiator_fanss, 0u, 0xffu);

    return (5);
}

int can_mcu_cooling_unpack(
    struct can_mcu_cooling_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->pump_signal = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->tsac_fans = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->hall_fans = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->chassis_fans = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->radiator_fanss = unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

uint8_t can_mcu_cooling_pump_signal_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_cooling_pump_signal_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_cooling_pump_signal_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_cooling_tsac_fans_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_cooling_tsac_fans_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_cooling_tsac_fans_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_cooling_hall_fans_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_cooling_hall_fans_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_cooling_hall_fans_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_cooling_chassis_fans_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_cooling_chassis_fans_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_cooling_chassis_fans_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_cooling_radiator_fanss_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_cooling_radiator_fanss_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_cooling_radiator_fanss_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_inverter_left_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_inverter_left_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->irms_max_left, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->irms_max_left, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->i_lim_in_use_left, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->i_lim_in_use_left, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->irm_left, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->irm_left, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->max_rpm_left, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->max_rpm_left, 8u, 0xffu);

    return (8);
}

int can_mcu_inverter_left_info_unpack(
    struct can_mcu_inverter_left_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->irms_max_left = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->irms_max_left |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->i_lim_in_use_left = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->i_lim_in_use_left |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->irm_left = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->irm_left |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->max_rpm_left = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->max_rpm_left |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_inverter_left_info_irms_max_left_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_left_info_irms_max_left_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_left_info_irms_max_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_left_info_i_lim_in_use_left_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_left_info_i_lim_in_use_left_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_left_info_i_lim_in_use_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_left_info_irm_left_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_left_info_irm_left_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_left_info_irm_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_left_info_max_rpm_left_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_left_info_max_rpm_left_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_left_info_max_rpm_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_parameters_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_parameters_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->inverter_rpm_percentage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->inverter_rpm_percentage, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->inverter_i_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->inverter_i_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->power_target, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->servo_start_speed, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->regen_min_speed, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->ed_enable, 0u, 0x01u);
    dst_p[7] |= pack_left_shift_u8(src_p->tc_enable, 1u, 0x02u);

    return (8);
}

int can_mcu_ecu_parameters_unpack(
    struct can_mcu_ecu_parameters_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->inverter_rpm_percentage = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->inverter_rpm_percentage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->inverter_i_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->inverter_i_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->power_target = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->servo_start_speed = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->regen_min_speed = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->ed_enable = unpack_right_shift_u8(src_p[7], 0u, 0x01u);
    dst_p->tc_enable = unpack_right_shift_u8(src_p[7], 1u, 0x02u);

    return (0);
}

uint16_t can_mcu_ecu_parameters_inverter_rpm_percentage_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_parameters_inverter_rpm_percentage_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_inverter_rpm_percentage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_ecu_parameters_inverter_i_max_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_parameters_inverter_i_max_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_inverter_i_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_power_target_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_power_target_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_power_target_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_servo_start_speed_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_servo_start_speed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_servo_start_speed_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_regen_min_speed_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_regen_min_speed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_regen_min_speed_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_ed_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_ed_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_ed_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_parameters_tc_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_tc_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_tc_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_ecu_parameters_actual_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_parameters_actual_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->inverter_rpm_max_actual, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->inverter_rpm_max_actual, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->inverter_i_max_actual, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->brake_torque, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->power_target_actual, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->servo_start_speed_actual, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->regen_min_speed_actual, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->ed_enable_actual, 0u, 0x01u);
    dst_p[7] |= pack_left_shift_u8(src_p->tc_enable_actual, 1u, 0x02u);

    return (8);
}

int can_mcu_ecu_parameters_actual_unpack(
    struct can_mcu_ecu_parameters_actual_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->inverter_rpm_max_actual = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->inverter_rpm_max_actual |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->inverter_i_max_actual = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->brake_torque = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->power_target_actual = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->servo_start_speed_actual = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->regen_min_speed_actual = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->ed_enable_actual = unpack_right_shift_u8(src_p[7], 0u, 0x01u);
    dst_p->tc_enable_actual = unpack_right_shift_u8(src_p[7], 1u, 0x02u);

    return (0);
}

uint16_t can_mcu_ecu_parameters_actual_inverter_rpm_max_actual_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_parameters_actual_inverter_rpm_max_actual_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_actual_inverter_rpm_max_actual_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_actual_inverter_i_max_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_actual_inverter_i_max_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_actual_inverter_i_max_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_actual_brake_torque_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_actual_brake_torque_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_actual_brake_torque_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_actual_power_target_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_actual_power_target_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_actual_power_target_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_actual_servo_start_speed_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_actual_servo_start_speed_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_actual_servo_start_speed_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_actual_regen_min_speed_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_actual_regen_min_speed_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_actual_regen_min_speed_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_parameters_actual_ed_enable_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_actual_ed_enable_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_actual_ed_enable_actual_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_parameters_actual_tc_enable_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_parameters_actual_tc_enable_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_parameters_actual_tc_enable_actual_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_bms_min_max_s1_s2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s1_s2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s1_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s1_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s1_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s1_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s2_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s2_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s2_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s2_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s1_s2_unpack(
    struct can_mcu_bms_min_max_s1_s2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s1_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s1_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s1_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s1_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s2_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s2_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s2_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s2_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s1_s2_s1_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s1_s2_s1_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s1_s2_s1_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s1_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s1_s2_s1_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s1_s2_s1_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s2_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s1_s2_s2_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s1_s2_s2_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s2_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s1_s2_s2_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s1_s2_s2_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s3_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s3_s4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s3_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s3_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s3_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s3_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s4_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s4_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s4_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s4_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s3_s4_unpack(
    struct can_mcu_bms_min_max_s3_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s3_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s3_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s3_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s3_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s4_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s4_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s4_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s4_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s3_s4_s3_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s3_s4_s3_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s3_s4_s3_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s3_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s3_s4_s3_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s3_s4_s3_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s4_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s3_s4_s4_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s3_s4_s4_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s4_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s3_s4_s4_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s3_s4_s4_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s5_s6_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s5_s6_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s5_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s5_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s5_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s5_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s6_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s6_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s6_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s6_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s5_s6_unpack(
    struct can_mcu_bms_min_max_s5_s6_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s5_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s5_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s5_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s5_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s6_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s6_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s6_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s6_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s5_s6_s5_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s5_s6_s5_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s5_s6_s5_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s5_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s5_s6_s5_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s5_s6_s5_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s6_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s5_s6_s6_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s5_s6_s6_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s6_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s5_s6_s6_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s5_s6_s6_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s7_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s7_s8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s7_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s7_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s7_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s7_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s8_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s8_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s8_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s8_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s7_s8_unpack(
    struct can_mcu_bms_min_max_s7_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s7_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s7_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s7_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s7_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s8_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s8_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s8_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s8_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s7_s8_s7_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s7_s8_s7_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s7_s8_s7_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s7_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s7_s8_s7_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s7_s8_s7_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s8_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s7_s8_s8_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s7_s8_s8_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s8_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s7_s8_s8_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s7_s8_s8_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s9_s10_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s9_s10_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s9_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s9_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s9_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s9_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s10_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s10_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s10_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s10_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s9_s10_unpack(
    struct can_mcu_bms_min_max_s9_s10_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s9_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s9_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s9_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s9_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s10_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s10_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s10_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s10_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s9_s10_s9_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s9_s10_s9_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s9_s10_s9_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s9_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s9_s10_s9_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s9_s10_s9_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s10_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s9_s10_s10_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s9_s10_s10_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s10_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s9_s10_s10_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s9_s10_s10_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s11_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s11_s12_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s11_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s11_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s11_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s11_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s12_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s12_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s12_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s12_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s11_s12_unpack(
    struct can_mcu_bms_min_max_s11_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s11_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s11_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s11_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s11_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s12_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s12_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s12_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s12_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s11_s12_s11_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s11_s12_s11_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s11_s12_s11_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s11_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s11_s12_s11_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s11_s12_s11_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s12_min_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s11_s12_s12_min_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s11_s12_s12_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s12_max_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_bms_min_max_s11_s12_s12_max_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_bms_min_max_s11_s12_s12_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s1_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s1_s4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s1_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s1_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s2_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s2_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s3_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s3_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s4_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s4_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s1_s4_unpack(
    struct can_mcu_bms_max_temp_s1_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s1_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s1_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s2_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s2_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s3_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s3_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s4_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s4_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s1_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s1_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s1_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s2_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s2_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s2_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s3_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s3_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s3_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s4_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s4_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s4_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s5_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s5_s8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s5_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s5_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s6_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s6_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s7_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s7_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s8_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s8_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s5_s8_unpack(
    struct can_mcu_bms_max_temp_s5_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s5_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s5_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s6_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s6_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s7_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s7_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s8_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s8_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s5_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s5_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s5_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s6_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s6_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s6_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s7_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s7_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s7_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s8_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s8_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s8_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s9_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s9_s12_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s9_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s9_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s10_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s10_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s11_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s11_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s12_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s12_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s9_s12_unpack(
    struct can_mcu_bms_max_temp_s9_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s9_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s9_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s10_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s10_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s11_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s11_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s12_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s12_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s9_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s9_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s9_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s10_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s10_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s10_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s11_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s11_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s11_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s12_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s12_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s12_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_apu_temps_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_temps_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->cpu_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->cpu_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->gpu_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->gpu_temp, 8u, 0xffu);

    return (4);
}

int can_mcu_apu_temps_unpack(
    struct can_mcu_apu_temps_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->cpu_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->cpu_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->gpu_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->gpu_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_apu_temps_cpu_temp_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_apu_temps_cpu_temp_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_temps_cpu_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_apu_temps_gpu_temp_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_apu_temps_gpu_temp_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_temps_gpu_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_brake_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_brake_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->brake_pressure, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->brake_pressure, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->brake_pressure_spare, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->brake_pressure_spare, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_sc_gnd, 0u, 0x01u);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_sc_sup, 1u, 0x02u);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_out_of_range, 2u, 0x04u);

    return (8);
}

int can_mcu_dash_brake_unpack(
    struct can_mcu_dash_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->brake_pressure = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->brake_pressure |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->brake_pressure_spare = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->brake_pressure_spare |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->brake_sc_gnd = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->brake_sc_sup = unpack_right_shift_u8(src_p[4], 1u, 0x02u);
    dst_p->brake_out_of_range = unpack_right_shift_u8(src_p[4], 2u, 0x04u);

    return (0);
}

uint16_t can_mcu_dash_brake_brake_pressure_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_dash_brake_brake_pressure_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_dash_brake_brake_pressure_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_brake_brake_pressure_spare_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_dash_brake_brake_pressure_spare_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_dash_brake_brake_pressure_spare_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dash_brake_brake_sc_gnd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_sc_gnd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_sc_gnd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_brake_brake_sc_sup_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_sc_sup_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_sc_sup_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_brake_brake_out_of_range_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_out_of_range_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_out_of_range_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_bms_min_max_s1_s2_3_decimal_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s1_s2_3_decimal_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s1_min_3_decimal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s1_min_3_decimal, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s1_max_3_decimal, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s1_max_3_decimal, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s2_min_3_decimal, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s2_min_3_decimal, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s2_max_3_decimal, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s2_max_3_decimal, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s1_s2_3_decimal_unpack(
    struct can_mcu_bms_min_max_s1_s2_3_decimal_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s1_min_3_decimal = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s1_min_3_decimal |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s1_max_3_decimal = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s1_max_3_decimal |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s2_min_3_decimal = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s2_min_3_decimal |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s2_max_3_decimal = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s2_max_3_decimal |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s1_s2_3_decimal_s1_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_3_decimal_s1_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_3_decimal_s1_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_3_decimal_s1_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_3_decimal_s1_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_3_decimal_s1_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_3_decimal_s2_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_3_decimal_s2_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_3_decimal_s2_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_3_decimal_s2_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_3_decimal_s2_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_3_decimal_s2_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s3_s4_3_decimal_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s3_s4_3_decimal_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s3_min_3_decimal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s3_min_3_decimal, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s3_max_3_decimal, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s3_max_3_decimal, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s4_min_3_decimal, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s4_min_3_decimal, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s4_max_3_decimal, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s4_max_3_decimal, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s3_s4_3_decimal_unpack(
    struct can_mcu_bms_min_max_s3_s4_3_decimal_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s3_min_3_decimal = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s3_min_3_decimal |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s3_max_3_decimal = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s3_max_3_decimal |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s4_min_3_decimal = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s4_min_3_decimal |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s4_max_3_decimal = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s4_max_3_decimal |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s3_s4_3_decimal_s3_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_3_decimal_s3_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_3_decimal_s3_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_3_decimal_s3_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_3_decimal_s3_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_3_decimal_s3_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_3_decimal_s4_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_3_decimal_s4_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_3_decimal_s4_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_3_decimal_s4_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_3_decimal_s4_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_3_decimal_s4_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s5_s6_3_decimal_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s5_s6_3_decimal_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s5_min_3_decimal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s5_min_3_decimal, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s5_max_3_decimal, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s5_max_3_decimal, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s6_min_3_decimal, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s6_min_3_decimal, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s6_max_3_decimal, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s6_max_3_decimal, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s5_s6_3_decimal_unpack(
    struct can_mcu_bms_min_max_s5_s6_3_decimal_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s5_min_3_decimal = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s5_min_3_decimal |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s5_max_3_decimal = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s5_max_3_decimal |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s6_min_3_decimal = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s6_min_3_decimal |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s6_max_3_decimal = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s6_max_3_decimal |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s5_s6_3_decimal_s5_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_3_decimal_s5_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_3_decimal_s5_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_3_decimal_s5_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_3_decimal_s5_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_3_decimal_s5_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_3_decimal_s6_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_3_decimal_s6_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_3_decimal_s6_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_3_decimal_s6_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_3_decimal_s6_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_3_decimal_s6_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s7_s8_3_decimal_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s7_s8_3_decimal_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s7_min_3_decimal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s7_min_3_decimal, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s7_max_3_decimal, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s7_max_3_decimal, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s8_min_3_decimal, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s8_min_3_decimal, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s8_max_3_decimal, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s8_max_3_decimal, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s7_s8_3_decimal_unpack(
    struct can_mcu_bms_min_max_s7_s8_3_decimal_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s7_min_3_decimal = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s7_min_3_decimal |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s7_max_3_decimal = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s7_max_3_decimal |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s8_min_3_decimal = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s8_min_3_decimal |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s8_max_3_decimal = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s8_max_3_decimal |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s7_s8_3_decimal_s7_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_3_decimal_s7_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_3_decimal_s7_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_3_decimal_s7_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_3_decimal_s7_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_3_decimal_s7_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_3_decimal_s8_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_3_decimal_s8_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_3_decimal_s8_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_3_decimal_s8_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_3_decimal_s8_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_3_decimal_s8_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s9_s10_3_decimal_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s9_s10_3_decimal_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s9_min_3_decimal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s9_min_3_decimal, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s9_max_3_decimal, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s9_max_3_decimal, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s10_min_3_decimal, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s10_min_3_decimal, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s10_max_3_decimal, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s10_max_3_decimal, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s9_s10_3_decimal_unpack(
    struct can_mcu_bms_min_max_s9_s10_3_decimal_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s9_min_3_decimal = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s9_min_3_decimal |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s9_max_3_decimal = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s9_max_3_decimal |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s10_min_3_decimal = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s10_min_3_decimal |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s10_max_3_decimal = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s10_max_3_decimal |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s9_s10_3_decimal_s9_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_3_decimal_s9_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_3_decimal_s9_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_3_decimal_s9_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_3_decimal_s9_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_3_decimal_s9_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_3_decimal_s10_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_3_decimal_s10_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_3_decimal_s10_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_3_decimal_s10_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_3_decimal_s10_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_3_decimal_s10_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s11_s12_3_decimal_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s11_s12_3_decimal_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s11_min_3_decimal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s11_min_3_decimal, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s11_max_3_decimal, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s11_max_3_decimal, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s12_min_3_decimal, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s12_min_3_decimal, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s12_max_3_decimal, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s12_max_3_decimal, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s11_s12_3_decimal_unpack(
    struct can_mcu_bms_min_max_s11_s12_3_decimal_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s11_min_3_decimal = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s11_min_3_decimal |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s11_max_3_decimal = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s11_max_3_decimal |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s12_min_3_decimal = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s12_min_3_decimal |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s12_max_3_decimal = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s12_max_3_decimal |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t can_mcu_bms_min_max_s11_s12_3_decimal_s11_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_3_decimal_s11_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_3_decimal_s11_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_3_decimal_s11_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_3_decimal_s11_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_3_decimal_s11_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_3_decimal_s12_min_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_3_decimal_s12_min_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_3_decimal_s12_min_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_3_decimal_s12_max_3_decimal_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_3_decimal_s12_max_3_decimal_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_3_decimal_s12_max_3_decimal_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_16_bit_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_16_bit_t *src_p,
    size_t size)
{
    uint16_t idc_16_bit;
    uint16_t pdc_16_bit;
    uint16_t vdc_16_bit;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    vdc_16_bit = (uint16_t)src_p->vdc_16_bit;
    dst_p[0] |= pack_left_shift_u16(vdc_16_bit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(vdc_16_bit, 8u, 0xffu);
    pdc_16_bit = (uint16_t)src_p->pdc_16_bit;
    dst_p[2] |= pack_left_shift_u16(pdc_16_bit, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(pdc_16_bit, 8u, 0xffu);
    idc_16_bit = (uint16_t)src_p->idc_16_bit;
    dst_p[4] |= pack_left_shift_u16(idc_16_bit, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(idc_16_bit, 8u, 0xffu);

    return (8);
}

int can_mcu_isabellen_16_bit_unpack(
    struct can_mcu_isabellen_16_bit_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t idc_16_bit;
    uint16_t pdc_16_bit;
    uint16_t vdc_16_bit;

    if (size < 8u) {
        return (-EINVAL);
    }

    vdc_16_bit = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    vdc_16_bit |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->vdc_16_bit = (int16_t)vdc_16_bit;
    pdc_16_bit = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    pdc_16_bit |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->pdc_16_bit = (int16_t)pdc_16_bit;
    idc_16_bit = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    idc_16_bit |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->idc_16_bit = (int16_t)idc_16_bit;

    return (0);
}

int16_t can_mcu_isabellen_16_bit_vdc_16_bit_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_mcu_isabellen_16_bit_vdc_16_bit_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_isabellen_16_bit_vdc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_isabellen_16_bit_pdc_16_bit_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_isabellen_16_bit_pdc_16_bit_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_16_bit_pdc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_isabellen_16_bit_idc_16_bit_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_isabellen_16_bit_idc_16_bit_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_isabellen_16_bit_idc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}
