/**
 * @file can_mcu.c
 *
 * @brief This source file was generated by cantools version 40.1.1 Thu Jun 19 20:18:32 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <string.h>

#include "can_mcu.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t unpack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) << shift);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int can_mcu_aux_susp_r_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_susp_r_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->susp_pot_rl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->susp_pot_rl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->susp_pot_rr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->susp_pot_rr, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->susp_sg_rl, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->susp_sg_rl, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->susp_sg_rr, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->susp_sg_rr, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_susp_r_unpack(
    struct can_mcu_aux_susp_r_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->susp_pot_rl = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->susp_pot_rl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->susp_pot_rr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->susp_pot_rr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->susp_sg_rl = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->susp_sg_rl |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->susp_sg_rr = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->susp_sg_rr |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_aux_susp_r_init(struct can_mcu_aux_susp_r_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_aux_susp_r_t));

    return 0;
}

uint16_t can_mcu_aux_susp_r_susp_pot_rl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_susp_r_susp_pot_rl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_susp_r_susp_pot_rl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_susp_r_susp_pot_rr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_susp_r_susp_pot_rr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_susp_r_susp_pot_rr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_susp_r_susp_sg_rl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_susp_r_susp_sg_rl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_susp_r_susp_sg_rl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_susp_r_susp_sg_rr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_susp_r_susp_sg_rr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_susp_r_susp_sg_rr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_apps_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u16(src_p->apps1_raw, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->apps1_raw, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->apps2_raw, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->apps2_raw, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_signals, 0u, 0x01u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_sup, 1u, 0x02u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_sc_gnd, 2u, 0x04u);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_out_of_range, 3u, 0x08u);

    return (7);
}

int can_mcu_dash_apps_unpack(
    struct can_mcu_dash_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    dst_p->apps1_raw = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->apps1_raw |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->apps2_raw = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->apps2_raw |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->apps_sc_signals = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->apps_sc_sup = unpack_right_shift_u8(src_p[4], 1u, 0x02u);
    dst_p->apps_sc_gnd = unpack_right_shift_u8(src_p[4], 2u, 0x04u);
    dst_p->apps_out_of_range = unpack_right_shift_u8(src_p[4], 3u, 0x08u);

    return (0);
}

int can_mcu_dash_apps_init(struct can_mcu_dash_apps_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_apps_t));

    return 0;
}

uint16_t can_mcu_dash_apps_apps1_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_apps_apps1_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps1_raw_is_in_range(uint16_t value)
{
    return (value <= 1u);
}

uint16_t can_mcu_dash_apps_apps2_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_apps_apps2_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps2_raw_is_in_range(uint16_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_signals_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_signals_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_signals_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_sup_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_sup_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_sup_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_sc_gnd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_sc_gnd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_sc_gnd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_apps_apps_out_of_range_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_apps_apps_out_of_range_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_apps_apps_out_of_range_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_dash_hall_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_hall_f_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->hall_fl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->hall_fl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->hall_fr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->hall_fr, 8u, 0xffu);

    return (4);
}

int can_mcu_dash_hall_f_unpack(
    struct can_mcu_dash_hall_f_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->hall_fl = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->hall_fl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->hall_fr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->hall_fr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

int can_mcu_dash_hall_f_init(struct can_mcu_dash_hall_f_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_hall_f_t));

    return 0;
}

uint16_t can_mcu_dash_hall_f_hall_fl_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can_mcu_dash_hall_f_hall_fl_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_dash_hall_f_hall_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_hall_f_hall_fr_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can_mcu_dash_hall_f_hall_fr_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_dash_hall_f_hall_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_bools_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->buzzer, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->enable, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->sensor_error, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->brakelight, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->imd, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->ams, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->servo_commanded, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->as_mode, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->ts_off, 0u, 0x01u);

    return (2);
}

int can_mcu_ecu_bools_unpack(
    struct can_mcu_ecu_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->buzzer = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->enable = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->sensor_error = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->brakelight = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->imd = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->ams = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->servo_commanded = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->as_mode = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->ts_off = unpack_right_shift_u8(src_p[1], 0u, 0x01u);

    return (0);
}

int can_mcu_ecu_bools_init(struct can_mcu_ecu_bools_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ecu_bools_t));

    return 0;
}

uint8_t can_mcu_ecu_bools_buzzer_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_buzzer_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_buzzer_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_sensor_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_sensor_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_sensor_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_brakelight_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_brakelight_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_brakelight_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_imd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_imd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_imd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_ams_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_ams_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_ams_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_servo_commanded_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_servo_commanded_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_servo_commanded_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_as_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_as_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_as_mode_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_bools_ts_off_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_bools_ts_off_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_bools_ts_off_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_dash_steering_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_steering_t *src_p,
    size_t size)
{
    uint32_t steering;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&steering, &src_p->steering, sizeof(steering));
    dst_p[0] |= pack_left_shift_u32(steering, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(steering, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(steering, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(steering, 24u, 0xffu);

    return (4);
}

int can_mcu_dash_steering_unpack(
    struct can_mcu_dash_steering_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t steering;

    if (size < 4u) {
        return (-EINVAL);
    }

    steering = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    steering |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->steering, &steering, sizeof(dst_p->steering));

    return (0);
}

int can_mcu_dash_steering_init(struct can_mcu_dash_steering_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_steering_t));

    return 0;
}

float can_mcu_dash_steering_steering_encode(double value)
{
    return (float)(value);
}

double can_mcu_dash_steering_steering_decode(float value)
{
    return ((double)value);
}

bool can_mcu_dash_steering_steering_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_bools_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u8(src_p->ad_act, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->enable_request, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->start, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->sdc_state, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->steering_implausibility, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->plus_button, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->minus_button, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->enter_button, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->traction_control_mode, 0u, 0x0fu);
    dst_p[1] |= pack_left_shift_u8(src_p->differential_mode, 4u, 0xf0u);
    dst_p[2] |= pack_left_shift_u8(src_p->regen_mode, 0u, 0x0fu);
    dst_p[2] |= pack_left_shift_u8(src_p->rotary_active_mode, 4u, 0xf0u);
    dst_p[3] |= pack_left_shift_u8(src_p->setup, 0u, 0x0fu);
    dst_p[3] |= pack_left_shift_u8(src_p->main_menu, 4u, 0xf0u);
    dst_p[4] |= pack_left_shift_u8(src_p->sub_menu, 0u, 0x0fu);
    dst_p[4] |= pack_left_shift_u8(src_p->default_screen, 4u, 0x10u);
    dst_p[4] |= pack_left_shift_u8(src_p->monitor, 5u, 0x20u);
    dst_p[4] |= pack_left_shift_u8(src_p->cooling_status, 6u, 0x40u);
    dst_p[4] |= pack_left_shift_u8(src_p->cooling_button, 7u, 0x80u);
    dst_p[5] |= pack_left_shift_u8(src_p->screen, 0u, 0xffu);

    return (6);
}

int can_mcu_dash_bools_unpack(
    struct can_mcu_dash_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->ad_act = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->enable_request = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->start = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->sdc_state = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->steering_implausibility = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->plus_button = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->minus_button = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->enter_button = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->traction_control_mode = unpack_right_shift_u8(src_p[1], 0u, 0x0fu);
    dst_p->differential_mode = unpack_right_shift_u8(src_p[1], 4u, 0xf0u);
    dst_p->regen_mode = unpack_right_shift_u8(src_p[2], 0u, 0x0fu);
    dst_p->rotary_active_mode = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    dst_p->setup = unpack_right_shift_u8(src_p[3], 0u, 0x0fu);
    dst_p->main_menu = unpack_right_shift_u8(src_p[3], 4u, 0xf0u);
    dst_p->sub_menu = unpack_right_shift_u8(src_p[4], 0u, 0x0fu);
    dst_p->default_screen = unpack_right_shift_u8(src_p[4], 4u, 0x10u);
    dst_p->monitor = unpack_right_shift_u8(src_p[4], 5u, 0x20u);
    dst_p->cooling_status = unpack_right_shift_u8(src_p[4], 6u, 0x40u);
    dst_p->cooling_button = unpack_right_shift_u8(src_p[4], 7u, 0x80u);
    dst_p->screen = unpack_right_shift_u8(src_p[5], 0u, 0xffu);

    return (0);
}

int can_mcu_dash_bools_init(struct can_mcu_dash_bools_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_bools_t));

    return 0;
}

uint8_t can_mcu_dash_bools_ad_act_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_ad_act_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_ad_act_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_enable_request_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_enable_request_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_enable_request_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_start_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_start_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_start_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_sdc_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_sdc_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_sdc_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_steering_implausibility_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_steering_implausibility_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_steering_implausibility_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_plus_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_plus_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_plus_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_minus_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_minus_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_minus_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_enter_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_enter_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_enter_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_traction_control_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_traction_control_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_traction_control_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_differential_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_differential_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_differential_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_regen_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_regen_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_regen_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_rotary_active_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_rotary_active_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_rotary_active_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_setup_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_setup_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_setup_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_main_menu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_main_menu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_main_menu_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_sub_menu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_sub_menu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_sub_menu_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dash_bools_default_screen_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_default_screen_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_default_screen_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_monitor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_monitor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_monitor_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_cooling_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_cooling_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_cooling_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_cooling_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_cooling_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_cooling_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_bools_screen_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_bools_screen_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_bools_screen_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_susp_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_susp_f_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->susp_pot_fl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->susp_pot_fl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->susp_pot_fr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->susp_pot_fr, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->susp_sg_fr, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->susp_sg_fr, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->susp_sg_fl, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->susp_sg_fl, 8u, 0xffu);

    return (8);
}

int can_mcu_dash_susp_f_unpack(
    struct can_mcu_dash_susp_f_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->susp_pot_fl = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->susp_pot_fl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->susp_pot_fr = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->susp_pot_fr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->susp_sg_fr = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->susp_sg_fr |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->susp_sg_fl = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->susp_sg_fl |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_dash_susp_f_init(struct can_mcu_dash_susp_f_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_susp_f_t));

    return 0;
}

uint16_t can_mcu_dash_susp_f_susp_pot_fl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_susp_pot_fl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_susp_pot_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_susp_f_susp_pot_fr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_susp_pot_fr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_susp_pot_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_susp_f_susp_sg_fr_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_susp_sg_fr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_susp_sg_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_susp_f_susp_sg_fl_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_dash_susp_f_susp_sg_fl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_susp_f_susp_sg_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_adu_t *src_p,
    size_t size)
{
    uint16_t steering_offset;
    uint8_t power_k_w;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    power_k_w = (uint8_t)src_p->power_k_w;
    dst_p[0] |= pack_left_shift_u8(power_k_w, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->pl_active, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->regen_active, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->differential_active, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->tc_active, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->power_fault, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->vicor_thermistor, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->recom_thermistor, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->velocity, 8u, 0xffu);
    steering_offset = (uint16_t)src_p->steering_offset;
    dst_p[6] |= pack_left_shift_u16(steering_offset, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(steering_offset, 8u, 0xffu);

    return (8);
}

int can_mcu_ecu_adu_unpack(
    struct can_mcu_ecu_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t steering_offset;
    uint8_t power_k_w;

    if (size < 8u) {
        return (-EINVAL);
    }

    power_k_w = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->power_k_w = (int8_t)power_k_w;
    dst_p->pl_active = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->regen_active = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->differential_active = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->tc_active = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->power_fault = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->vicor_thermistor = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->recom_thermistor = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->velocity = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->velocity |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    steering_offset = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    steering_offset |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->steering_offset = (int16_t)steering_offset;

    return (0);
}

int can_mcu_ecu_adu_init(struct can_mcu_ecu_adu_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ecu_adu_t));

    return 0;
}

int8_t can_mcu_ecu_adu_power_k_w_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_ecu_adu_power_k_w_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_power_k_w_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_adu_pl_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_pl_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_pl_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_regen_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_regen_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_regen_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_differential_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_differential_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_differential_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_tc_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_tc_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_tc_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_power_fault_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_power_fault_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_power_fault_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_adu_vicor_thermistor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_vicor_thermistor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_vicor_thermistor_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_adu_recom_thermistor_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_adu_recom_thermistor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_recom_thermistor_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_ecu_adu_velocity_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_ecu_adu_velocity_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_ecu_adu_velocity_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_ecu_adu_steering_offset_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_ecu_adu_steering_offset_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_adu_steering_offset_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_states_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_states_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u8(src_p->green_tsal, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->safe_state, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->ts_off, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u16(src_p->dc_link_voltage, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->dc_link_voltage, 8u, 0xffu);

    return (6);
}

int can_mcu_aux_states_unpack(
    struct can_mcu_aux_states_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->green_tsal = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->safe_state = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->ts_off = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->dc_link_voltage = unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->dc_link_voltage |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);

    return (0);
}

int can_mcu_aux_states_init(struct can_mcu_aux_states_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_aux_states_t));

    return 0;
}

uint8_t can_mcu_aux_states_green_tsal_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_aux_states_green_tsal_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_aux_states_green_tsal_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_aux_states_safe_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_aux_states_safe_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_aux_states_safe_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_aux_states_ts_off_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_aux_states_ts_off_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_aux_states_ts_off_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t can_mcu_aux_states_dc_link_voltage_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_aux_states_dc_link_voltage_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_aux_states_dc_link_voltage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_ir_cams_r1_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_r1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->zone_rr1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->zone_rr1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->zone_rr2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->zone_rr2, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->zone_rr3, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->zone_rr3, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->zone_rr4, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->zone_rr4, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_ir_cams_r1_unpack(
    struct can_mcu_aux_ir_cams_r1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->zone_rr1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->zone_rr1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->zone_rr2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->zone_rr2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->zone_rr3 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->zone_rr3 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->zone_rr4 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->zone_rr4 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_aux_ir_cams_r1_init(struct can_mcu_aux_ir_cams_r1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_aux_ir_cams_r1_t));

    return 0;
}

uint16_t can_mcu_aux_ir_cams_r1_zone_rr1_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r1_zone_rr1_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r1_zone_rr1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r1_zone_rr2_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r1_zone_rr2_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r1_zone_rr2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r1_zone_rr3_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r1_zone_rr3_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r1_zone_rr3_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r1_zone_rr4_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r1_zone_rr4_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r1_zone_rr4_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_ir_cams_r2_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_r2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->zone_rr5, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->zone_rr5, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->zone_rr6, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->zone_rr6, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->zone_rr7, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->zone_rr7, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->zone_rr8, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->zone_rr8, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_ir_cams_r2_unpack(
    struct can_mcu_aux_ir_cams_r2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->zone_rr5 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->zone_rr5 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->zone_rr6 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->zone_rr6 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->zone_rr7 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->zone_rr7 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->zone_rr8 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->zone_rr8 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_aux_ir_cams_r2_init(struct can_mcu_aux_ir_cams_r2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_aux_ir_cams_r2_t));

    return 0;
}

uint16_t can_mcu_aux_ir_cams_r2_zone_rr5_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r2_zone_rr5_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r2_zone_rr5_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r2_zone_rr6_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r2_zone_rr6_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r2_zone_rr6_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r2_zone_rr7_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r2_zone_rr7_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r2_zone_rr7_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_r2_zone_rr8_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_r2_zone_rr8_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_r2_zone_rr8_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_ir_cams_l1_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_l1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->zone_rl1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->zone_rl1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->zone_rl2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->zone_rl2, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->zone_rl3, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->zone_rl3, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->zone_rl4, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->zone_rl4, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_ir_cams_l1_unpack(
    struct can_mcu_aux_ir_cams_l1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->zone_rl1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->zone_rl1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->zone_rl2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->zone_rl2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->zone_rl3 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->zone_rl3 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->zone_rl4 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->zone_rl4 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_aux_ir_cams_l1_init(struct can_mcu_aux_ir_cams_l1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_aux_ir_cams_l1_t));

    return 0;
}

uint16_t can_mcu_aux_ir_cams_l1_zone_rl1_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l1_zone_rl1_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l1_zone_rl1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l1_zone_rl2_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l1_zone_rl2_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l1_zone_rl2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l1_zone_rl3_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l1_zone_rl3_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l1_zone_rl3_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l1_zone_rl4_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l1_zone_rl4_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l1_zone_rl4_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_ir_cams_l2_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_l2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->zone_rl5, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->zone_rl5, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->zone_rl6, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->zone_rl6, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->zone_rl7, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->zone_rl7, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->zone_rl8, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->zone_rl8, 8u, 0xffu);

    return (8);
}

int can_mcu_aux_ir_cams_l2_unpack(
    struct can_mcu_aux_ir_cams_l2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->zone_rl5 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->zone_rl5 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->zone_rl6 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->zone_rl6 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->zone_rl7 = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->zone_rl7 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->zone_rl8 = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->zone_rl8 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_aux_ir_cams_l2_init(struct can_mcu_aux_ir_cams_l2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_aux_ir_cams_l2_t));

    return 0;
}

uint16_t can_mcu_aux_ir_cams_l2_zone_rl5_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l2_zone_rl5_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l2_zone_rl5_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l2_zone_rl6_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l2_zone_rl6_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l2_zone_rl6_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l2_zone_rl7_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l2_zone_rl7_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l2_zone_rl7_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_ir_cams_l2_zone_rl8_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_ir_cams_l2_zone_rl8_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_ir_cams_l2_zone_rl8_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_adu_inverter_left_pack(
    uint8_t *dst_p,
    const struct can_mcu_adu_inverter_left_t *src_p,
    size_t size)
{
    uint16_t rpm_l;
    uint16_t torque_l;
    uint8_t idc_integer;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->igbt_l, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->motor_l, 0u, 0xffu);
    rpm_l = (uint16_t)src_p->rpm_l;
    dst_p[2] |= pack_left_shift_u16(rpm_l, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(rpm_l, 8u, 0xffu);
    torque_l = (uint16_t)src_p->torque_l;
    dst_p[4] |= pack_left_shift_u16(torque_l, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(torque_l, 8u, 0xffu);
    idc_integer = (uint8_t)src_p->idc_integer;
    dst_p[6] |= pack_left_shift_u8(idc_integer, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->ac_temperature, 0u, 0xffu);

    return (8);
}

int can_mcu_adu_inverter_left_unpack(
    struct can_mcu_adu_inverter_left_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t rpm_l;
    uint16_t torque_l;
    uint8_t idc_integer;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->igbt_l = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->motor_l = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    rpm_l = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    rpm_l |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rpm_l = (int16_t)rpm_l;
    torque_l = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    torque_l |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_l = (int16_t)torque_l;
    idc_integer = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->idc_integer = (int8_t)idc_integer;
    dst_p->ac_temperature = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int can_mcu_adu_inverter_left_init(struct can_mcu_adu_inverter_left_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_adu_inverter_left_t));

    return 0;
}

uint8_t can_mcu_adu_inverter_left_igbt_l_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double can_mcu_adu_inverter_left_igbt_l_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool can_mcu_adu_inverter_left_igbt_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_adu_inverter_left_motor_l_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double can_mcu_adu_inverter_left_motor_l_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool can_mcu_adu_inverter_left_motor_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_adu_inverter_left_rpm_l_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_adu_inverter_left_rpm_l_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_adu_inverter_left_rpm_l_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_adu_inverter_left_torque_l_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_mcu_adu_inverter_left_torque_l_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_adu_inverter_left_torque_l_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_adu_inverter_left_idc_integer_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_adu_inverter_left_idc_integer_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_adu_inverter_left_idc_integer_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_adu_inverter_left_ac_temperature_encode(double value)
{
    return (uint8_t)(value / 0.5);
}

double can_mcu_adu_inverter_left_ac_temperature_decode(uint8_t value)
{
    return ((double)value * 0.5);
}

bool can_mcu_adu_inverter_left_ac_temperature_is_in_range(uint8_t value)
{
    return (value <= 198u);
}

int can_mcu_adu_inverter_right_pack(
    uint8_t *dst_p,
    const struct can_mcu_adu_inverter_right_t *src_p,
    size_t size)
{
    uint16_t rpm_r;
    uint16_t torque_r;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->igbt_r, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->motor_r, 0u, 0xffu);
    rpm_r = (uint16_t)src_p->rpm_r;
    dst_p[2] |= pack_left_shift_u16(rpm_r, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(rpm_r, 8u, 0xffu);
    torque_r = (uint16_t)src_p->torque_r;
    dst_p[4] |= pack_left_shift_u16(torque_r, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(torque_r, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->isa_vdc, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->isa_vdc, 8u, 0xffu);

    return (8);
}

int can_mcu_adu_inverter_right_unpack(
    struct can_mcu_adu_inverter_right_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t rpm_r;
    uint16_t torque_r;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->igbt_r = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->motor_r = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    rpm_r = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    rpm_r |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->rpm_r = (int16_t)rpm_r;
    torque_r = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    torque_r |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_r = (int16_t)torque_r;
    dst_p->isa_vdc = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->isa_vdc |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_adu_inverter_right_init(struct can_mcu_adu_inverter_right_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_adu_inverter_right_t));

    return 0;
}

uint8_t can_mcu_adu_inverter_right_igbt_r_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double can_mcu_adu_inverter_right_igbt_r_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool can_mcu_adu_inverter_right_igbt_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_adu_inverter_right_motor_r_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

double can_mcu_adu_inverter_right_motor_r_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool can_mcu_adu_inverter_right_motor_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_adu_inverter_right_rpm_r_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_adu_inverter_right_rpm_r_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_adu_inverter_right_rpm_r_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_adu_inverter_right_torque_r_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_mcu_adu_inverter_right_torque_r_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_adu_inverter_right_torque_r_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_adu_inverter_right_isa_vdc_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can_mcu_adu_inverter_right_isa_vdc_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_adu_inverter_right_isa_vdc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_aux_cables_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_cables_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->hv_cable1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->hv_cable1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->hv_cable2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->hv_cable2, 8u, 0xffu);

    return (4);
}

int can_mcu_aux_cables_unpack(
    struct can_mcu_aux_cables_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->hv_cable1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->hv_cable1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->hv_cable2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->hv_cable2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

int can_mcu_aux_cables_init(struct can_mcu_aux_cables_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_aux_cables_t));

    return 0;
}

uint16_t can_mcu_aux_cables_hv_cable1_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_cables_hv_cable1_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_cables_hv_cable1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_aux_cables_hv_cable2_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_aux_cables_hv_cable2_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_aux_cables_hv_cable2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_asb_pack(
    uint8_t *dst_p,
    const struct can_mcu_asb_t *src_p,
    size_t size)
{
    uint16_t ebs_tank_pressure;
    uint8_t initial_check_step;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->asms_state, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->tsms_out, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->asb_led, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->initial_checked, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_tank_pressure, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_brake_pressure, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_servo_check, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->monitor_apu, 7u, 0x80u);
    initial_check_step = (uint8_t)src_p->initial_check_step;
    dst_p[1] |= pack_left_shift_u8(initial_check_step, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->service_brake_status, 0u, 0x0fu);
    dst_p[2] |= pack_left_shift_u8(src_p->ebs_status, 4u, 0xf0u);
    ebs_tank_pressure = (uint16_t)src_p->ebs_tank_pressure;
    dst_p[3] |= pack_left_shift_u16(ebs_tank_pressure, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(ebs_tank_pressure, 8u, 0xffu);

    return (8);
}

int can_mcu_asb_unpack(
    struct can_mcu_asb_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t ebs_tank_pressure;
    uint8_t initial_check_step;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->asms_state = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->tsms_out = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->asb_led = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->initial_checked = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->monitor_tank_pressure = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->monitor_brake_pressure = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->monitor_servo_check = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->monitor_apu = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    initial_check_step = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->initial_check_step = (int8_t)initial_check_step;
    dst_p->service_brake_status = unpack_right_shift_u8(src_p[2], 0u, 0x0fu);
    dst_p->ebs_status = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    ebs_tank_pressure = unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    ebs_tank_pressure |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->ebs_tank_pressure = (int16_t)ebs_tank_pressure;

    return (0);
}

int can_mcu_asb_init(struct can_mcu_asb_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_asb_t));

    return 0;
}

uint8_t can_mcu_asb_asms_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_asms_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_asms_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_tsms_out_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_tsms_out_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_tsms_out_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_asb_led_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_asb_led_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_asb_led_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_initial_checked_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_initial_checked_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_initial_checked_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_tank_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_tank_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_tank_pressure_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_brake_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_brake_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_brake_pressure_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_servo_check_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_servo_check_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_servo_check_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_asb_monitor_apu_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_monitor_apu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_monitor_apu_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int8_t can_mcu_asb_initial_check_step_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_asb_initial_check_step_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_initial_check_step_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_asb_service_brake_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_service_brake_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_service_brake_status_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_asb_ebs_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_asb_ebs_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_asb_ebs_status_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

int16_t can_mcu_asb_ebs_tank_pressure_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_asb_ebs_tank_pressure_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_asb_ebs_tank_pressure_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_apu_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_command_t *src_p,
    size_t size)
{
    uint32_t throttle_brake_commanded;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&throttle_brake_commanded, &src_p->throttle_brake_commanded, sizeof(throttle_brake_commanded));
    dst_p[0] |= pack_left_shift_u32(throttle_brake_commanded, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(throttle_brake_commanded, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(throttle_brake_commanded, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(throttle_brake_commanded, 24u, 0xffu);

    return (4);
}

int can_mcu_apu_command_unpack(
    struct can_mcu_apu_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t throttle_brake_commanded;

    if (size < 4u) {
        return (-EINVAL);
    }

    throttle_brake_commanded = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->throttle_brake_commanded, &throttle_brake_commanded, sizeof(dst_p->throttle_brake_commanded));

    return (0);
}

int can_mcu_apu_command_init(struct can_mcu_apu_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_command_t));

    return 0;
}

float can_mcu_apu_command_throttle_brake_commanded_encode(double value)
{
    return (float)(value);
}

double can_mcu_apu_command_throttle_brake_commanded_decode(float value)
{
    return ((double)value);
}

bool can_mcu_apu_command_throttle_brake_commanded_is_in_range(float value)
{
    return ((value >= -1.0f) && (value <= 1.0f));
}

int can_mcu_apu_state_mission_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_state_mission_t *src_p,
    size_t size)
{
    uint8_t as_mission;

    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    as_mission = (uint8_t)src_p->as_mission;
    dst_p[0] |= pack_left_shift_u8(as_mission, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->as_state, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->as_set_finished, 0u, 0x01u);

    return (3);
}

int can_mcu_apu_state_mission_unpack(
    struct can_mcu_apu_state_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t as_mission;

    if (size < 3u) {
        return (-EINVAL);
    }

    as_mission = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->as_mission = (int8_t)as_mission;
    dst_p->as_state = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->as_set_finished = unpack_right_shift_u8(src_p[2], 0u, 0x01u);

    return (0);
}

int can_mcu_apu_state_mission_init(struct can_mcu_apu_state_mission_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_state_mission_t));

    return 0;
}

int8_t can_mcu_apu_state_mission_as_mission_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_apu_state_mission_as_mission_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_mission_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_apu_state_mission_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_state_mission_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_apu_state_mission_as_set_finished_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_state_mission_as_set_finished_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_state_mission_as_set_finished_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_ami_pack(
    uint8_t *dst_p,
    const struct can_mcu_ami_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->ami, 0u, 0xffu);

    return (1);
}

int can_mcu_ami_unpack(
    struct can_mcu_ami_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->ami = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int can_mcu_ami_init(struct can_mcu_ami_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ami_t));

    return 0;
}

uint8_t can_mcu_ami_ami_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ami_ami_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ami_ami_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_idc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_idc_t *src_p,
    size_t size)
{
    uint32_t idc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->idc_measurement_error, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->system_error, 7u, 0x80u);
    idc = (uint32_t)src_p->idc;
    dst_p[2] |= pack_left_shift_u32(idc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(idc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(idc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(idc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_idc_unpack(
    struct can_mcu_isabellen_idc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t idc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->idc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->system_error = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    idc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    idc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->idc = (int32_t)idc;

    return (0);
}

int can_mcu_isabellen_idc_init(struct can_mcu_isabellen_idc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_idc_t));

    return 0;
}

uint8_t can_mcu_isabellen_idc_idc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_idc_idc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_idc_idc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_isabellen_idc_system_error_encode(double value)
{
    return (uint8_t)(value / 7.0);
}

double can_mcu_isabellen_idc_system_error_decode(uint8_t value)
{
    return ((double)value * 7.0);
}

bool can_mcu_isabellen_idc_system_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_idc_idc_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_isabellen_idc_idc_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_isabellen_idc_idc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_vdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_vdc_t *src_p,
    size_t size)
{
    uint32_t vdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->vdc_measurement_error, 5u, 0x20u);
    vdc = (uint32_t)src_p->vdc;
    dst_p[2] |= pack_left_shift_u32(vdc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vdc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(vdc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vdc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_vdc_unpack(
    struct can_mcu_isabellen_vdc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->vdc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    vdc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    vdc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->vdc = (int32_t)vdc;

    return (0);
}

int can_mcu_isabellen_vdc_init(struct can_mcu_isabellen_vdc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_vdc_t));

    return 0;
}

uint8_t can_mcu_isabellen_vdc_vdc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_vdc_vdc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_vdc_vdc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_vdc_vdc_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_isabellen_vdc_vdc_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_isabellen_vdc_vdc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_pdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_pdc_t *src_p,
    size_t size)
{
    uint32_t pdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->pdc_measurement_error, 5u, 0x20u);
    pdc = (uint32_t)src_p->pdc;
    dst_p[2] |= pack_left_shift_u32(pdc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pdc, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(pdc, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(pdc, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_pdc_unpack(
    struct can_mcu_isabellen_pdc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pdc;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->pdc_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    pdc = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    pdc |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->pdc = (int32_t)pdc;

    return (0);
}

int can_mcu_isabellen_pdc_init(struct can_mcu_isabellen_pdc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_pdc_t));

    return 0;
}

uint8_t can_mcu_isabellen_pdc_pdc_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_pdc_pdc_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_pdc_pdc_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_pdc_pdc_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_isabellen_pdc_pdc_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_pdc_pdc_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_isabellen_energy_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_energy_t *src_p,
    size_t size)
{
    uint32_t energy;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[1] |= pack_left_shift_u8(src_p->energy_measurement_error, 5u, 0x20u);
    energy = (uint32_t)src_p->energy;
    dst_p[2] |= pack_left_shift_u32(energy, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(energy, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(energy, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(energy, 24u, 0xffu);

    return (6);
}

int can_mcu_isabellen_energy_unpack(
    struct can_mcu_isabellen_energy_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t energy;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->energy_measurement_error = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    energy = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    energy |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);
    dst_p->energy = (int32_t)energy;

    return (0);
}

int can_mcu_isabellen_energy_init(struct can_mcu_isabellen_energy_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_energy_t));

    return 0;
}

uint8_t can_mcu_isabellen_energy_energy_measurement_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_isabellen_energy_energy_measurement_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_energy_energy_measurement_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int32_t can_mcu_isabellen_energy_energy_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_isabellen_energy_energy_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_energy_energy_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_1_t *src_p,
    size_t size)
{
    uint8_t modes_of_operation_display;

    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u16(src_p->status_word, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->status_word, 8u, 0xffu);
    modes_of_operation_display = (uint8_t)src_p->modes_of_operation_display;
    dst_p[2] |= pack_left_shift_u8(modes_of_operation_display, 0u, 0xffu);

    return (3);
}

int can_mcu_bldc_tx_1_unpack(
    struct can_mcu_bldc_tx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t modes_of_operation_display;

    if (size < 3u) {
        return (-EINVAL);
    }

    dst_p->status_word = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->status_word |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    modes_of_operation_display = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->modes_of_operation_display = (int8_t)modes_of_operation_display;

    return (0);
}

int can_mcu_bldc_tx_1_init(struct can_mcu_bldc_tx_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_tx_1_t));

    return 0;
}

uint16_t can_mcu_bldc_tx_1_status_word_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_bldc_tx_1_status_word_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_1_status_word_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_bldc_tx_1_modes_of_operation_display_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_bldc_tx_1_modes_of_operation_display_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_1_modes_of_operation_display_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_1_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u16(src_p->controlword, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->controlword, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->mode_of_operation, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->motor_drive_submode_select, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 8u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->motor_drive_submode_select, 24u, 0xffu);

    return (7);
}

int can_mcu_bldc_rx_1_unpack(
    struct can_mcu_bldc_rx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    dst_p->controlword = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->controlword |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->mode_of_operation = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->motor_drive_submode_select = unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[4], 8u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    dst_p->motor_drive_submode_select |= unpack_left_shift_u32(src_p[6], 24u, 0xffu);

    return (0);
}

int can_mcu_bldc_rx_1_init(struct can_mcu_bldc_rx_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_rx_1_t));

    return 0;
}

uint16_t can_mcu_bldc_rx_1_controlword_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_bldc_rx_1_controlword_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_controlword_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_bldc_rx_1_mode_of_operation_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_bldc_rx_1_mode_of_operation_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_mode_of_operation_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_bldc_rx_1_motor_drive_submode_select_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_1_motor_drive_submode_select_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_1_motor_drive_submode_select_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_2_t *src_p,
    size_t size)
{
    uint32_t target_position;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    target_position = (uint32_t)src_p->target_position;
    dst_p[0] |= pack_left_shift_u32(target_position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(target_position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(target_position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(target_position, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->profile_velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->profile_velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->profile_velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->profile_velocity, 24u, 0xffu);

    return (8);
}

int can_mcu_bldc_rx_2_unpack(
    struct can_mcu_bldc_rx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t target_position;

    if (size < 8u) {
        return (-EINVAL);
    }

    target_position = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    target_position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->target_position = (int32_t)target_position;
    dst_p->profile_velocity = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->profile_velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int can_mcu_bldc_rx_2_init(struct can_mcu_bldc_rx_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_rx_2_t));

    return 0;
}

int32_t can_mcu_bldc_rx_2_target_position_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_bldc_rx_2_target_position_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_2_target_position_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_bldc_rx_2_profile_velocity_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_2_profile_velocity_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_2_profile_velocity_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_2_t *src_p,
    size_t size)
{
    uint32_t position_actual_value;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    position_actual_value = (uint32_t)src_p->position_actual_value;
    dst_p[0] |= pack_left_shift_u32(position_actual_value, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_actual_value, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_actual_value, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position_actual_value, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_tx_2_unpack(
    struct can_mcu_bldc_tx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t position_actual_value;

    if (size < 4u) {
        return (-EINVAL);
    }

    position_actual_value = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position_actual_value |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->position_actual_value = (int32_t)position_actual_value;

    return (0);
}

int can_mcu_bldc_tx_2_init(struct can_mcu_bldc_tx_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_tx_2_t));

    return 0;
}

int32_t can_mcu_bldc_tx_2_position_actual_value_encode(double value)
{
    return (int32_t)(value);
}

double can_mcu_bldc_tx_2_position_actual_value_decode(int32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_2_position_actual_value_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_3_t *src_p,
    size_t size)
{
    uint16_t velocity_actual_value;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    velocity_actual_value = (uint16_t)src_p->velocity_actual_value;
    dst_p[0] |= pack_left_shift_u16(velocity_actual_value, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_actual_value, 8u, 0xffu);

    return (2);
}

int can_mcu_bldc_tx_3_unpack(
    struct can_mcu_bldc_tx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_actual_value;

    if (size < 2u) {
        return (-EINVAL);
    }

    velocity_actual_value = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_actual_value |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_actual_value = (int16_t)velocity_actual_value;

    return (0);
}

int can_mcu_bldc_tx_3_init(struct can_mcu_bldc_tx_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_tx_3_t));

    return 0;
}

int16_t can_mcu_bldc_tx_3_velocity_actual_value_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_bldc_tx_3_velocity_actual_value_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_3_velocity_actual_value_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_3_t *src_p,
    size_t size)
{
    uint16_t target_velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    target_velocity = (uint16_t)src_p->target_velocity;
    dst_p[0] |= pack_left_shift_u16(target_velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(target_velocity, 8u, 0xffu);

    return (2);
}

int can_mcu_bldc_rx_3_unpack(
    struct can_mcu_bldc_rx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t target_velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    target_velocity = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    target_velocity |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->target_velocity = (int16_t)target_velocity;

    return (0);
}

int can_mcu_bldc_rx_3_init(struct can_mcu_bldc_rx_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_rx_3_t));

    return 0;
}

int16_t can_mcu_bldc_rx_3_target_velocity_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_bldc_rx_3_target_velocity_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_3_target_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_tx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_4_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->digital_input, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->digital_input, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->digital_input, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->digital_input, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_tx_4_unpack(
    struct can_mcu_bldc_tx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->digital_input = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->digital_input |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

int can_mcu_bldc_tx_4_init(struct can_mcu_bldc_tx_4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_tx_4_t));

    return 0;
}

uint32_t can_mcu_bldc_tx_4_digital_input_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_tx_4_digital_input_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_tx_4_digital_input_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bldc_rx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_4_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->digital_output, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->digital_output, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->digital_output, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->digital_output, 24u, 0xffu);

    return (4);
}

int can_mcu_bldc_rx_4_unpack(
    struct can_mcu_bldc_rx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->digital_output = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->digital_output |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

int can_mcu_bldc_rx_4_init(struct can_mcu_bldc_rx_4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bldc_rx_4_t));

    return 0;
}

uint32_t can_mcu_bldc_rx_4_digital_output_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_bldc_rx_4_digital_output_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_bldc_rx_4_digital_output_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_steering_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_steering_command_t *src_p,
    size_t size)
{
    uint16_t velocity_target;
    uint32_t position_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&position_target, &src_p->position_target, sizeof(position_target));
    dst_p[0] |= pack_left_shift_u32(position_target, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(position_target, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(position_target, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(position_target, 24u, 0xffu);
    velocity_target = (uint16_t)src_p->velocity_target;
    dst_p[4] |= pack_left_shift_u16(velocity_target, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_target, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->steering_mode, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->steering_mode, 8u, 0xffu);

    return (8);
}

int can_mcu_steering_command_unpack(
    struct can_mcu_steering_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_target;
    uint32_t position_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    position_target = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    position_target |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->position_target, &position_target, sizeof(dst_p->position_target));
    velocity_target = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_target |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_target = (int16_t)velocity_target;
    dst_p->steering_mode = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->steering_mode |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_steering_command_init(struct can_mcu_steering_command_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_steering_command_t));

    return 0;
}

float can_mcu_steering_command_position_target_encode(double value)
{
    return (float)(value);
}

double can_mcu_steering_command_position_target_decode(float value)
{
    return ((double)value);
}

bool can_mcu_steering_command_position_target_is_in_range(float value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_steering_command_velocity_target_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_steering_command_velocity_target_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_steering_command_velocity_target_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_steering_command_steering_mode_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_steering_command_steering_mode_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_steering_command_steering_mode_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_inverter_right_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_inverter_right_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->irms_max_r, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->irms_max_r, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->i_lim_in_use_r, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->i_lim_in_use_r, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->irms_r, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->irms_r, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->rpm_max_r, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->rpm_max_r, 8u, 0xffu);

    return (8);
}

int can_mcu_inverter_right_info_unpack(
    struct can_mcu_inverter_right_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->irms_max_r = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->irms_max_r |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->i_lim_in_use_r = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->i_lim_in_use_r |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->irms_r = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->irms_r |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->rpm_max_r = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->rpm_max_r |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_inverter_right_info_init(struct can_mcu_inverter_right_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_inverter_right_info_t));

    return 0;
}

uint16_t can_mcu_inverter_right_info_irms_max_r_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_right_info_irms_max_r_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_right_info_irms_max_r_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_right_info_i_lim_in_use_r_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_right_info_i_lim_in_use_r_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_right_info_i_lim_in_use_r_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_right_info_irms_r_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_right_info_irms_r_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_right_info_irms_r_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_right_info_rpm_max_r_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_right_info_rpm_max_r_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_right_info_rpm_max_r_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_inverter_left_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_inverter_left_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->irms_max_l, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->irms_max_l, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->i_lim_in_use_l, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->i_lim_in_use_l, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->irms_l, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->irms_l, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->rpm_max_l, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->rpm_max_l, 8u, 0xffu);

    return (8);
}

int can_mcu_inverter_left_info_unpack(
    struct can_mcu_inverter_left_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->irms_max_l = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->irms_max_l |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->i_lim_in_use_l = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->i_lim_in_use_l |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->irms_l = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->irms_l |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->rpm_max_l = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->rpm_max_l |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_inverter_left_info_init(struct can_mcu_inverter_left_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_inverter_left_info_t));

    return 0;
}

uint16_t can_mcu_inverter_left_info_irms_max_l_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_left_info_irms_max_l_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_left_info_irms_max_l_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_left_info_i_lim_in_use_l_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_left_info_i_lim_in_use_l_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_left_info_i_lim_in_use_l_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_left_info_irms_l_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_left_info_irms_l_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_left_info_irms_l_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_inverter_left_info_rpm_max_l_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_inverter_left_info_rpm_max_l_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_inverter_left_info_rpm_max_l_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_param_apu_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_param_apu_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->inverter_rpm_percentage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->inverter_rpm_percentage, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->inverter_irms_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->inverter_irms_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->power_target, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->servo_start_speed, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->regen_min_speed, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->ed_enable, 0u, 0x01u);
    dst_p[7] |= pack_left_shift_u8(src_p->tc_enable, 1u, 0x02u);

    return (8);
}

int can_mcu_ecu_param_apu_unpack(
    struct can_mcu_ecu_param_apu_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->inverter_rpm_percentage = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->inverter_rpm_percentage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->inverter_irms_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->inverter_irms_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->power_target = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->servo_start_speed = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->regen_min_speed = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->ed_enable = unpack_right_shift_u8(src_p[7], 0u, 0x01u);
    dst_p->tc_enable = unpack_right_shift_u8(src_p[7], 1u, 0x02u);

    return (0);
}

int can_mcu_ecu_param_apu_init(struct can_mcu_ecu_param_apu_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ecu_param_apu_t));

    return 0;
}

uint16_t can_mcu_ecu_param_apu_inverter_rpm_percentage_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_param_apu_inverter_rpm_percentage_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_apu_inverter_rpm_percentage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_ecu_param_apu_inverter_irms_max_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_param_apu_inverter_irms_max_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_apu_inverter_irms_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_apu_power_target_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_apu_power_target_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_apu_power_target_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_apu_servo_start_speed_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_apu_servo_start_speed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_apu_servo_start_speed_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_apu_regen_min_speed_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_apu_regen_min_speed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_apu_regen_min_speed_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_apu_ed_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_apu_ed_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_apu_ed_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_param_apu_tc_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_apu_tc_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_apu_tc_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_ecu_param_general_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_param_general_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->inverter_rpm_max_actual, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->inverter_irms_max_actual, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->power_target_actual, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->servo_start_speed_actual, 0u, 0xffu);

    return (8);
}

int can_mcu_ecu_param_general_unpack(
    struct can_mcu_ecu_param_general_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->inverter_rpm_max_actual = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->inverter_irms_max_actual = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->power_target_actual = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->servo_start_speed_actual = unpack_right_shift_u8(src_p[3], 0u, 0xffu);

    return (0);
}

int can_mcu_ecu_param_general_init(struct can_mcu_ecu_param_general_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ecu_param_general_t));

    return 0;
}

uint8_t can_mcu_ecu_param_general_inverter_rpm_max_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_general_inverter_rpm_max_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_general_inverter_rpm_max_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_general_inverter_irms_max_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_general_inverter_irms_max_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_general_inverter_irms_max_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_general_power_target_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_general_power_target_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_general_power_target_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_general_servo_start_speed_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_general_servo_start_speed_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_general_servo_start_speed_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s1_s2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s1_s2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s1_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s1_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s1_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s1_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s2_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s2_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s2_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s2_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s1_s2_unpack(
    struct can_mcu_bms_min_max_s1_s2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s1_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s1_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s1_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s1_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s2_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s2_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s2_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s2_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s1_s2_init(struct can_mcu_bms_min_max_s1_s2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s1_s2_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s1_s2_s1_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_s1_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_s1_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s1_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_s1_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_s1_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s2_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_s2_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_s2_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s1_s2_s2_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s1_s2_s2_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s1_s2_s2_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s3_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s3_s4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s3_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s3_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s3_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s3_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s4_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s4_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s4_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s4_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s3_s4_unpack(
    struct can_mcu_bms_min_max_s3_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s3_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s3_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s3_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s3_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s4_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s4_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s4_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s4_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s3_s4_init(struct can_mcu_bms_min_max_s3_s4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s3_s4_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s3_s4_s3_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_s3_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_s3_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s3_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_s3_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_s3_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s4_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_s4_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_s4_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s3_s4_s4_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s3_s4_s4_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s3_s4_s4_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s5_s6_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s5_s6_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s5_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s5_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s5_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s5_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s6_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s6_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s6_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s6_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s5_s6_unpack(
    struct can_mcu_bms_min_max_s5_s6_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s5_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s5_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s5_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s5_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s6_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s6_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s6_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s6_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s5_s6_init(struct can_mcu_bms_min_max_s5_s6_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s5_s6_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s5_s6_s5_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_s5_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_s5_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s5_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_s5_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_s5_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s6_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_s6_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_s6_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s5_s6_s6_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s5_s6_s6_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s5_s6_s6_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s7_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s7_s8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s7_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s7_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s7_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s7_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s8_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s8_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s8_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s8_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s7_s8_unpack(
    struct can_mcu_bms_min_max_s7_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s7_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s7_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s7_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s7_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s8_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s8_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s8_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s8_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s7_s8_init(struct can_mcu_bms_min_max_s7_s8_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s7_s8_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s7_s8_s7_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_s7_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_s7_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s7_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_s7_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_s7_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s8_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_s8_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_s8_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s7_s8_s8_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s7_s8_s8_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s7_s8_s8_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s9_s10_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s9_s10_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s9_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s9_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s9_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s9_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s10_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s10_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s10_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s10_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s9_s10_unpack(
    struct can_mcu_bms_min_max_s9_s10_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s9_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s9_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s9_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s9_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s10_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s10_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s10_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s10_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s9_s10_init(struct can_mcu_bms_min_max_s9_s10_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s9_s10_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s9_s10_s9_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_s9_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_s9_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s9_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_s9_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_s9_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s10_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_s10_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_s10_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s9_s10_s10_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s9_s10_s10_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s9_s10_s10_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_min_max_s11_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s11_s12_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s11_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s11_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s11_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s11_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s12_min, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s12_min, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s12_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s12_max, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_min_max_s11_s12_unpack(
    struct can_mcu_bms_min_max_s11_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s11_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s11_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s11_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s11_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s12_min = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s12_min |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s12_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s12_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_min_max_s11_s12_init(struct can_mcu_bms_min_max_s11_s12_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_min_max_s11_s12_t));

    return 0;
}

uint16_t can_mcu_bms_min_max_s11_s12_s11_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_s11_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_s11_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s11_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_s11_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_s11_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s12_min_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_s12_min_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_s12_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_min_max_s11_s12_s12_max_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double can_mcu_bms_min_max_s11_s12_s12_max_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_bms_min_max_s11_s12_s12_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s1_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s1_s4_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s1_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s1_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s2_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s2_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s3_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s3_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s4_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s4_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s1_s4_unpack(
    struct can_mcu_bms_max_temp_s1_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s1_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s1_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s2_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s2_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s3_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s3_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s4_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s4_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_max_temp_s1_s4_init(struct can_mcu_bms_max_temp_s1_s4_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_max_temp_s1_s4_t));

    return 0;
}

uint16_t can_mcu_bms_max_temp_s1_s4_s1_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s1_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s1_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s2_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s2_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s2_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s3_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s3_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s3_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s1_s4_s4_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s1_s4_s4_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s1_s4_s4_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s5_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s5_s8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s5_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s5_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s6_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s6_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s7_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s7_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s8_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s8_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s5_s8_unpack(
    struct can_mcu_bms_max_temp_s5_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s5_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s5_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s6_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s6_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s7_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s7_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s8_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s8_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_max_temp_s5_s8_init(struct can_mcu_bms_max_temp_s5_s8_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_max_temp_s5_s8_t));

    return 0;
}

uint16_t can_mcu_bms_max_temp_s5_s8_s5_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s5_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s5_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s6_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s6_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s6_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s7_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s7_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s7_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s5_s8_s8_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s5_s8_s8_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s5_s8_s8_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_bms_max_temp_s9_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s9_s12_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->s9_max_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->s9_max_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->s10_max_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->s10_max_temp, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->s11_max_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->s11_max_temp, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->s12_max_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->s12_max_temp, 8u, 0xffu);

    return (8);
}

int can_mcu_bms_max_temp_s9_s12_unpack(
    struct can_mcu_bms_max_temp_s9_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->s9_max_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->s9_max_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->s10_max_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->s10_max_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->s11_max_temp = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->s11_max_temp |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->s12_max_temp = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->s12_max_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_bms_max_temp_s9_s12_init(struct can_mcu_bms_max_temp_s9_s12_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_bms_max_temp_s9_s12_t));

    return 0;
}

uint16_t can_mcu_bms_max_temp_s9_s12_s9_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s9_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s9_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s10_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s10_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s10_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s11_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s11_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s11_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_bms_max_temp_s9_s12_s12_max_temp_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_bms_max_temp_s9_s12_s12_max_temp_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_bms_max_temp_s9_s12_s12_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_apu_temp_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_temp_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->cpu_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->cpu_temp, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->gpu_temp, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->gpu_temp, 8u, 0xffu);

    return (4);
}

int can_mcu_apu_temp_unpack(
    struct can_mcu_apu_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->cpu_temp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->cpu_temp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->gpu_temp = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->gpu_temp |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

int can_mcu_apu_temp_init(struct can_mcu_apu_temp_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_temp_t));

    return 0;
}

uint16_t can_mcu_apu_temp_cpu_temp_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_apu_temp_cpu_temp_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_temp_cpu_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_apu_temp_gpu_temp_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_apu_temp_gpu_temp_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_temp_gpu_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_brake_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_brake_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->brake_pressure, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->brake_pressure, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->brake_pressure_spare, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->brake_pressure_spare, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_sc_gnd, 0u, 0x01u);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_sc_sup, 1u, 0x02u);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_out_of_range, 2u, 0x04u);

    return (8);
}

int can_mcu_dash_brake_unpack(
    struct can_mcu_dash_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->brake_pressure = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->brake_pressure |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->brake_pressure_spare = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->brake_pressure_spare |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->brake_sc_gnd = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->brake_sc_sup = unpack_right_shift_u8(src_p[4], 1u, 0x02u);
    dst_p->brake_out_of_range = unpack_right_shift_u8(src_p[4], 2u, 0x04u);

    return (0);
}

int can_mcu_dash_brake_init(struct can_mcu_dash_brake_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_brake_t));

    return 0;
}

uint16_t can_mcu_dash_brake_brake_pressure_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_dash_brake_brake_pressure_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_dash_brake_brake_pressure_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_dash_brake_brake_pressure_spare_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_dash_brake_brake_pressure_spare_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_dash_brake_brake_pressure_spare_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dash_brake_brake_sc_gnd_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_sc_gnd_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_sc_gnd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_brake_brake_sc_sup_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_sc_sup_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_sc_sup_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dash_brake_brake_out_of_range_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dash_brake_brake_out_of_range_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dash_brake_brake_out_of_range_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_mcu_isabellen_16_bit_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_16_bit_t *src_p,
    size_t size)
{
    uint16_t idc_16_bit;
    uint16_t pdc_16_bit;
    uint16_t vdc_16_bit;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    vdc_16_bit = (uint16_t)src_p->vdc_16_bit;
    dst_p[0] |= pack_left_shift_u16(vdc_16_bit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(vdc_16_bit, 8u, 0xffu);
    pdc_16_bit = (uint16_t)src_p->pdc_16_bit;
    dst_p[2] |= pack_left_shift_u16(pdc_16_bit, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(pdc_16_bit, 8u, 0xffu);
    idc_16_bit = (uint16_t)src_p->idc_16_bit;
    dst_p[4] |= pack_left_shift_u16(idc_16_bit, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(idc_16_bit, 8u, 0xffu);

    return (8);
}

int can_mcu_isabellen_16_bit_unpack(
    struct can_mcu_isabellen_16_bit_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t idc_16_bit;
    uint16_t pdc_16_bit;
    uint16_t vdc_16_bit;

    if (size < 8u) {
        return (-EINVAL);
    }

    vdc_16_bit = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    vdc_16_bit |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->vdc_16_bit = (int16_t)vdc_16_bit;
    pdc_16_bit = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    pdc_16_bit |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->pdc_16_bit = (int16_t)pdc_16_bit;
    idc_16_bit = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    idc_16_bit |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->idc_16_bit = (int16_t)idc_16_bit;

    return (0);
}

int can_mcu_isabellen_16_bit_init(struct can_mcu_isabellen_16_bit_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_isabellen_16_bit_t));

    return 0;
}

int16_t can_mcu_isabellen_16_bit_vdc_16_bit_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_mcu_isabellen_16_bit_vdc_16_bit_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_mcu_isabellen_16_bit_vdc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_isabellen_16_bit_pdc_16_bit_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_isabellen_16_bit_pdc_16_bit_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_isabellen_16_bit_pdc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_isabellen_16_bit_idc_16_bit_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_isabellen_16_bit_idc_16_bit_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_isabellen_16_bit_idc_16_bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_param_control_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_param_control_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->ed_enable_actual, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->tc_enable_actual, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->regen_enable_actual, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->ed_a_actual, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->ed_d_actual, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->ed_steering_deadzone_actual, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->regen_min_speed_actual, 0u, 0xffu);

    return (8);
}

int can_mcu_ecu_param_control_unpack(
    struct can_mcu_ecu_param_control_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ed_enable_actual = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->tc_enable_actual = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->regen_enable_actual = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->ed_a_actual = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ed_d_actual = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->ed_steering_deadzone_actual = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->regen_min_speed_actual = unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

int can_mcu_ecu_param_control_init(struct can_mcu_ecu_param_control_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ecu_param_control_t));

    return 0;
}

uint8_t can_mcu_ecu_param_control_ed_enable_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_control_ed_enable_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_control_ed_enable_actual_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_param_control_tc_enable_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_control_tc_enable_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_control_tc_enable_actual_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_param_control_regen_enable_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_control_regen_enable_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_control_regen_enable_actual_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_ecu_param_control_ed_a_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_control_ed_a_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_control_ed_a_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_control_ed_d_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_control_ed_d_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_control_ed_d_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_ecu_param_control_ed_steering_deadzone_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_control_ed_steering_deadzone_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_control_ed_steering_deadzone_actual_is_in_range(uint8_t value)
{
    return (value <= 30u);
}

uint8_t can_mcu_ecu_param_control_regen_min_speed_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_ecu_param_control_regen_min_speed_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_param_control_regen_min_speed_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_apps_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_apps_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->apps, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->apps, 8u, 0xffu);

    return (8);
}

int can_mcu_ecu_apps_unpack(
    struct can_mcu_ecu_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->apps = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->apps |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    return (0);
}

int can_mcu_ecu_apps_init(struct can_mcu_ecu_apps_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ecu_apps_t));

    return 0;
}

uint16_t can_mcu_ecu_apps_apps_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_apps_apps_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_apps_apps_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_res_status_pack(
    uint8_t *dst_p,
    const struct can_mcu_res_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->stop, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->toggle, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->button, 2u, 0x04u);
    dst_p[6] |= pack_left_shift_u8(src_p->signal_strength, 0u, 0xffu);

    return (8);
}

int can_mcu_res_status_unpack(
    struct can_mcu_res_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->stop = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->toggle = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->button = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->signal_strength = unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

int can_mcu_res_status_init(struct can_mcu_res_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_res_status_t));

    return 0;
}

uint8_t can_mcu_res_status_stop_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_res_status_stop_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_res_status_stop_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_res_status_toggle_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_res_status_toggle_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_res_status_toggle_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_res_status_button_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_res_status_button_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_res_status_button_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_res_status_signal_strength_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_res_status_signal_strength_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_res_status_signal_strength_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

int can_mcu_dv_system_status_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_system_status_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->as_state, 0u, 0x07u);
    dst_p[0] |= pack_left_shift_u8(src_p->asb_ebs_state, 3u, 0x18u);
    dst_p[0] |= pack_left_shift_u8(src_p->ami_state, 5u, 0xe0u);
    dst_p[1] |= pack_left_shift_u8(src_p->steering_state, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->asb_redundancy_state, 1u, 0x06u);
    dst_p[1] |= pack_left_shift_u8(src_p->lap_counter, 3u, 0x78u);
    dst_p[1] |= pack_left_shift_u8(src_p->cones_count_actual, 7u, 0x80u);
    dst_p[2] |= pack_right_shift_u8(src_p->cones_count_actual, 1u, 0x7fu);
    dst_p[2] |= pack_left_shift_u32(src_p->cones_count_all, 7u, 0x80u);
    dst_p[3] |= pack_right_shift_u32(src_p->cones_count_all, 1u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->cones_count_all, 9u, 0xffu);

    return (5);
}

int can_mcu_dv_system_status_unpack(
    struct can_mcu_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->as_state = unpack_right_shift_u8(src_p[0], 0u, 0x07u);
    dst_p->asb_ebs_state = unpack_right_shift_u8(src_p[0], 3u, 0x18u);
    dst_p->ami_state = unpack_right_shift_u8(src_p[0], 5u, 0xe0u);
    dst_p->steering_state = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->asb_redundancy_state = unpack_right_shift_u8(src_p[1], 1u, 0x06u);
    dst_p->lap_counter = unpack_right_shift_u8(src_p[1], 3u, 0x78u);
    dst_p->cones_count_actual = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    dst_p->cones_count_actual |= unpack_left_shift_u8(src_p[2], 1u, 0x7fu);
    dst_p->cones_count_all = unpack_right_shift_u32(src_p[2], 7u, 0x80u);
    dst_p->cones_count_all |= unpack_left_shift_u32(src_p[3], 1u, 0xffu);
    dst_p->cones_count_all |= unpack_left_shift_u32(src_p[4], 9u, 0xffu);

    return (0);
}

int can_mcu_dv_system_status_init(struct can_mcu_dv_system_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dv_system_status_t));

    return 0;
}

uint8_t can_mcu_dv_system_status_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_as_state_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t can_mcu_dv_system_status_asb_ebs_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_asb_ebs_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_asb_ebs_state_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_mcu_dv_system_status_ami_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_ami_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_ami_state_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t can_mcu_dv_system_status_steering_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_steering_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_steering_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_mcu_dv_system_status_asb_redundancy_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_asb_redundancy_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_asb_redundancy_state_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_mcu_dv_system_status_lap_counter_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_lap_counter_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_lap_counter_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_mcu_dv_system_status_cones_count_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_system_status_cones_count_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_cones_count_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_dv_system_status_cones_count_all_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_dv_system_status_cones_count_all_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_dv_system_status_cones_count_all_is_in_range(uint32_t value)
{
    return (value <= 131071u);
}

int can_mcu_apu_res_init_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_res_init_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->requested_state, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->addresed_node, 0u, 0xffu);

    return (2);
}

int can_mcu_apu_res_init_unpack(
    struct can_mcu_apu_res_init_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->requested_state = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->addresed_node = unpack_right_shift_u8(src_p[1], 0u, 0xffu);

    return (0);
}

int can_mcu_apu_res_init_init(struct can_mcu_apu_res_init_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_res_init_t));

    return 0;
}

uint8_t can_mcu_apu_res_init_requested_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_res_init_requested_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_res_init_requested_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_apu_res_init_addresed_node_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_apu_res_init_addresed_node_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_apu_res_init_addresed_node_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_hdt_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_hdt_t *src_p,
    size_t size)
{
    uint16_t pitch;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->true_heading, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->true_heading, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->true_heading_acc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->true_heading_acc, 8u, 0xffu);
    pitch = (uint16_t)src_p->pitch;
    dst_p[4] |= pack_left_shift_u16(pitch, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(pitch, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->pitch_acc, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->pitch_acc, 8u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_gps1_hdt_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_hdt_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t pitch;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->true_heading = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->true_heading |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->true_heading_acc = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->true_heading_acc |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    pitch = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    pitch |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->pitch = (int16_t)pitch;
    dst_p->pitch_acc = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->pitch_acc |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_hdt_init(struct can_mcu_sbg_ecan_msg_gps1_hdt_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_hdt_t));

    return 0;
}

uint16_t can_mcu_sbg_ecan_msg_gps1_hdt_true_heading_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_hdt_true_heading_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_hdt_true_heading_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_gps1_hdt_true_heading_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_hdt_true_heading_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_hdt_true_heading_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_gps1_hdt_pitch_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_hdt_pitch_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_hdt_pitch_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_gps1_hdt_pitch_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_hdt_pitch_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_hdt_pitch_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_hdt_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_hdt_info_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u32(src_p->time_stamp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->time_stamp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->time_stamp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->time_stamp, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->status, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->status, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_gps1_hdt_info_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_hdt_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->time_stamp = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->status = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->status |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_hdt_info_init(struct can_mcu_sbg_ecan_msg_gps1_hdt_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_hdt_info_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_gps1_hdt_info_time_stamp_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_hdt_info_time_stamp_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_hdt_info_time_stamp_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint16_t can_mcu_sbg_ecan_msg_gps1_hdt_info_status_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_hdt_info_status_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_hdt_info_status_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_pos_acc_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_pos_acc_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->latitude_acc, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->latitude_acc, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->longitude_acc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->longitude_acc, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->altitude_acc, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->altitude_acc, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->base_station_id, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->base_station_id, 8u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_gps1_pos_acc_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->latitude_acc = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->latitude_acc |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->longitude_acc = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->longitude_acc |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->altitude_acc = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->altitude_acc |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->base_station_id = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->base_station_id |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_pos_acc_init(struct can_mcu_sbg_ecan_msg_gps1_pos_acc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_pos_acc_t));

    return 0;
}

uint16_t can_mcu_sbg_ecan_msg_gps1_pos_acc_latitude_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_pos_acc_latitude_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_acc_latitude_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_gps1_pos_acc_longitude_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_pos_acc_longitude_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_acc_longitude_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_gps1_pos_acc_altitude_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_pos_acc_altitude_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_acc_altitude_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_gps1_pos_acc_base_station_id_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_pos_acc_base_station_id_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_acc_base_station_id_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_pos_alt_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *src_p,
    size_t size)
{
    uint16_t undulation;
    uint32_t altitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    altitude = (uint32_t)src_p->altitude;
    dst_p[0] |= pack_left_shift_u32(altitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(altitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(altitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(altitude, 24u, 0xffu);
    undulation = (uint16_t)src_p->undulation;
    dst_p[4] |= pack_left_shift_u16(undulation, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(undulation, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->num_sv, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->diff_corr_age, 0u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_gps1_pos_alt_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t undulation;
    uint32_t altitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    altitude = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->altitude = (int32_t)altitude;
    undulation = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    undulation |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->undulation = (int16_t)undulation;
    dst_p->num_sv = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->diff_corr_age = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_pos_alt_init(struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_pos_alt_t));

    return 0;
}

int32_t can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_alt_altitude_is_in_range(int32_t value)
{
    return ((value >= -2147480000) && (value <= 2147480000));
}

int16_t can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_encode(double value)
{
    return (int16_t)(value / 0.005);
}

double can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_decode(int16_t value)
{
    return ((double)value * 0.005);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_alt_undulation_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_alt_num_sv_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_pos_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_pos_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    latitude = (uint32_t)src_p->latitude;
    dst_p[0] |= pack_left_shift_u32(latitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(latitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(latitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(latitude, 24u, 0xffu);
    longitude = (uint32_t)src_p->longitude;
    dst_p[4] |= pack_left_shift_u32(longitude, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(longitude, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(longitude, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(longitude, 24u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_gps1_pos_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    latitude = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->latitude = (int32_t)latitude;
    longitude = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    dst_p->longitude = (int32_t)longitude;

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_pos_init(struct can_mcu_sbg_ecan_msg_gps1_pos_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_pos_t));

    return 0;
}

int32_t can_mcu_sbg_ecan_msg_gps1_pos_latitude_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double can_mcu_sbg_ecan_msg_gps1_pos_latitude_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_latitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int32_t can_mcu_sbg_ecan_msg_gps1_pos_longitude_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double can_mcu_sbg_ecan_msg_gps1_pos_longitude_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_longitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_pos_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_pos_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->time_stamp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->time_stamp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->time_stamp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->time_stamp, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->status, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->status, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->status, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->status, 24u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_gps1_pos_info_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_pos_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->time_stamp = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->status = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->status |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->status |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->status |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_pos_info_init(struct can_mcu_sbg_ecan_msg_gps1_pos_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_pos_info_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_gps1_pos_info_time_stamp_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_pos_info_time_stamp_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_info_time_stamp_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint32_t can_mcu_sbg_ecan_msg_gps1_pos_info_status_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_pos_info_status_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_pos_info_status_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

int can_mcu_sbg_ecan_msg_gps1_vel_course_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_vel_course_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u16(src_p->course, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->course, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->course_acc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->course_acc, 8u, 0xffu);

    return (4);
}

int can_mcu_sbg_ecan_msg_gps1_vel_course_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_vel_course_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->course = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->course |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->course_acc = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->course_acc |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_vel_course_init(struct can_mcu_sbg_ecan_msg_gps1_vel_course_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_vel_course_t));

    return 0;
}

uint16_t can_mcu_sbg_ecan_msg_gps1_vel_course_course_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_course_course_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_course_course_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_gps1_vel_course_course_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_course_course_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_course_course_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_vel_acc_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_vel_acc_t *src_p,
    size_t size)
{
    uint16_t velocity_acc_d;
    uint16_t velocity_acc_e;
    uint16_t velocity_acc_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    velocity_acc_n = (uint16_t)src_p->velocity_acc_n;
    dst_p[0] |= pack_left_shift_u16(velocity_acc_n, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_acc_n, 8u, 0xffu);
    velocity_acc_e = (uint16_t)src_p->velocity_acc_e;
    dst_p[2] |= pack_left_shift_u16(velocity_acc_e, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(velocity_acc_e, 8u, 0xffu);
    velocity_acc_d = (uint16_t)src_p->velocity_acc_d;
    dst_p[4] |= pack_left_shift_u16(velocity_acc_d, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_acc_d, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_gps1_vel_acc_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_vel_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_acc_d;
    uint16_t velocity_acc_e;
    uint16_t velocity_acc_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    velocity_acc_n = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_acc_n |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_acc_n = (int16_t)velocity_acc_n;
    velocity_acc_e = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    velocity_acc_e |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->velocity_acc_e = (int16_t)velocity_acc_e;
    velocity_acc_d = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_acc_d |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_acc_d = (int16_t)velocity_acc_d;

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_vel_acc_init(struct can_mcu_sbg_ecan_msg_gps1_vel_acc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_vel_acc_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_vel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_vel_t *src_p,
    size_t size)
{
    uint16_t velocity_d;
    uint16_t velocity_e;
    uint16_t velocity_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    velocity_n = (uint16_t)src_p->velocity_n;
    dst_p[0] |= pack_left_shift_u16(velocity_n, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_n, 8u, 0xffu);
    velocity_e = (uint16_t)src_p->velocity_e;
    dst_p[2] |= pack_left_shift_u16(velocity_e, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(velocity_e, 8u, 0xffu);
    velocity_d = (uint16_t)src_p->velocity_d;
    dst_p[4] |= pack_left_shift_u16(velocity_d, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_d, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_gps1_vel_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_d;
    uint16_t velocity_e;
    uint16_t velocity_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    velocity_n = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_n |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_n = (int16_t)velocity_n;
    velocity_e = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    velocity_e |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->velocity_e = (int16_t)velocity_e;
    velocity_d = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_d |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_d = (int16_t)velocity_d;

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_vel_init(struct can_mcu_sbg_ecan_msg_gps1_vel_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_vel_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_n_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_e_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_velocity_d_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_gps1_vel_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_gps1_vel_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->time_stamp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->time_stamp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->time_stamp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->time_stamp, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->status, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->status, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->status, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->status, 24u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_gps1_vel_info_unpack(
    struct can_mcu_sbg_ecan_msg_gps1_vel_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->time_stamp = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->status = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->status |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->status |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->status |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_gps1_vel_info_init(struct can_mcu_sbg_ecan_msg_gps1_vel_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_gps1_vel_info_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_gps1_vel_info_time_stamp_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_vel_info_time_stamp_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_info_time_stamp_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint32_t can_mcu_sbg_ecan_msg_gps1_vel_info_status_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_gps1_vel_info_status_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_gps1_vel_info_status_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

int can_mcu_sbg_ecan_msg_odo_vel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_odo_vel_t *src_p,
    size_t size)
{
    uint16_t velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    velocity = (uint16_t)src_p->velocity;
    dst_p[0] |= pack_left_shift_u16(velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity, 8u, 0xffu);

    return (2);
}

int can_mcu_sbg_ecan_msg_odo_vel_unpack(
    struct can_mcu_sbg_ecan_msg_odo_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity;

    if (size < 2u) {
        return (-EINVAL);
    }

    velocity = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity = (int16_t)velocity;

    return (0);
}

int can_mcu_sbg_ecan_msg_odo_vel_init(struct can_mcu_sbg_ecan_msg_odo_vel_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_odo_vel_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_odo_vel_velocity_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_odo_vel_velocity_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_odo_vel_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_odo_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_odo_info_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u32(src_p->time_stamp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->time_stamp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->time_stamp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->time_stamp, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->odo_status, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->odo_status, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_odo_info_unpack(
    struct can_mcu_sbg_ecan_msg_odo_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->time_stamp = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->odo_status = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->odo_status |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_odo_info_init(struct can_mcu_sbg_ecan_msg_odo_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_odo_info_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_odo_info_time_stamp_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_odo_info_time_stamp_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_odo_info_time_stamp_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint16_t can_mcu_sbg_ecan_msg_odo_info_odo_status_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_sbg_ecan_msg_odo_info_odo_status_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_odo_info_odo_status_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_mag_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_mag_2_t *src_p,
    size_t size)
{
    uint16_t accel_x;
    uint16_t accel_y;
    uint16_t accel_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    accel_x = (uint16_t)src_p->accel_x;
    dst_p[0] |= pack_left_shift_u16(accel_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(accel_x, 8u, 0xffu);
    accel_y = (uint16_t)src_p->accel_y;
    dst_p[2] |= pack_left_shift_u16(accel_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(accel_y, 8u, 0xffu);
    accel_z = (uint16_t)src_p->accel_z;
    dst_p[4] |= pack_left_shift_u16(accel_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(accel_z, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_mag_2_unpack(
    struct can_mcu_sbg_ecan_msg_mag_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t accel_x;
    uint16_t accel_y;
    uint16_t accel_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    accel_x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    accel_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->accel_x = (int16_t)accel_x;
    accel_y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    accel_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->accel_y = (int16_t)accel_y;
    accel_z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    accel_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->accel_z = (int16_t)accel_z;

    return (0);
}

int can_mcu_sbg_ecan_msg_mag_2_init(struct can_mcu_sbg_ecan_msg_mag_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_mag_2_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_mag_2_accel_x_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_mag_2_accel_x_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_mag_2_accel_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_mag_2_accel_y_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_mag_2_accel_y_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_mag_2_accel_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_mag_2_accel_z_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_mag_2_accel_z_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_mag_2_accel_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_mag_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_mag_1_t *src_p,
    size_t size)
{
    uint16_t mag_x;
    uint16_t mag_y;
    uint16_t mag_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    mag_x = (uint16_t)src_p->mag_x;
    dst_p[0] |= pack_left_shift_u16(mag_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(mag_x, 8u, 0xffu);
    mag_y = (uint16_t)src_p->mag_y;
    dst_p[2] |= pack_left_shift_u16(mag_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(mag_y, 8u, 0xffu);
    mag_z = (uint16_t)src_p->mag_z;
    dst_p[4] |= pack_left_shift_u16(mag_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(mag_z, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_mag_1_unpack(
    struct can_mcu_sbg_ecan_msg_mag_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t mag_x;
    uint16_t mag_y;
    uint16_t mag_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    mag_x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    mag_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->mag_x = (int16_t)mag_x;
    mag_y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    mag_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->mag_y = (int16_t)mag_y;
    mag_z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    mag_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->mag_z = (int16_t)mag_z;

    return (0);
}

int can_mcu_sbg_ecan_msg_mag_1_init(struct can_mcu_sbg_ecan_msg_mag_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_mag_1_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_mag_1_mag_x_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_mag_1_mag_x_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_mag_1_mag_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_mag_1_mag_y_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_mag_1_mag_y_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_mag_1_mag_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_mag_1_mag_z_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_mag_1_mag_z_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_mag_1_mag_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_mag_0_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_mag_0_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u32(src_p->time_stamp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->time_stamp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->time_stamp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->time_stamp, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->status, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->status, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_mag_0_unpack(
    struct can_mcu_sbg_ecan_msg_mag_0_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->time_stamp = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->status = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->status |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_mag_0_init(struct can_mcu_sbg_ecan_msg_mag_0_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_mag_0_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_mag_0_time_stamp_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_mag_0_time_stamp_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_mag_0_time_stamp_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint16_t can_mcu_sbg_ecan_msg_mag_0_status_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_sbg_ecan_msg_mag_0_status_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_mag_0_status_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_vel_body_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *src_p,
    size_t size)
{
    uint16_t velocity_x;
    uint16_t velocity_y;
    uint16_t velocity_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    velocity_x = (uint16_t)src_p->velocity_x;
    dst_p[0] |= pack_left_shift_u16(velocity_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_x, 8u, 0xffu);
    velocity_y = (uint16_t)src_p->velocity_y;
    dst_p[2] |= pack_left_shift_u16(velocity_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(velocity_y, 8u, 0xffu);
    velocity_z = (uint16_t)src_p->velocity_z;
    dst_p[4] |= pack_left_shift_u16(velocity_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_z, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_vel_body_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_x;
    uint16_t velocity_y;
    uint16_t velocity_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    velocity_x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_x = (int16_t)velocity_x;
    velocity_y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    velocity_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->velocity_y = (int16_t)velocity_y;
    velocity_z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_z = (int16_t)velocity_z;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_vel_body_init(struct can_mcu_sbg_ecan_msg_ekf_vel_body_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_vel_body_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_body_velocity_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_t *src_p,
    size_t size)
{
    uint16_t velocity_acc_d;
    uint16_t velocity_acc_e;
    uint16_t velocity_acc_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    velocity_acc_n = (uint16_t)src_p->velocity_acc_n;
    dst_p[0] |= pack_left_shift_u16(velocity_acc_n, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_acc_n, 8u, 0xffu);
    velocity_acc_e = (uint16_t)src_p->velocity_acc_e;
    dst_p[2] |= pack_left_shift_u16(velocity_acc_e, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(velocity_acc_e, 8u, 0xffu);
    velocity_acc_d = (uint16_t)src_p->velocity_acc_d;
    dst_p[4] |= pack_left_shift_u16(velocity_acc_d, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_acc_d, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_acc_d;
    uint16_t velocity_acc_e;
    uint16_t velocity_acc_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    velocity_acc_n = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_acc_n |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_acc_n = (int16_t)velocity_acc_n;
    velocity_acc_e = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    velocity_acc_e |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->velocity_acc_e = (int16_t)velocity_acc_e;
    velocity_acc_d = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_acc_d |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_acc_d = (int16_t)velocity_acc_d;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_init(struct can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *src_p,
    size_t size)
{
    uint16_t velocity_d;
    uint16_t velocity_e;
    uint16_t velocity_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    velocity_n = (uint16_t)src_p->velocity_n;
    dst_p[0] |= pack_left_shift_u16(velocity_n, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(velocity_n, 8u, 0xffu);
    velocity_e = (uint16_t)src_p->velocity_e;
    dst_p[2] |= pack_left_shift_u16(velocity_e, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(velocity_e, 8u, 0xffu);
    velocity_d = (uint16_t)src_p->velocity_d;
    dst_p[4] |= pack_left_shift_u16(velocity_d, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(velocity_d, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t velocity_d;
    uint16_t velocity_e;
    uint16_t velocity_n;

    if (size < 6u) {
        return (-EINVAL);
    }

    velocity_n = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    velocity_n |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->velocity_n = (int16_t)velocity_n;
    velocity_e = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    velocity_e |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->velocity_e = (int16_t)velocity_e;
    velocity_d = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    velocity_d |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->velocity_d = (int16_t)velocity_d;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_vel_ned_init(struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_vel_ned_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_n_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_e_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_vel_ned_velocity_d_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_pos_acc_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_pos_acc_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u16(src_p->latitude_acc, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->latitude_acc, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->longitude_acc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->longitude_acc, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->altitude_acc, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->altitude_acc, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_pos_acc_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->latitude_acc = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->latitude_acc |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->longitude_acc = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->longitude_acc |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->altitude_acc = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->altitude_acc |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_pos_acc_init(struct can_mcu_sbg_ecan_msg_ekf_pos_acc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_pos_acc_t));

    return 0;
}

uint16_t can_mcu_sbg_ecan_msg_ekf_pos_acc_latitude_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_pos_acc_latitude_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_pos_acc_latitude_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_ekf_pos_acc_longitude_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_pos_acc_longitude_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_pos_acc_longitude_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_ekf_pos_acc_altitude_acc_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_ekf_pos_acc_altitude_acc_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_ekf_pos_acc_altitude_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_altitude_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_altitude_t *src_p,
    size_t size)
{
    uint16_t undulation;
    uint32_t altitude;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    altitude = (uint32_t)src_p->altitude;
    dst_p[0] |= pack_left_shift_u32(altitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(altitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(altitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(altitude, 24u, 0xffu);
    undulation = (uint16_t)src_p->undulation;
    dst_p[4] |= pack_left_shift_u16(undulation, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(undulation, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_altitude_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_altitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t undulation;
    uint32_t altitude;

    if (size < 6u) {
        return (-EINVAL);
    }

    altitude = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    altitude |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->altitude = (int32_t)altitude;
    undulation = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    undulation |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->undulation = (int16_t)undulation;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_altitude_init(struct can_mcu_sbg_ecan_msg_ekf_altitude_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_altitude_t));

    return 0;
}

int32_t can_mcu_sbg_ecan_msg_ekf_altitude_altitude_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_ekf_altitude_altitude_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_ekf_altitude_altitude_is_in_range(int32_t value)
{
    return ((value >= -2147480000) && (value <= 2147480000));
}

int16_t can_mcu_sbg_ecan_msg_ekf_altitude_undulation_encode(double value)
{
    return (int16_t)(value / 0.005);
}

double can_mcu_sbg_ecan_msg_ekf_altitude_undulation_decode(int16_t value)
{
    return ((double)value * 0.005);
}

bool can_mcu_sbg_ecan_msg_ekf_altitude_undulation_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_pos_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_pos_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    latitude = (uint32_t)src_p->latitude;
    dst_p[0] |= pack_left_shift_u32(latitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(latitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(latitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(latitude, 24u, 0xffu);
    longitude = (uint32_t)src_p->longitude;
    dst_p[4] |= pack_left_shift_u32(longitude, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(longitude, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(longitude, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(longitude, 24u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_ekf_pos_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t latitude;
    uint32_t longitude;

    if (size < 8u) {
        return (-EINVAL);
    }

    latitude = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    latitude |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->latitude = (int32_t)latitude;
    longitude = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    longitude |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    dst_p->longitude = (int32_t)longitude;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_pos_init(struct can_mcu_sbg_ecan_msg_ekf_pos_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_pos_t));

    return 0;
}

int32_t can_mcu_sbg_ecan_msg_ekf_pos_latitude_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double can_mcu_sbg_ecan_msg_ekf_pos_latitude_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool can_mcu_sbg_ecan_msg_ekf_pos_latitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int32_t can_mcu_sbg_ecan_msg_ekf_pos_longitude_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double can_mcu_sbg_ecan_msg_ekf_pos_longitude_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool can_mcu_sbg_ecan_msg_ekf_pos_longitude_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_orientation_acc_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_orientation_acc_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u16(src_p->roll_acc, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->roll_acc, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->pitch_acc, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->pitch_acc, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->yaw_acc, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->yaw_acc, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_orientation_acc_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_orientation_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->roll_acc = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->roll_acc |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->pitch_acc = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->pitch_acc |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->yaw_acc = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->yaw_acc |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_orientation_acc_init(struct can_mcu_sbg_ecan_msg_ekf_orientation_acc_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_orientation_acc_t));

    return 0;
}

uint16_t can_mcu_sbg_ecan_msg_ekf_orientation_acc_roll_acc_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_orientation_acc_roll_acc_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_orientation_acc_roll_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_encode(double value)
{
    return (uint16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_decode(uint16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_ekf_euler_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_ekf_euler_t *src_p,
    size_t size)
{
    uint16_t pitch;
    uint16_t roll;
    uint16_t yaw;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    roll = (uint16_t)src_p->roll;
    dst_p[0] |= pack_left_shift_u16(roll, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(roll, 8u, 0xffu);
    pitch = (uint16_t)src_p->pitch;
    dst_p[2] |= pack_left_shift_u16(pitch, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(pitch, 8u, 0xffu);
    yaw = (uint16_t)src_p->yaw;
    dst_p[4] |= pack_left_shift_u16(yaw, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(yaw, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_ekf_euler_unpack(
    struct can_mcu_sbg_ecan_msg_ekf_euler_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t pitch;
    uint16_t roll;
    uint16_t yaw;

    if (size < 6u) {
        return (-EINVAL);
    }

    roll = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    roll |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->roll = (int16_t)roll;
    pitch = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    pitch |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->pitch = (int16_t)pitch;
    yaw = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    yaw |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->yaw = (int16_t)yaw;

    return (0);
}

int can_mcu_sbg_ecan_msg_ekf_euler_init(struct can_mcu_sbg_ecan_msg_ekf_euler_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_ekf_euler_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_ekf_euler_roll_encode(double value)
{
    return (int16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_euler_roll_decode(int16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_euler_roll_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_euler_pitch_encode(double value)
{
    return (int16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_euler_pitch_decode(int16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_euler_pitch_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_ekf_euler_yaw_encode(double value)
{
    return (int16_t)(value / 0.0001);
}

double can_mcu_sbg_ecan_msg_ekf_euler_yaw_decode(int16_t value)
{
    return ((double)value * 0.0001);
}

bool can_mcu_sbg_ecan_msg_ekf_euler_yaw_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_imu_gyro_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_imu_gyro_t *src_p,
    size_t size)
{
    uint16_t gyro_x;
    uint16_t gyro_y;
    uint16_t gyro_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    gyro_x = (uint16_t)src_p->gyro_x;
    dst_p[0] |= pack_left_shift_u16(gyro_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(gyro_x, 8u, 0xffu);
    gyro_y = (uint16_t)src_p->gyro_y;
    dst_p[2] |= pack_left_shift_u16(gyro_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(gyro_y, 8u, 0xffu);
    gyro_z = (uint16_t)src_p->gyro_z;
    dst_p[4] |= pack_left_shift_u16(gyro_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(gyro_z, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_imu_gyro_unpack(
    struct can_mcu_sbg_ecan_msg_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t gyro_x;
    uint16_t gyro_y;
    uint16_t gyro_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    gyro_x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    gyro_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->gyro_x = (int16_t)gyro_x;
    gyro_y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    gyro_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->gyro_y = (int16_t)gyro_y;
    gyro_z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    gyro_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->gyro_z = (int16_t)gyro_z;

    return (0);
}

int can_mcu_sbg_ecan_msg_imu_gyro_init(struct can_mcu_sbg_ecan_msg_imu_gyro_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_imu_gyro_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_encode(double value)
{
    return (int16_t)(value / 0.001);
}

double can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_decode(int16_t value)
{
    return ((double)value * 0.001);
}

bool can_mcu_sbg_ecan_msg_imu_gyro_gyro_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_imu_accel_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_imu_accel_t *src_p,
    size_t size)
{
    uint16_t accel_x;
    uint16_t accel_y;
    uint16_t accel_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    accel_x = (uint16_t)src_p->accel_x;
    dst_p[0] |= pack_left_shift_u16(accel_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(accel_x, 8u, 0xffu);
    accel_y = (uint16_t)src_p->accel_y;
    dst_p[2] |= pack_left_shift_u16(accel_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(accel_y, 8u, 0xffu);
    accel_z = (uint16_t)src_p->accel_z;
    dst_p[4] |= pack_left_shift_u16(accel_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(accel_z, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_imu_accel_unpack(
    struct can_mcu_sbg_ecan_msg_imu_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t accel_x;
    uint16_t accel_y;
    uint16_t accel_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    accel_x = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    accel_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->accel_x = (int16_t)accel_x;
    accel_y = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    accel_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->accel_y = (int16_t)accel_y;
    accel_z = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    accel_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->accel_z = (int16_t)accel_z;

    return (0);
}

int can_mcu_sbg_ecan_msg_imu_accel_init(struct can_mcu_sbg_ecan_msg_imu_accel_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_imu_accel_t));

    return 0;
}

int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_x_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_imu_accel_accel_x_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_imu_accel_accel_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_y_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_imu_accel_accel_y_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_imu_accel_accel_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_accel_accel_z_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_imu_accel_accel_z_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_imu_accel_accel_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_imu_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_imu_info_t *src_p,
    size_t size)
{
    uint16_t temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->time_stamp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->time_stamp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->time_stamp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->time_stamp, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->status, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->status, 8u, 0xffu);
    temperature = (uint16_t)src_p->temperature;
    dst_p[6] |= pack_left_shift_u16(temperature, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(temperature, 8u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_imu_info_unpack(
    struct can_mcu_sbg_ecan_msg_imu_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->time_stamp = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->status = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->status |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    temperature = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    temperature |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->temperature = (int16_t)temperature;

    return (0);
}

int can_mcu_sbg_ecan_msg_imu_info_init(struct can_mcu_sbg_ecan_msg_imu_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_imu_info_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_imu_info_time_stamp_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_imu_info_time_stamp_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_imu_info_time_stamp_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint16_t can_mcu_sbg_ecan_msg_imu_info_status_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_sbg_ecan_msg_imu_info_status_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_imu_info_status_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_sbg_ecan_msg_imu_info_temperature_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double can_mcu_sbg_ecan_msg_imu_info_temperature_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool can_mcu_sbg_ecan_msg_imu_info_temperature_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_utc_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_utc_1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->year, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->month, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->day, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->hour, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->min, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->sec, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->micro_sec, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->micro_sec, 8u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_utc_1_unpack(
    struct can_mcu_sbg_ecan_msg_utc_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->year = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->month = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->day = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->hour = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->min = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->sec = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->micro_sec = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->micro_sec |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_utc_1_init(struct can_mcu_sbg_ecan_msg_utc_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_utc_1_t));

    return 0;
}

uint8_t can_mcu_sbg_ecan_msg_utc_1_year_encode(double value)
{
    return (uint8_t)(value - 2000.0);
}

double can_mcu_sbg_ecan_msg_utc_1_year_decode(uint8_t value)
{
    return ((double)value + 2000.0);
}

bool can_mcu_sbg_ecan_msg_utc_1_year_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_utc_1_month_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_utc_1_month_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_utc_1_month_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_utc_1_day_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_utc_1_day_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_utc_1_day_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_utc_1_hour_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_utc_1_hour_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_utc_1_hour_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_utc_1_min_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_utc_1_min_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_utc_1_min_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_sbg_ecan_msg_utc_1_sec_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_sbg_ecan_msg_utc_1_sec_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_utc_1_sec_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_utc_1_micro_sec_encode(double value)
{
    return (uint16_t)(value / 100.0);
}

double can_mcu_sbg_ecan_msg_utc_1_micro_sec_decode(uint16_t value)
{
    return ((double)value * 100.0);
}

bool can_mcu_sbg_ecan_msg_utc_1_micro_sec_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_utc_0_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_utc_0_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->time_stamp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->time_stamp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->time_stamp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->time_stamp, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->gps_tow, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->gps_tow, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->gps_tow, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->gps_tow, 24u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_utc_0_unpack(
    struct can_mcu_sbg_ecan_msg_utc_0_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->time_stamp = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->gps_tow = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->gps_tow |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->gps_tow |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->gps_tow |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_utc_0_init(struct can_mcu_sbg_ecan_msg_utc_0_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_utc_0_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_utc_0_time_stamp_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_utc_0_time_stamp_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_utc_0_time_stamp_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint32_t can_mcu_sbg_ecan_msg_utc_0_gps_tow_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_utc_0_gps_tow_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_utc_0_gps_tow_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

int can_mcu_sbg_ecan_msg_status_03_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_status_03_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u32(src_p->solution, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->solution, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->solution, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->solution, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->heave_status, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->heave_status, 8u, 0xffu);

    return (6);
}

int can_mcu_sbg_ecan_msg_status_03_unpack(
    struct can_mcu_sbg_ecan_msg_status_03_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->solution = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->solution |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->solution |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->solution |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->heave_status = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->heave_status |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_status_03_init(struct can_mcu_sbg_ecan_msg_status_03_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_status_03_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_status_03_solution_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_status_03_solution_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_status_03_solution_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint16_t can_mcu_sbg_ecan_msg_status_03_heave_status_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_sbg_ecan_msg_status_03_heave_status_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_status_03_heave_status_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_sbg_ecan_msg_status_02_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_status_02_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->com, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->com, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->com, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->com, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->aiding, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->aiding, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->aiding, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->aiding, 24u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_status_02_unpack(
    struct can_mcu_sbg_ecan_msg_status_02_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->com = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->com |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->com |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->com |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->aiding = unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->aiding |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->aiding |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->aiding |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_status_02_init(struct can_mcu_sbg_ecan_msg_status_02_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_status_02_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_status_02_com_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_status_02_com_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_status_02_com_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint32_t can_mcu_sbg_ecan_msg_status_02_aiding_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_status_02_aiding_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_status_02_aiding_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

int can_mcu_sbg_ecan_msg_status_01_pack(
    uint8_t *dst_p,
    const struct can_mcu_sbg_ecan_msg_status_01_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->time_stamp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->time_stamp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->time_stamp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->time_stamp, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->general, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->general, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->clock, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->clock, 8u, 0xffu);

    return (8);
}

int can_mcu_sbg_ecan_msg_status_01_unpack(
    struct can_mcu_sbg_ecan_msg_status_01_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->time_stamp = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->time_stamp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->general = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->general |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->clock = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->clock |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_sbg_ecan_msg_status_01_init(struct can_mcu_sbg_ecan_msg_status_01_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_sbg_ecan_msg_status_01_t));

    return 0;
}

uint32_t can_mcu_sbg_ecan_msg_status_01_time_stamp_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_sbg_ecan_msg_status_01_time_stamp_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_status_01_time_stamp_is_in_range(uint32_t value)
{
    return (value <= 2704u);
}

uint16_t can_mcu_sbg_ecan_msg_status_01_general_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_sbg_ecan_msg_status_01_general_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_status_01_general_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_sbg_ecan_msg_status_01_clock_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_sbg_ecan_msg_status_01_clock_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_sbg_ecan_msg_status_01_clock_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_param_tuning_general_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_param_tuning_general_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u16(src_p->index, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->index, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(src_p->value, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->value, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->value, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->value, 24u, 0xffu);

    return (6);
}

int can_mcu_vcu_param_tuning_general_unpack(
    struct can_mcu_vcu_param_tuning_general_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->index = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->index |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->value = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);

    return (0);
}

int can_mcu_vcu_param_tuning_general_init(struct can_mcu_vcu_param_tuning_general_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_param_tuning_general_t));

    return 0;
}

uint16_t can_mcu_vcu_param_tuning_general_index_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_param_tuning_general_index_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_param_tuning_general_index_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_vcu_param_tuning_general_value_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_vcu_param_tuning_general_value_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_param_tuning_general_value_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_vcu_param_tuning_control_pack(
    uint8_t *dst_p,
    const struct can_mcu_vcu_param_tuning_control_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u16(src_p->index, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->index, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(src_p->value, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->value, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->value, 16u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->value, 24u, 0xffu);

    return (6);
}

int can_mcu_vcu_param_tuning_control_unpack(
    struct can_mcu_vcu_param_tuning_control_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->index = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->index |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->value = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    dst_p->value |= unpack_left_shift_u32(src_p[5], 24u, 0xffu);

    return (0);
}

int can_mcu_vcu_param_tuning_control_init(struct can_mcu_vcu_param_tuning_control_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_vcu_param_tuning_control_t));

    return 0;
}

uint16_t can_mcu_vcu_param_tuning_control_index_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_vcu_param_tuning_control_index_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_param_tuning_control_index_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint32_t can_mcu_vcu_param_tuning_control_value_encode(double value)
{
    return (uint32_t)(value);
}

double can_mcu_vcu_param_tuning_control_value_decode(uint32_t value)
{
    return ((double)value);
}

bool can_mcu_vcu_param_tuning_control_value_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dash_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_adu_t *src_p,
    size_t size)
{
    uint16_t steering_16bit;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    steering_16bit = (uint16_t)src_p->steering_16bit;
    dst_p[0] |= pack_left_shift_u16(steering_16bit, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(steering_16bit, 8u, 0xffu);

    return (2);
}

int can_mcu_dash_adu_unpack(
    struct can_mcu_dash_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t steering_16bit;

    if (size < 2u) {
        return (-EINVAL);
    }

    steering_16bit = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    steering_16bit |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->steering_16bit = (int16_t)steering_16bit;

    return (0);
}

int can_mcu_dash_adu_init(struct can_mcu_dash_adu_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dash_adu_t));

    return 0;
}

int16_t can_mcu_dash_adu_steering_16bit_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_dash_adu_steering_16bit_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_dash_adu_steering_16bit_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_apps_raw_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_apps_raw_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->apps1_raw_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->apps1_raw_min, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->apps2_raw_min, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->apps2_raw_min, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->apps1_raw_max, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->apps1_raw_max, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->apps2_raw_max, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->apps2_raw_max, 8u, 0xffu);

    return (8);
}

int can_mcu_ecu_apps_raw_unpack(
    struct can_mcu_ecu_apps_raw_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->apps1_raw_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->apps1_raw_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->apps2_raw_min = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->apps2_raw_min |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->apps1_raw_max = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->apps1_raw_max |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->apps2_raw_max = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->apps2_raw_max |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int can_mcu_ecu_apps_raw_init(struct can_mcu_ecu_apps_raw_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ecu_apps_raw_t));

    return 0;
}

uint16_t can_mcu_ecu_apps_raw_apps1_raw_min_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_apps_raw_apps1_raw_min_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_apps_raw_apps1_raw_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_ecu_apps_raw_apps2_raw_min_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_apps_raw_apps2_raw_min_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_apps_raw_apps2_raw_min_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_ecu_apps_raw_apps1_raw_max_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_apps_raw_apps1_raw_max_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_apps_raw_apps1_raw_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_mcu_ecu_apps_raw_apps2_raw_max_encode(double value)
{
    return (uint16_t)(value);
}

double can_mcu_ecu_apps_raw_apps2_raw_max_decode(uint16_t value)
{
    return ((double)value);
}

bool can_mcu_ecu_apps_raw_apps2_raw_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_ecu_steering_calibrated_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_steering_calibrated_t *src_p,
    size_t size)
{
    uint32_t steering_wheel_angle_calibrated;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&steering_wheel_angle_calibrated, &src_p->steering_wheel_angle_calibrated, sizeof(steering_wheel_angle_calibrated));
    dst_p[0] |= pack_left_shift_u32(steering_wheel_angle_calibrated, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(steering_wheel_angle_calibrated, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(steering_wheel_angle_calibrated, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(steering_wheel_angle_calibrated, 24u, 0xffu);

    return (4);
}

int can_mcu_ecu_steering_calibrated_unpack(
    struct can_mcu_ecu_steering_calibrated_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t steering_wheel_angle_calibrated;

    if (size < 4u) {
        return (-EINVAL);
    }

    steering_wheel_angle_calibrated = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    steering_wheel_angle_calibrated |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    steering_wheel_angle_calibrated |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    steering_wheel_angle_calibrated |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->steering_wheel_angle_calibrated, &steering_wheel_angle_calibrated, sizeof(dst_p->steering_wheel_angle_calibrated));

    return (0);
}

int can_mcu_ecu_steering_calibrated_init(struct can_mcu_ecu_steering_calibrated_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_ecu_steering_calibrated_t));

    return 0;
}

float can_mcu_ecu_steering_calibrated_steering_wheel_angle_calibrated_encode(double value)
{
    return (float)(value);
}

double can_mcu_ecu_steering_calibrated_steering_wheel_angle_calibrated_decode(float value)
{
    return ((double)value);
}

bool can_mcu_ecu_steering_calibrated_steering_wheel_angle_calibrated_is_in_range(float value)
{
    (void)value;

    return (true);
}

int can_mcu_apu_estimation_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_estimation_t *src_p,
    size_t size)
{
    uint16_t vel_x_estimation;
    uint16_t vel_y_estimation;
    uint16_t yaw_rate_estimation;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    vel_x_estimation = (uint16_t)src_p->vel_x_estimation;
    dst_p[0] |= pack_left_shift_u16(vel_x_estimation, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(vel_x_estimation, 8u, 0xffu);
    vel_y_estimation = (uint16_t)src_p->vel_y_estimation;
    dst_p[2] |= pack_left_shift_u16(vel_y_estimation, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(vel_y_estimation, 8u, 0xffu);
    yaw_rate_estimation = (uint16_t)src_p->yaw_rate_estimation;
    dst_p[4] |= pack_left_shift_u16(yaw_rate_estimation, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(yaw_rate_estimation, 8u, 0xffu);

    return (6);
}

int can_mcu_apu_estimation_unpack(
    struct can_mcu_apu_estimation_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t vel_x_estimation;
    uint16_t vel_y_estimation;
    uint16_t yaw_rate_estimation;

    if (size < 6u) {
        return (-EINVAL);
    }

    vel_x_estimation = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    vel_x_estimation |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->vel_x_estimation = (int16_t)vel_x_estimation;
    vel_y_estimation = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    vel_y_estimation |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->vel_y_estimation = (int16_t)vel_y_estimation;
    yaw_rate_estimation = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    yaw_rate_estimation |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->yaw_rate_estimation = (int16_t)yaw_rate_estimation;

    return (0);
}

int can_mcu_apu_estimation_init(struct can_mcu_apu_estimation_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_apu_estimation_t));

    return 0;
}

int16_t can_mcu_apu_estimation_vel_x_estimation_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_apu_estimation_vel_x_estimation_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_estimation_vel_x_estimation_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_apu_estimation_vel_y_estimation_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_apu_estimation_vel_y_estimation_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_estimation_vel_y_estimation_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_apu_estimation_yaw_rate_estimation_encode(double value)
{
    return (int16_t)(value);
}

double can_mcu_apu_estimation_yaw_rate_estimation_decode(int16_t value)
{
    return ((double)value);
}

bool can_mcu_apu_estimation_yaw_rate_estimation_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dv_driving_dynamics_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_driving_dynamics_1_t *src_p,
    size_t size)
{
    uint8_t motor_moment_actual;
    uint8_t motor_moment_target;
    uint8_t steering_angle_actual;
    uint8_t steering_angle_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->speed_actual, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->speed_target, 0u, 0xffu);
    steering_angle_actual = (uint8_t)src_p->steering_angle_actual;
    dst_p[2] |= pack_left_shift_u8(steering_angle_actual, 0u, 0xffu);
    steering_angle_target = (uint8_t)src_p->steering_angle_target;
    dst_p[3] |= pack_left_shift_u8(steering_angle_target, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->brake_hydr_acrtual, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->brake_hydr_target, 0u, 0xffu);
    motor_moment_actual = (uint8_t)src_p->motor_moment_actual;
    dst_p[6] |= pack_left_shift_u8(motor_moment_actual, 0u, 0xffu);
    motor_moment_target = (uint8_t)src_p->motor_moment_target;
    dst_p[7] |= pack_left_shift_u8(motor_moment_target, 0u, 0xffu);

    return (8);
}

int can_mcu_dv_driving_dynamics_1_unpack(
    struct can_mcu_dv_driving_dynamics_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t motor_moment_actual;
    uint8_t motor_moment_target;
    uint8_t steering_angle_actual;
    uint8_t steering_angle_target;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->speed_actual = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->speed_target = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    steering_angle_actual = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->steering_angle_actual = (int8_t)steering_angle_actual;
    steering_angle_target = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->steering_angle_target = (int8_t)steering_angle_target;
    dst_p->brake_hydr_acrtual = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->brake_hydr_target = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    motor_moment_actual = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->motor_moment_actual = (int8_t)motor_moment_actual;
    motor_moment_target = unpack_right_shift_u8(src_p[7], 0u, 0xffu);
    dst_p->motor_moment_target = (int8_t)motor_moment_target;

    return (0);
}

int can_mcu_dv_driving_dynamics_1_init(struct can_mcu_dv_driving_dynamics_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dv_driving_dynamics_1_t));

    return 0;
}

uint8_t can_mcu_dv_driving_dynamics_1_speed_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_speed_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_speed_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dv_driving_dynamics_1_speed_target_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_speed_target_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_speed_target_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_dv_driving_dynamics_1_steering_angle_actual_encode(double value)
{
    return (int8_t)(value / 0.5);
}

double can_mcu_dv_driving_dynamics_1_steering_angle_actual_decode(int8_t value)
{
    return ((double)value * 0.5);
}

bool can_mcu_dv_driving_dynamics_1_steering_angle_actual_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_dv_driving_dynamics_1_steering_angle_target_encode(double value)
{
    return (int8_t)(value / 0.5);
}

double can_mcu_dv_driving_dynamics_1_steering_angle_target_decode(int8_t value)
{
    return ((double)value * 0.5);
}

bool can_mcu_dv_driving_dynamics_1_steering_angle_target_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_brake_hydr_acrtual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_mcu_dv_driving_dynamics_1_brake_hydr_target_encode(double value)
{
    return (uint8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_brake_hydr_target_decode(uint8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_brake_hydr_target_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_dv_driving_dynamics_1_motor_moment_actual_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_motor_moment_actual_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_motor_moment_actual_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t can_mcu_dv_driving_dynamics_1_motor_moment_target_encode(double value)
{
    return (int8_t)(value);
}

double can_mcu_dv_driving_dynamics_1_motor_moment_target_decode(int8_t value)
{
    return ((double)value);
}

bool can_mcu_dv_driving_dynamics_1_motor_moment_target_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_mcu_dv_driving_dynamics_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_dv_driving_dynamics_2_t *src_p,
    size_t size)
{
    uint16_t acceleration_lateral;
    uint16_t acceleration_longitudinal;
    uint16_t yaw_rate;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    acceleration_longitudinal = (uint16_t)src_p->acceleration_longitudinal;
    dst_p[0] |= pack_left_shift_u16(acceleration_longitudinal, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(acceleration_longitudinal, 8u, 0xffu);
    acceleration_lateral = (uint16_t)src_p->acceleration_lateral;
    dst_p[2] |= pack_left_shift_u16(acceleration_lateral, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(acceleration_lateral, 8u, 0xffu);
    yaw_rate = (uint16_t)src_p->yaw_rate;
    dst_p[4] |= pack_left_shift_u16(yaw_rate, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(yaw_rate, 8u, 0xffu);

    return (6);
}

int can_mcu_dv_driving_dynamics_2_unpack(
    struct can_mcu_dv_driving_dynamics_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t acceleration_lateral;
    uint16_t acceleration_longitudinal;
    uint16_t yaw_rate;

    if (size < 6u) {
        return (-EINVAL);
    }

    acceleration_longitudinal = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    acceleration_longitudinal |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->acceleration_longitudinal = (int16_t)acceleration_longitudinal;
    acceleration_lateral = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    acceleration_lateral |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->acceleration_lateral = (int16_t)acceleration_lateral;
    yaw_rate = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    yaw_rate |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->yaw_rate = (int16_t)yaw_rate;

    return (0);
}

int can_mcu_dv_driving_dynamics_2_init(struct can_mcu_dv_driving_dynamics_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_mcu_dv_driving_dynamics_2_t));

    return 0;
}

int16_t can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_encode(double value)
{
    return (int16_t)(value / 0.00195313);
}

double can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_decode(int16_t value)
{
    return ((double)value * 0.00195313);
}

bool can_mcu_dv_driving_dynamics_2_acceleration_longitudinal_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_dv_driving_dynamics_2_acceleration_lateral_encode(double value)
{
    return (int16_t)(value / 0.00195313);
}

double can_mcu_dv_driving_dynamics_2_acceleration_lateral_decode(int16_t value)
{
    return ((double)value * 0.00195313);
}

bool can_mcu_dv_driving_dynamics_2_acceleration_lateral_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_mcu_dv_driving_dynamics_2_yaw_rate_encode(double value)
{
    return (int16_t)(value / 0.0078125);
}

double can_mcu_dv_driving_dynamics_2_yaw_rate_decode(int16_t value)
{
    return ((double)value * 0.0078125);
}

bool can_mcu_dv_driving_dynamics_2_yaw_rate_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}
