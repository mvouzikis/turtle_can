/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 37.0.5 Wed Jun 15 01:34:08 2022.
 */

#ifndef CAN_MCU_H
#define CAN_MCU_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_MCU_AUX_SUSP_R_FRAME_ID (0x1a0u)
#define CAN_MCU_DASH_APPS_BRAKE_FRAME_ID (0x64u)
#define CAN_MCU_DASH_HALL_F_FRAME_ID (0x15eu)
#define CAN_MCU_ECU_BOOLS_FRAME_ID (0x73u)
#define CAN_MCU_DASH_STEERING_FRAME_ID (0x190u)
#define CAN_MCU_DASH_BOOLS_FRAME_ID (0x131u)
#define CAN_MCU_DASH_SUSP_F_FRAME_ID (0x1e0u)
#define CAN_MCU_ECU_ADU_FRAME_ID (0x258u)
#define CAN_MCU_AUX_STATES_FRAME_ID (0x145u)
#define CAN_MCU_AUX_IR_CAMS_R1_FRAME_ID (0x5dcu)
#define CAN_MCU_AUX_IR_CAMS_R2_FRAME_ID (0x5ddu)
#define CAN_MCU_AUX_IR_CAMS_L1_FRAME_ID (0x5deu)
#define CAN_MCU_AUX_IR_CAMS_L2_FRAME_ID (0x5dfu)
#define CAN_MCU_ADU_INVERTER_LEFT_FRAME_ID (0x2bcu)
#define CAN_MCU_ADU_INVERTER_RIGHT_FRAME_ID (0x320u)
#define CAN_MCU_AUX_CABLES_FRAME_ID (0x1f4u)
#define CAN_MCU_ASB_FRAME_ID (0x23u)
#define CAN_MCU_APU_COMMAND_FRAME_ID (0x14u)
#define CAN_MCU_APU_STATE_MISSION_FRAME_ID (0x0au)
#define CAN_MCU_AMI_FRAME_ID (0x0du)
#define CAN_MCU_ISABELLEN_IDC_FRAME_ID (0x521u)
#define CAN_MCU_ISABELLEN_VDC_FRAME_ID (0x522u)
#define CAN_MCU_ISABELLEN_PDC_FRAME_ID (0x526u)
#define CAN_MCU_ISABELLEN_ENERGY_FRAME_ID (0x528u)
#define CAN_MCU_BLDC_TX_1_FRAME_ID (0x200u)
#define CAN_MCU_BLDC_RX_1_FRAME_ID (0x27fu)
#define CAN_MCU_BLDC_RX_2_FRAME_ID (0x37fu)
#define CAN_MCU_BLDC_TX_2_FRAME_ID (0x2ffu)
#define CAN_MCU_BLDC_TX_3_FRAME_ID (0x3ffu)
#define CAN_MCU_BLDC_RX_3_FRAME_ID (0x47fu)
#define CAN_MCU_BLDC_TX_4_FRAME_ID (0x4ffu)
#define CAN_MCU_BLDC_RX_4_FRAME_ID (0x57fu)
#define CAN_MCU_STEERING_COMMAND_FRAME_ID (0x1eu)
#define CAN_MCU_INVERTER_RIGHT_INFO_FRAME_ID (0x2beu)
#define CAN_MCU_COOLING_FRAME_ID (0x2eeu)
#define CAN_MCU_INVERTER_LEFT_INFO_FRAME_ID (0x2c6u)
#define CAN_MCU_ECU_PARAMETERS_FRAME_ID (0x311u)
#define CAN_MCU_ECU_PARAMETERS_ACTUAL_FRAME_ID (0x31bu)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_FRAME_ID (0x640u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_FRAME_ID (0x641u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_FRAME_ID (0x642u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_FRAME_ID (0x643u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_FRAME_ID (0x644u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_FRAME_ID (0x645u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_FRAME_ID (0x646u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_FRAME_ID (0x647u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_FRAME_ID (0x648u)
#define CAN_MCU_APU_TEMPS_FRAME_ID (0x5aau)

/* Frame lengths in bytes. */
#define CAN_MCU_AUX_SUSP_R_LENGTH (8u)
#define CAN_MCU_DASH_APPS_BRAKE_LENGTH (7u)
#define CAN_MCU_DASH_HALL_F_LENGTH (4u)
#define CAN_MCU_ECU_BOOLS_LENGTH (2u)
#define CAN_MCU_DASH_STEERING_LENGTH (4u)
#define CAN_MCU_DASH_BOOLS_LENGTH (6u)
#define CAN_MCU_DASH_SUSP_F_LENGTH (8u)
#define CAN_MCU_ECU_ADU_LENGTH (6u)
#define CAN_MCU_AUX_STATES_LENGTH (6u)
#define CAN_MCU_AUX_IR_CAMS_R1_LENGTH (8u)
#define CAN_MCU_AUX_IR_CAMS_R2_LENGTH (8u)
#define CAN_MCU_AUX_IR_CAMS_L1_LENGTH (8u)
#define CAN_MCU_AUX_IR_CAMS_L2_LENGTH (8u)
#define CAN_MCU_ADU_INVERTER_LEFT_LENGTH (8u)
#define CAN_MCU_ADU_INVERTER_RIGHT_LENGTH (8u)
#define CAN_MCU_AUX_CABLES_LENGTH (4u)
#define CAN_MCU_ASB_LENGTH (8u)
#define CAN_MCU_APU_COMMAND_LENGTH (4u)
#define CAN_MCU_APU_STATE_MISSION_LENGTH (2u)
#define CAN_MCU_AMI_LENGTH (1u)
#define CAN_MCU_ISABELLEN_IDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_VDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_PDC_LENGTH (6u)
#define CAN_MCU_ISABELLEN_ENERGY_LENGTH (6u)
#define CAN_MCU_BLDC_TX_1_LENGTH (3u)
#define CAN_MCU_BLDC_RX_1_LENGTH (7u)
#define CAN_MCU_BLDC_RX_2_LENGTH (8u)
#define CAN_MCU_BLDC_TX_2_LENGTH (4u)
#define CAN_MCU_BLDC_TX_3_LENGTH (2u)
#define CAN_MCU_BLDC_RX_3_LENGTH (2u)
#define CAN_MCU_BLDC_TX_4_LENGTH (4u)
#define CAN_MCU_BLDC_RX_4_LENGTH (4u)
#define CAN_MCU_STEERING_COMMAND_LENGTH (8u)
#define CAN_MCU_INVERTER_RIGHT_INFO_LENGTH (8u)
#define CAN_MCU_COOLING_LENGTH (8u)
#define CAN_MCU_INVERTER_LEFT_INFO_LENGTH (8u)
#define CAN_MCU_ECU_PARAMETERS_LENGTH (8u)
#define CAN_MCU_ECU_PARAMETERS_ACTUAL_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_LENGTH (8u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_LENGTH (8u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_LENGTH (8u)
#define CAN_MCU_APU_TEMPS_LENGTH (4u)

/* Extended or standard frame types. */
#define CAN_MCU_AUX_SUSP_R_IS_EXTENDED (0)
#define CAN_MCU_DASH_APPS_BRAKE_IS_EXTENDED (0)
#define CAN_MCU_DASH_HALL_F_IS_EXTENDED (0)
#define CAN_MCU_ECU_BOOLS_IS_EXTENDED (0)
#define CAN_MCU_DASH_STEERING_IS_EXTENDED (0)
#define CAN_MCU_DASH_BOOLS_IS_EXTENDED (0)
#define CAN_MCU_DASH_SUSP_F_IS_EXTENDED (0)
#define CAN_MCU_ECU_ADU_IS_EXTENDED (0)
#define CAN_MCU_AUX_STATES_IS_EXTENDED (0)
#define CAN_MCU_AUX_IR_CAMS_R1_IS_EXTENDED (0)
#define CAN_MCU_AUX_IR_CAMS_R2_IS_EXTENDED (0)
#define CAN_MCU_AUX_IR_CAMS_L1_IS_EXTENDED (0)
#define CAN_MCU_AUX_IR_CAMS_L2_IS_EXTENDED (0)
#define CAN_MCU_ADU_INVERTER_LEFT_IS_EXTENDED (0)
#define CAN_MCU_ADU_INVERTER_RIGHT_IS_EXTENDED (0)
#define CAN_MCU_AUX_CABLES_IS_EXTENDED (0)
#define CAN_MCU_ASB_IS_EXTENDED (0)
#define CAN_MCU_APU_COMMAND_IS_EXTENDED (0)
#define CAN_MCU_APU_STATE_MISSION_IS_EXTENDED (0)
#define CAN_MCU_AMI_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_IDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_VDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_PDC_IS_EXTENDED (0)
#define CAN_MCU_ISABELLEN_ENERGY_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_1_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_1_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_2_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_2_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_3_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_3_IS_EXTENDED (0)
#define CAN_MCU_BLDC_TX_4_IS_EXTENDED (0)
#define CAN_MCU_BLDC_RX_4_IS_EXTENDED (0)
#define CAN_MCU_STEERING_COMMAND_IS_EXTENDED (0)
#define CAN_MCU_INVERTER_RIGHT_INFO_IS_EXTENDED (0)
#define CAN_MCU_COOLING_IS_EXTENDED (0)
#define CAN_MCU_INVERTER_LEFT_INFO_IS_EXTENDED (0)
#define CAN_MCU_ECU_PARAMETERS_IS_EXTENDED (0)
#define CAN_MCU_ECU_PARAMETERS_ACTUAL_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_IS_EXTENDED (0)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_IS_EXTENDED (0)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_IS_EXTENDED (0)
#define CAN_MCU_APU_TEMPS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define CAN_MCU_AUX_SUSP_R_CYCLE_TIME_MS (10u)
#define CAN_MCU_DASH_APPS_BRAKE_CYCLE_TIME_MS (2u)
#define CAN_MCU_DASH_HALL_F_CYCLE_TIME_MS (10u)
#define CAN_MCU_ECU_BOOLS_CYCLE_TIME_MS (100u)
#define CAN_MCU_DASH_STEERING_CYCLE_TIME_MS (10u)
#define CAN_MCU_DASH_BOOLS_CYCLE_TIME_MS (100u)
#define CAN_MCU_DASH_SUSP_F_CYCLE_TIME_MS (10u)
#define CAN_MCU_ECU_ADU_CYCLE_TIME_MS (100u)
#define CAN_MCU_AUX_STATES_CYCLE_TIME_MS (10u)
#define CAN_MCU_AUX_IR_CAMS_R1_CYCLE_TIME_MS (50u)
#define CAN_MCU_AUX_IR_CAMS_R2_CYCLE_TIME_MS (50u)
#define CAN_MCU_AUX_IR_CAMS_L1_CYCLE_TIME_MS (50u)
#define CAN_MCU_AUX_IR_CAMS_L2_CYCLE_TIME_MS (50u)
#define CAN_MCU_ADU_INVERTER_LEFT_CYCLE_TIME_MS (100u)
#define CAN_MCU_ADU_INVERTER_RIGHT_CYCLE_TIME_MS (100u)
#define CAN_MCU_AUX_CABLES_CYCLE_TIME_MS (10u)
#define CAN_MCU_ASB_CYCLE_TIME_MS (50u)
#define CAN_MCU_APU_COMMAND_CYCLE_TIME_MS (20u)
#define CAN_MCU_APU_STATE_MISSION_CYCLE_TIME_MS (125u)
#define CAN_MCU_ECU_PARAMETERS_CYCLE_TIME_MS (100u)
#define CAN_MCU_ECU_PARAMETERS_ACTUAL_CYCLE_TIME_MS (10u)
#define CAN_MCU_BMS_MIN_MAX_S1_S2_CYCLE_TIME_MS (50u)
#define CAN_MCU_BMS_MIN_MAX_S3_S4_CYCLE_TIME_MS (50u)
#define CAN_MCU_BMS_MIN_MAX_S5_S6_CYCLE_TIME_MS (50u)
#define CAN_MCU_BMS_MIN_MAX_S7_S8_CYCLE_TIME_MS (50u)
#define CAN_MCU_BMS_MIN_MAX_S9_S10_CYCLE_TIME_MS (50u)
#define CAN_MCU_BMS_MIN_MAX_S11_S12_CYCLE_TIME_MS (50u)
#define CAN_MCU_BMS_MAX_TEMP_S1_S4_CYCLE_TIME_MS (50u)
#define CAN_MCU_BMS_MAX_TEMP_S5_S8_CYCLE_TIME_MS (50u)
#define CAN_MCU_BMS_MAX_TEMP_S9_S12_CYCLE_TIME_MS (50u)

/* Signal choices. */
#define CAN_MCU_DASH_APPS_BRAKE_APPS1_RAW_LOWER_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_APPS1_RAW_HIGHER_CHOICE (4095u)

#define CAN_MCU_DASH_APPS_BRAKE_APPS2_RAW_LOWER_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_APPS2_RAW_HIGHER_CHOICE (4095u)

#define CAN_MCU_DASH_APPS_BRAKE_BRAKE_PRESSURE_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_BRAKE_PRESSURE_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_BRAKE_APPS_SC_GND_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_APPS_SC_GND_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_BRAKE_APPS_SC_SUP_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_APPS_SC_SUP_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_BRAKE_APPS_SC_SIGNALS_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_APPS_SC_SIGNALS_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_BRAKE_APPS_OUT_OF_RANGE_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_APPS_OUT_OF_RANGE_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_BRAKE_BRAKE_SC_GND_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_BRAKE_SC_GND_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_BRAKE_BRAKE_SC_SUP_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_BRAKE_SC_SUP_ERROR_CHOICE (1u)

#define CAN_MCU_DASH_APPS_BRAKE_BRAKE_OUT_OF_RANGE_OK_CHOICE (0u)
#define CAN_MCU_DASH_APPS_BRAKE_BRAKE_OUT_OF_RANGE_ERROR_CHOICE (1u)

#define CAN_MCU_ECU_BOOLS_BRAKELIGHT_DISABLE_CHOICE (0u)
#define CAN_MCU_ECU_BOOLS_BRAKELIGHT_ENABLE_CHOICE (1u)

#define CAN_MCU_ECU_BOOLS_SERVO_COMMANDED_DE_ACTIVATED_CHOICE (0u)
#define CAN_MCU_ECU_BOOLS_SERVO_COMMANDED_ACTIVATED_CHOICE (1u)

#define CAN_MCU_ECU_BOOLS_RADIATOR_FANS_LEFT_DISABLE_CHOICE (0u)
#define CAN_MCU_ECU_BOOLS_RADIATOR_FANS_LEFT_ENABLE_CHOICE (1u)

#define CAN_MCU_ECU_BOOLS_RADIATOR_FANS_RIGHT_DISABLE_CHOICE (0u)
#define CAN_MCU_ECU_BOOLS_RADIATOR_FANS_RIGHT_ENABLE_CHOICE (1u)

#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_REGEN_CHOICE (1u)
#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_TRACTION_CONTROL_CHOICE (2u)
#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_DIFFERENTIAL_CHOICE (3u)
#define CAN_MCU_DASH_BOOLS_ROTARY_ACTIVE_MODE_MENU_CHOICE (4u)

#define CAN_MCU_DASH_BOOLS_COOLING_STATUS_COOLING_DISABLE_CHOICE (0u)
#define CAN_MCU_DASH_BOOLS_COOLING_STATUS_COOLING_ENABLE_CHOICE (1u)

#define CAN_MCU_AUX_STATES_GREEN_TSAL_DISABLE_CHOICE (0u)
#define CAN_MCU_AUX_STATES_GREEN_TSAL_ENABLE_CHOICE (1u)

#define CAN_MCU_AUX_STATES_SAFE_STATE_DISABLE_CHOICE (0u)
#define CAN_MCU_AUX_STATES_SAFE_STATE_ENABLE_CHOICE (1u)

#define CAN_MCU_AUX_STATES_TS_OFF_DISABLE_CHOICE (0u)
#define CAN_MCU_AUX_STATES_TS_OFF_ENABLE_CHOICE (1u)

#define CAN_MCU_ASB_ASMS_STATE_ASMS_OPENED_CHOICE (0u)
#define CAN_MCU_ASB_ASMS_STATE_ASMS_CLOSED_CHOICE (1u)

#define CAN_MCU_ASB_TSMS_OUT_TSMS_OPENED_CHOICE (0u)
#define CAN_MCU_ASB_TSMS_OUT_TSMS_CLOSED_CHOICE (1u)

#define CAN_MCU_ASB_ASB_LED_ASB_LED_OFF_CHOICE (0u)
#define CAN_MCU_ASB_ASB_LED_ASB_LED_ON_CHOICE (1u)

#define CAN_MCU_ASB_INITIAL_CHECKED_INITIAL_CHECK_FAILED_CHOICE (0u)
#define CAN_MCU_ASB_INITIAL_CHECKED_INITIAL_CHECK_SUCCESSFUL_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_TANK_PRESSURE_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_TANK_PRESSURE_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_BRAKE_PRESSURE_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_BRAKE_PRESSURE_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_SERVO_CHECK_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_SERVO_CHECK_OK_CHOICE (1u)

#define CAN_MCU_ASB_MONITOR_APU_ERROR_CHOICE (0u)
#define CAN_MCU_ASB_MONITOR_APU_OK_CHOICE (1u)

#define CAN_MCU_ASB_INITIAL_CHECK_STEP_NOT_IN_INITIAL_CHECK_CHOICE (-1)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CLOSE_RES_RELAIS_AND_SDC_BEFORE_AS_RELAY_CHOICE (0)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_DISABLE_WATCHDOG_CHOICE (1)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_RE_ENABLE_WATCHDOG_CHOICE (2)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_TANK___BRAKE_PRESSURE_CHOICE (3)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CLOSE_SDC_CHOICE (4)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_EBS_ARMING_CHOICE (5)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_DE_ENERGIZE_EBS_ELECTRIC_VALVE_CHOICE (6)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_SERVICE_BRAKE_CHOICE (7)
#define CAN_MCU_ASB_INITIAL_CHECK_STEP_CHECK_COMMUNICATION_WITH_APU_CHOICE (8)

#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_DISENGAGED_CHOICE (1u)
#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_ENGAGED_CHOICE (2u)
#define CAN_MCU_ASB_SERVICE_BRAKE_STATUS_AVAILABLE_CHOICE (3u)

#define CAN_MCU_ASB_ASB_STATUS_UNAVAILABLE_CHOICE (1u)
#define CAN_MCU_ASB_ASB_STATUS_ARMED_CHOICE (2u)
#define CAN_MCU_ASB_ASB_STATUS_TRIGGERED_CHOICE (3u)

#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_ERROR_MISSION_CHOICE (-1)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_NO_MISSION_CHOICE (0)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_ACCELERATION_CHOICE (1)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_SKIDPAD_CHOICE (2)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_AUTOCROSS_CHOICE (3)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_TRACKDRIVE_CHOICE (4)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_EBSTEST_CHOICE (5)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_INSPECTION_CHOICE (6)
#define CAN_MCU_APU_STATE_MISSION_AS_MISSION_MANUAL_DRIVING_CHOICE (7)

#define CAN_MCU_APU_STATE_MISSION_AS_STATE_MANUAL_DRIVING_CHOICE (0u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_OFF_CHOICE (1u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_READY_CHOICE (2u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_DRIVING_CHOICE (3u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_FINISHED_CHOICE (4u)
#define CAN_MCU_APU_STATE_MISSION_AS_STATE_AS_EMERGENCY_CHOICE (5u)

#define CAN_MCU_AMI_AMI_MANUAL__MISSION_CHOICE (1u)
#define CAN_MCU_AMI_AMI_ACCELERATION__CHOICE (2u)
#define CAN_MCU_AMI_AMI_AUTOCROSS_CHOICE (3u)
#define CAN_MCU_AMI_AMI_SKIDPAD_CHOICE (4u)
#define CAN_MCU_AMI_AMI_TRACKDRIVE_CHOICE (5u)
#define CAN_MCU_AMI_AMI_EBS_TEST_CHOICE (6u)
#define CAN_MCU_AMI_AMI_INSPECTION__MISSION__CHOICE (7u)

#define CAN_MCU_STEERING_COMMAND_STEERING_MODE_CYCLIC_SYCHRONOUS_POSITION_MODE_CHOICE (8u)
#define CAN_MCU_STEERING_COMMAND_STEERING_MODE_CYCLIC_SYCHRONOUS_VELOCITY_MODE_CHOICE (9u)

/**
 * Signals in message AUX_SUSP_R.
 *
 * The measurements for rear suspension

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_susp_r_t {
    /**
     * Suspension Potentiometers Rear Left
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_rl;

    /**
     * Suspension Potentiometers Rear Right
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_pot_rr;

    /**
     * Suspension Strain Gauges Rear Left
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_sg_rl;

    /**
     * Suspension Strain Gauges Rear Right
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_sg_rr;
};

/**
 * Signals in message DASH_APPS_BRAKE.
 *
 * APPS Raw Values & SCS states, Brake Pressure & SCS states
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_apps_brake_t {
    /**
     * analog value of APPS1
     *
     * Range: 0..1 (0..1 ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps1_raw;

    /**
     * analog value of APPS2
     * 
     *
     * Range: 0..1 (0..1 ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps2_raw;

    /**
     * brake pressure measured in bars
     *
     * Range: 0..2000000 (0..20000 bar)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t brake_pressure;

    /**
     * checks if any of the APPS signal is short circuited to GND
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_gnd;

    /**
     * checks if any of the APPS signal is short circuited to supply
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_sup;

    /**
     * checks if APPSs's signals are short circuited
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_sc_signals;

    /**
     * checks if any of APPSs' signals is out of range
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_out_of_range;

    /**
     * checks if brake signal is short circuited to GND
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_sc_gnd;

    /**
     * checks if brake signal is short circuited to supply
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_sc_sup;

    /**
     * checks if brake signal is out of range
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_out_of_range;
};

/**
 * Signals in message DASH_HALL_F.
 *
 * Front Hall Effect Sensors
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_hall_f_t {
    /**
     * front and left speed in rpm
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t hall_fl;

    /**
     * front and right speed in rpm
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t hall_fr;
};

/**
 * Signals in message ECU_BOOLS.
 *
 * LEDs to Dashboard and bools from ECU to ASB and AUX
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_bools_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t buzzer;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sensor_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brakelight;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ams;

    /**
     * Boolean that activates the Service Brake if commanded from ECU
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_commanded;

    /**
     * Boolean sent to AUX to re-activate the LEFT radiator fans if they are not working.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t radiator_fans_left;

    /**
     * Boolean sent to AUX to re-activate the RIGHT radiator fans if they are not working.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t radiator_fans_right;
};

/**
 * Signals in message DASH_STEERING.
 *
 * Steering Sensor
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_steering_t {
    /**
     * steering wheel's angle
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float steering;
};

/**
 * Signals in message DASH_BOOLS.
 *
 * Dashboard buttons and toggle switches
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_bools_t {
    /**
     * status of the Ad_act button
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ad_act;

    /**
     * toggle button
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_request;

    /**
     * status of start button
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t start;

    /**
     * the state of the shutdown before the cockpit
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_state;

    /**
     * checks if there is an implausibility in steering compute of angle
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_implausibility;

    /**
     * status of plus button
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t plus_button;

    /**
     * status of minus button
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t minus_button;

    /**
     * status of enter button
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enter_button;

    /**
     * value of traction control
     * 
     *
     * Range: 0..15 (0..15 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t traction_control_mode;

    /**
     * value of differential mode
     * 
     * 
     *
     * Range: 0..15 (0..15 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t differential_mode;

    /**
     * value of Regen_mode
     *
     * Range: 0..15 (0..15 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_mode;

    /**
     * the position of the rotary switch
     *
     * Range: 0..15 (0..15 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_active_mode;

    /**
     * which driver it is
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t driver;

    /**
     * which place is chosen
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t place;

    /**
     * the current place at the secont column of the menu
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t menu;

    /**
     * default place
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t default_screen;

    /**
     * monitor place
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor;

    /**
     * cooling enable
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cooling_status;

    /**
     * status of cooling button
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cooling_button;
};

/**
 * Signals in message DASH_SUSP_F.
 *
 * Front Suspension Strain Gauges
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_dash_susp_f_t {
    /**
     * front and left suspension potentiometer
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_fl;

    /**
     * front and right suspension potentiometer
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t susp_fr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t strai_gauge_fr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t strain_gauge_fl;
};

/**
 * Signals in message ECU_ADU.
 *
 * Signals for use by the ADU
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_adu_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t power_k_w;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pl_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t differential_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t vicor_thermistor;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t recom_thermistor;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t velocity;
};

/**
 * Signals in message AUX_STATES.
 *
 * Aux uController States
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_states_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t green_tsal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t safe_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off;

    /**
     * 0...4095
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_link_voltage;
};

/**
 * Signals in message AUX_IR_CAMS_R1.
 *
 * IR Cameras - Rear Right Wheel - Zones 1-4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_ir_cams_r1_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr1;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr2;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr3;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr4;
};

/**
 * Signals in message AUX_IR_CAMS_R2.
 *
 * IR Cameras - Rear Right Wheel - Zones 5-8
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_ir_cams_r2_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr5;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr6;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr7;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rr8;
};

/**
 * Signals in message AUX_IR_CAMS_L1.
 *
 * IR Cameras - Rear Left Wheel - Zones 1-4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_ir_cams_l1_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl1;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl2;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl3;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl4;
};

/**
 * Signals in message AUX_IR_CAMS_L2.
 *
 * IR Cameras - Rear Left Wheel - Zones 5-8
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_ir_cams_l2_t {
    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl5;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl6;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl7;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t zone_rl8;
};

/**
 * Signals in message ADU_INVERTER_LEFT.
 *
 * values from the left inverter for the ADU

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_adu_inverter_left_t {
    /**
     * Range: -
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t igbt_l;

    /**
     * Range: -
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t motor_l;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rpm_l;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t torque_l;

    /**
     * Integer part of the DC Current
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t idc_integer;

    /**
     * Fractional part of the DC current
     *
     * Range: 0..198 (0..99 -)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ac_temparature;
};

/**
 * Signals in message ADU_INVERTER_RIGHT.
 *
 * values from the right inverter for the ADU

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_adu_inverter_right_t {
    /**
     * Range: -
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t igbt_r;

    /**
     * Range: -
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t motor_r;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rpm_r;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t torque_r;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t isa_vdc;
};

/**
 * Signals in message AUX_CABLES.
 *
 * Temperature measurements for HV cables

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_aux_cables_t {
    /**
     * Thermistor in DC HV cables
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t hv_cable1;

    /**
     * Thermistor in AC HV cables
     *
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t hv_cable2;
};

/**
 * Signals in message ASB.
 *
 * ASB signals

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_asb_t {
    /**
     * It's the actual state of TSMS
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asms_state;

    /**
     * It's the actual state of TSMS
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsms_out;

    /**
     * For visible check in startup or when EBS is activated
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb_led;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t initial_checked;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_tank_pressure;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_brake_pressure;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_servo_check;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t monitor_apu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t initial_check_step;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asb_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ebs_tank_pressure;
};

/**
 * Signals in message APU_COMMAND.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_command_t {
    /**
     * Throttle/Brake command [-1,1]
     *
     * Range: -1..1 (-1..1 -)
     * Scale: 1
     * Offset: 0
     */
    float throttle_brake_commanded;
};

/**
 * Signals in message APU_STATE_MISSION.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_state_mission_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t as_mission;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;
};

/**
 * Signals in message AMI.
 *
 * Autonomous Mission Indicator 
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ami_t {
    /**
     * Autonomous Mission Indicator
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami;
};

/**
 * Signals in message Isabellen_Idc.
 *
 * 


 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_idc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t idc_measurement_error;

    /**
     * Range: -
     * Scale: 7
     * Offset: 0
     */
    uint8_t system_error;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int32_t idc;
};

/**
 * Signals in message Isabellen_Vdc.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_vdc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t vdc_measurement_error;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int32_t vdc;
};

/**
 * Signals in message Isabellen_Pdc.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_pdc_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pdc_measurement_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pdc;
};

/**
 * Signals in message Isabellen_Energy.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_isabellen_energy_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t energy_measurent_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t energy;
};

/**
 * Signals in message BLDC_TX_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t status_word;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t modes_of_operation_display;
};

/**
 * Signals in message BLDC_RX_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t controlword;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode_of_operation;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_drive_submode_select;
};

/**
 * Signals in message BLDC_RX_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t target_position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t profile_velocity;
};

/**
 * Signals in message BLDC_TX_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position_actual_value;
};

/**
 * Signals in message BLDC_TX_3.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t velocity_actual_value;
};

/**
 * Signals in message BLDC_RX_3.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t target_velocity;
};

/**
 * Signals in message BLDC_TX_4.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_tx_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t digital_input;
};

/**
 * Signals in message BLDC_RX_4.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bldc_rx_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t digital_output;
};

/**
 * Signals in message Steering_command.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_steering_command_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t position_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t velocity_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_mode;
};

/**
 * Signals in message Inverter_Right_Info.
 *
 * values for the inverts nessecary for Telemtry
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_inverter_right_info_t {
    /**
     * The max Irms that is set for the right inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t irms_max_right;

    /**
     * The current limit that the right inverter sets at a specific time
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t i_lim_in_use_right;

    /**
     * the actual current at the moment of the right inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t irm_right;

    /**
     * The rpm threshold that we set for the right inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t max_rpm_right;
};

/**
 * Signals in message Cooling.
 *
 * The commands for the pump and fans.

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_cooling_t {
    /**
     * command of pump
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pump_signal;

    /**
     * command of tsac fans
     * 
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsac_fans;

    /**
     * command of tsac hall's fans
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t hall_fans;

    /**
     * command of chassis fans
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t chassis_fans;

    /**
     * command of radiators' fans
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t radiator_fanss;
};

/**
 * Signals in message Inverter_Left_Info.
 *
 * values for the inverts nessecary for Telemtry
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_inverter_left_info_t {
    /**
     * The current limit that the left inverter sets at a specific time
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t irms_max_left;

    /**
     * the actual current at the moment of the left inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t i_lim_in_use_left;

    /**
     * The max Irms that is set for the left inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t irm_left;

    /**
     * The rpm threshold that we set for the left inverter
     *
     * Range: -
     * Scale: 100
     * Offset: 0
     */
    uint16_t max_rpm_left;
};

/**
 * Signals in message ECU_PARAMETERS.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_parameters_t {
    /**
     * A percentage of 7000 RPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_rpm_percentage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_i_max;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_start_speed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_min_speed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_enable;
};

/**
 * Signals in message ECU_PARAMETERS_ACTUAL.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_ecu_parameters_actual_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_rpm_max_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_i_max_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_target_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_start_speed_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regen_min_speed_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ed_enable_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_enable_actual;
};

/**
 * Signals in message BMS_MIN_MAX_S1_S2.
 *
 * Min Max Voltages for Segment 1,2
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s1_s2_t {
    /**
     * Segment 1 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s1_min;

    /**
     * Segment 1 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s1_max;

    /**
     * Segment 2 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s2_min;

    /**
     * Segment 2 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s2_max;
};

/**
 * Signals in message BMS_MIN_MAX_S3_S4.
 *
 * Min Max Voltages for Segment 3,4

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s3_s4_t {
    /**
     * Segment 3 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s3_min;

    /**
     * Segment 3 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s3_max;

    /**
     * Segment 4 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s4_min;

    /**
     * Segment 4 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s4_max;
};

/**
 * Signals in message BMS_MIN_MAX_S5_S6.
 *
 * Min Max Voltages for Segment 5,6

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s5_s6_t {
    /**
     * Segment 5 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s5_min;

    /**
     * Segment 5 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s5_max;

    /**
     * Segment 6 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s6_min;

    /**
     * Segment 6 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s6_max;
};

/**
 * Signals in message BMS_MIN_MAX_S7_S8.
 *
 * Min Max Voltages for Segment 7,8

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s7_s8_t {
    /**
     * Segment 7 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s7_min;

    /**
     * Segment 7 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s7_max;

    /**
     * Segment 8 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s8_min;

    /**
     * Segment 8 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s8_max;
};

/**
 * Signals in message BMS_MIN_MAX_S9_S10.
 *
 * Min Max Voltages for Segment 9,10

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s9_s10_t {
    /**
     * Segment 9 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s9_min;

    /**
     * Segment 9 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s9_max;

    /**
     * Segment 10 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s10_min;

    /**
     * Segment 10 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s10_max;
};

/**
 * Signals in message BMS_MIN_MAX_S11_S12.
 *
 * Min Max Voltages for Segment 11,12

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_min_max_s11_s12_t {
    /**
     * Segment 11 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s11_min;

    /**
     * Segment 11 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s11_max;

    /**
     * Segment 12 Min Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s12_min;

    /**
     * Segment 12 Max Voltage
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s12_max;
};

/**
 * Signals in message BMS_Max_Temp_S1_S4.
 *
 * Max Temperature for Segments 1,2,3,4
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s1_s4_t {
    /**
     * Segment 1 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s1_max_temp;

    /**
     * Segment 2 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s2_max_temp;

    /**
     * Segment 3 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s3_max_temp;

    /**
     * Segment 4 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s4_max_temp;
};

/**
 * Signals in message BMS_Max_Temp_S5_S8.
 *
 * Max Temperature for Segments 5,6,7,8

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s5_s8_t {
    /**
     * Segment 5 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s5_max_temp;

    /**
     * Segment 6 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s6_max_temp;

    /**
     * Segment 7 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s7_max_temp;

    /**
     * Segment 8 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s8_max_temp;
};

/**
 * Signals in message BMS_Max_Temp_S9_S12.
 *
 * Max Temperature for Segments 9,10,11,12

 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_bms_max_temp_s9_s12_t {
    /**
     * Segment 9 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s9_max_temp;

    /**
     * Segment 10 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s10_max_temp;

    /**
     * Segment 11 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint16_t s11_max_temp;

    /**
     * Segment 12 Max Temperature
     *
     * Range: -
     * Scale: 10000
     * Offset: 0
     */
    uint8_t s12_max_temp;
};

/**
 * Signals in message APU_Temps.
 *
 * All signal values are as on the CAN bus.
 */
struct can_mcu_apu_temps_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t cpu_temp;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t gpu_temp;
};

/**
 * Pack message AUX_SUSP_R.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_susp_r_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_susp_r_t *src_p,
    size_t size);

/**
 * Unpack message AUX_SUSP_R.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_susp_r_unpack(
    struct can_mcu_aux_susp_r_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_susp_r_susp_pot_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_susp_r_susp_pot_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_susp_r_susp_pot_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_susp_r_susp_pot_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_susp_r_susp_pot_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_susp_r_susp_pot_rr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_susp_r_susp_sg_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_susp_r_susp_sg_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_susp_r_susp_sg_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_susp_r_susp_sg_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_susp_r_susp_sg_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_susp_r_susp_sg_rr_is_in_range(uint16_t value);

/**
 * Pack message DASH_APPS_BRAKE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_apps_brake_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_apps_brake_t *src_p,
    size_t size);

/**
 * Unpack message DASH_APPS_BRAKE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_apps_brake_unpack(
    struct can_mcu_dash_apps_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_apps_brake_apps1_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_apps1_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_apps1_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_apps_brake_apps2_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_apps2_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_apps2_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_apps_brake_brake_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_brake_pressure_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_brake_pressure_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_brake_apps_sc_gnd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_apps_sc_gnd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_apps_sc_gnd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_brake_apps_sc_sup_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_apps_sc_sup_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_apps_sc_sup_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_brake_apps_sc_signals_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_apps_sc_signals_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_apps_sc_signals_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_brake_apps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_apps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_apps_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_brake_brake_sc_gnd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_brake_sc_gnd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_brake_sc_gnd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_brake_brake_sc_sup_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_brake_sc_sup_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_brake_sc_sup_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_apps_brake_brake_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_apps_brake_brake_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_apps_brake_brake_out_of_range_is_in_range(uint8_t value);

/**
 * Pack message DASH_HALL_F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_hall_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_hall_f_t *src_p,
    size_t size);

/**
 * Unpack message DASH_HALL_F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_hall_f_unpack(
    struct can_mcu_dash_hall_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_hall_f_hall_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_hall_f_hall_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_hall_f_hall_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_hall_f_hall_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_hall_f_hall_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_hall_f_hall_fr_is_in_range(uint16_t value);

/**
 * Pack message ECU_BOOLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_bools_t *src_p,
    size_t size);

/**
 * Unpack message ECU_BOOLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_bools_unpack(
    struct can_mcu_ecu_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_buzzer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_buzzer_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_buzzer_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_sensor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_sensor_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_sensor_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_brakelight_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_brakelight_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_brakelight_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_imd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_imd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_imd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_ams_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_ams_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_ams_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_servo_commanded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_servo_commanded_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_servo_commanded_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_radiator_fans_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_radiator_fans_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_radiator_fans_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_bools_radiator_fans_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_bools_radiator_fans_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_bools_radiator_fans_right_is_in_range(uint8_t value);

/**
 * Pack message DASH_STEERING.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_steering_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_steering_t *src_p,
    size_t size);

/**
 * Unpack message DASH_STEERING.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_steering_unpack(
    struct can_mcu_dash_steering_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_dash_steering_steering_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_steering_steering_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_steering_steering_is_in_range(float value);

/**
 * Pack message DASH_BOOLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_bools_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_bools_t *src_p,
    size_t size);

/**
 * Unpack message DASH_BOOLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_bools_unpack(
    struct can_mcu_dash_bools_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_ad_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_ad_act_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_ad_act_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_enable_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_enable_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_enable_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_start_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_start_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_sdc_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_sdc_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_sdc_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_steering_implausibility_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_steering_implausibility_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_steering_implausibility_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_plus_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_plus_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_plus_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_minus_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_minus_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_minus_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_enter_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_enter_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_enter_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_traction_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_traction_control_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_traction_control_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_differential_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_differential_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_differential_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_regen_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_regen_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_regen_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_rotary_active_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_rotary_active_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_rotary_active_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_driver_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_driver_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_driver_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_place_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_place_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_place_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_menu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_menu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_menu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_default_screen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_default_screen_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_default_screen_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_monitor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_monitor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_monitor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_cooling_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_cooling_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_cooling_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_dash_bools_cooling_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_bools_cooling_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_bools_cooling_button_is_in_range(uint8_t value);

/**
 * Pack message DASH_SUSP_F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_dash_susp_f_pack(
    uint8_t *dst_p,
    const struct can_mcu_dash_susp_f_t *src_p,
    size_t size);

/**
 * Unpack message DASH_SUSP_F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_dash_susp_f_unpack(
    struct can_mcu_dash_susp_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_susp_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_susp_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_susp_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_susp_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_susp_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_susp_fr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_strai_gauge_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_strai_gauge_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_strai_gauge_fr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_dash_susp_f_strain_gauge_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_dash_susp_f_strain_gauge_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_dash_susp_f_strain_gauge_fl_is_in_range(uint16_t value);

/**
 * Pack message ECU_ADU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_adu_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_adu_t *src_p,
    size_t size);

/**
 * Unpack message ECU_ADU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_adu_unpack(
    struct can_mcu_ecu_adu_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_ecu_adu_power_k_w_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_power_k_w_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_power_k_w_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_pl_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_pl_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_pl_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_regen_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_regen_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_regen_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_differential_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_differential_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_differential_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_tc_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_tc_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_tc_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_vicor_thermistor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_vicor_thermistor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_vicor_thermistor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_adu_recom_thermistor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_recom_thermistor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_recom_thermistor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_adu_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_adu_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_adu_velocity_is_in_range(uint16_t value);

/**
 * Pack message AUX_STATES.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_states_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_states_t *src_p,
    size_t size);

/**
 * Unpack message AUX_STATES.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_states_unpack(
    struct can_mcu_aux_states_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_aux_states_green_tsal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_states_green_tsal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_states_green_tsal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_aux_states_safe_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_states_safe_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_states_safe_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_aux_states_ts_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_states_ts_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_states_ts_off_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_states_dc_link_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_states_dc_link_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_states_dc_link_voltage_is_in_range(uint16_t value);

/**
 * Pack message AUX_IR_CAMS_R1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_ir_cams_r1_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_r1_t *src_p,
    size_t size);

/**
 * Unpack message AUX_IR_CAMS_R1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_ir_cams_r1_unpack(
    struct can_mcu_aux_ir_cams_r1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r1_zone_rr1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r1_zone_rr1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r1_zone_rr1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r1_zone_rr2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r1_zone_rr2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r1_zone_rr2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r1_zone_rr3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r1_zone_rr3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r1_zone_rr3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r1_zone_rr4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r1_zone_rr4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r1_zone_rr4_is_in_range(uint16_t value);

/**
 * Pack message AUX_IR_CAMS_R2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_ir_cams_r2_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_r2_t *src_p,
    size_t size);

/**
 * Unpack message AUX_IR_CAMS_R2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_ir_cams_r2_unpack(
    struct can_mcu_aux_ir_cams_r2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r2_zone_rr5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r2_zone_rr5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r2_zone_rr5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r2_zone_rr6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r2_zone_rr6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r2_zone_rr6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r2_zone_rr7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r2_zone_rr7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r2_zone_rr7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_r2_zone_rr8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_r2_zone_rr8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_r2_zone_rr8_is_in_range(uint16_t value);

/**
 * Pack message AUX_IR_CAMS_L1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_ir_cams_l1_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_l1_t *src_p,
    size_t size);

/**
 * Unpack message AUX_IR_CAMS_L1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_ir_cams_l1_unpack(
    struct can_mcu_aux_ir_cams_l1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l1_zone_rl1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l1_zone_rl1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l1_zone_rl1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l1_zone_rl2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l1_zone_rl2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l1_zone_rl2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l1_zone_rl3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l1_zone_rl3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l1_zone_rl3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l1_zone_rl4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l1_zone_rl4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l1_zone_rl4_is_in_range(uint16_t value);

/**
 * Pack message AUX_IR_CAMS_L2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_ir_cams_l2_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_ir_cams_l2_t *src_p,
    size_t size);

/**
 * Unpack message AUX_IR_CAMS_L2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_ir_cams_l2_unpack(
    struct can_mcu_aux_ir_cams_l2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l2_zone_rl5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l2_zone_rl5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l2_zone_rl5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l2_zone_rl6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l2_zone_rl6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l2_zone_rl6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l2_zone_rl7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l2_zone_rl7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l2_zone_rl7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_ir_cams_l2_zone_rl8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_ir_cams_l2_zone_rl8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_ir_cams_l2_zone_rl8_is_in_range(uint16_t value);

/**
 * Pack message ADU_INVERTER_LEFT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_adu_inverter_left_pack(
    uint8_t *dst_p,
    const struct can_mcu_adu_inverter_left_t *src_p,
    size_t size);

/**
 * Unpack message ADU_INVERTER_LEFT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_adu_inverter_left_unpack(
    struct can_mcu_adu_inverter_left_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_left_igbt_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_igbt_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_igbt_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_left_motor_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_motor_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_motor_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_adu_inverter_left_rpm_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_rpm_l_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_rpm_l_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_adu_inverter_left_torque_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_torque_l_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_torque_l_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_adu_inverter_left_idc_integer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_idc_integer_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_idc_integer_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_left_ac_temparature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_left_ac_temparature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_left_ac_temparature_is_in_range(uint8_t value);

/**
 * Pack message ADU_INVERTER_RIGHT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_adu_inverter_right_pack(
    uint8_t *dst_p,
    const struct can_mcu_adu_inverter_right_t *src_p,
    size_t size);

/**
 * Unpack message ADU_INVERTER_RIGHT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_adu_inverter_right_unpack(
    struct can_mcu_adu_inverter_right_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_right_igbt_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_igbt_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_igbt_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_adu_inverter_right_motor_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_motor_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_motor_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_adu_inverter_right_rpm_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_rpm_r_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_rpm_r_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_adu_inverter_right_torque_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_torque_r_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_torque_r_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_adu_inverter_right_isa_vdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_adu_inverter_right_isa_vdc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_adu_inverter_right_isa_vdc_is_in_range(uint16_t value);

/**
 * Pack message AUX_CABLES.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_aux_cables_pack(
    uint8_t *dst_p,
    const struct can_mcu_aux_cables_t *src_p,
    size_t size);

/**
 * Unpack message AUX_CABLES.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_aux_cables_unpack(
    struct can_mcu_aux_cables_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_cables_hv_cable1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_cables_hv_cable1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_cables_hv_cable1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_aux_cables_hv_cable2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_aux_cables_hv_cable2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_aux_cables_hv_cable2_is_in_range(uint16_t value);

/**
 * Pack message ASB.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_asb_pack(
    uint8_t *dst_p,
    const struct can_mcu_asb_t *src_p,
    size_t size);

/**
 * Unpack message ASB.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_asb_unpack(
    struct can_mcu_asb_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_asms_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_asms_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_asms_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_tsms_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_tsms_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_tsms_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_asb_led_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_asb_led_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_asb_led_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_initial_checked_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_initial_checked_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_initial_checked_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_tank_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_tank_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_tank_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_brake_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_brake_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_brake_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_servo_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_servo_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_servo_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_monitor_apu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_monitor_apu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_monitor_apu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_asb_initial_check_step_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_initial_check_step_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_initial_check_step_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_service_brake_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_service_brake_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_service_brake_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_asb_asb_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_asb_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_asb_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_asb_ebs_tank_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_asb_ebs_tank_pressure_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_asb_ebs_tank_pressure_is_in_range(uint16_t value);

/**
 * Pack message APU_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_command_t *src_p,
    size_t size);

/**
 * Unpack message APU_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_command_unpack(
    struct can_mcu_apu_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_mcu_apu_command_throttle_brake_commanded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_command_throttle_brake_commanded_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_command_throttle_brake_commanded_is_in_range(float value);

/**
 * Pack message APU_STATE_MISSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_state_mission_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_state_mission_t *src_p,
    size_t size);

/**
 * Unpack message APU_STATE_MISSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_state_mission_unpack(
    struct can_mcu_apu_state_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_apu_state_mission_as_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_state_mission_as_mission_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_state_mission_as_mission_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_apu_state_mission_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_state_mission_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_state_mission_as_state_is_in_range(uint8_t value);

/**
 * Pack message AMI.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ami_pack(
    uint8_t *dst_p,
    const struct can_mcu_ami_t *src_p,
    size_t size);

/**
 * Unpack message AMI.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ami_unpack(
    struct can_mcu_ami_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ami_ami_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ami_ami_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ami_ami_is_in_range(uint8_t value);

/**
 * Pack message Isabellen_Idc.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_idc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_idc_t *src_p,
    size_t size);

/**
 * Unpack message Isabellen_Idc.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_idc_unpack(
    struct can_mcu_isabellen_idc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_idc_idc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_idc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_idc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_idc_system_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_system_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_system_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_idc_idc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_idc_idc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_idc_idc_is_in_range(int32_t value);

/**
 * Pack message Isabellen_Vdc.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_vdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_vdc_t *src_p,
    size_t size);

/**
 * Unpack message Isabellen_Vdc.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_vdc_unpack(
    struct can_mcu_isabellen_vdc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_vdc_vdc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_vdc_vdc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_vdc_vdc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_vdc_vdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_vdc_vdc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_vdc_vdc_is_in_range(int32_t value);

/**
 * Pack message Isabellen_Pdc.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_pdc_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_pdc_t *src_p,
    size_t size);

/**
 * Unpack message Isabellen_Pdc.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_pdc_unpack(
    struct can_mcu_isabellen_pdc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_pdc_pdc_measurement_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_pdc_pdc_measurement_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_pdc_pdc_measurement_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_pdc_pdc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_pdc_pdc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_pdc_pdc_is_in_range(int32_t value);

/**
 * Pack message Isabellen_Energy.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_isabellen_energy_pack(
    uint8_t *dst_p,
    const struct can_mcu_isabellen_energy_t *src_p,
    size_t size);

/**
 * Unpack message Isabellen_Energy.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_isabellen_energy_unpack(
    struct can_mcu_isabellen_energy_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_isabellen_energy_energy_measurent_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_energy_energy_measurent_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_energy_energy_measurent_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_isabellen_energy_energy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_isabellen_energy_energy_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_isabellen_energy_energy_is_in_range(int32_t value);

/**
 * Pack message BLDC_TX_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_1_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_1_unpack(
    struct can_mcu_bldc_tx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bldc_tx_1_status_word_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_1_status_word_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_1_status_word_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_mcu_bldc_tx_1_modes_of_operation_display_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_1_modes_of_operation_display_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_1_modes_of_operation_display_is_in_range(int8_t value);

/**
 * Pack message BLDC_RX_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_1_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_1_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_1_unpack(
    struct can_mcu_bldc_rx_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bldc_rx_1_controlword_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_controlword_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_controlword_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_bldc_rx_1_mode_of_operation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_mode_of_operation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_mode_of_operation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_1_motor_drive_submode_select_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_1_motor_drive_submode_select_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_1_motor_drive_submode_select_is_in_range(uint32_t value);

/**
 * Pack message BLDC_RX_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_2_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_2_unpack(
    struct can_mcu_bldc_rx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_bldc_rx_2_target_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_2_target_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_2_target_position_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_2_profile_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_2_profile_velocity_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_2_profile_velocity_is_in_range(uint32_t value);

/**
 * Pack message BLDC_TX_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_2_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_2_unpack(
    struct can_mcu_bldc_tx_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can_mcu_bldc_tx_2_position_actual_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_2_position_actual_value_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_2_position_actual_value_is_in_range(int32_t value);

/**
 * Pack message BLDC_TX_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_3_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_3_unpack(
    struct can_mcu_bldc_tx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_bldc_tx_3_velocity_actual_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_3_velocity_actual_value_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_3_velocity_actual_value_is_in_range(int16_t value);

/**
 * Pack message BLDC_RX_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_3_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_3_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_3_unpack(
    struct can_mcu_bldc_rx_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_bldc_rx_3_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_3_target_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_3_target_velocity_is_in_range(int16_t value);

/**
 * Pack message BLDC_TX_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_tx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_tx_4_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_TX_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_tx_4_unpack(
    struct can_mcu_bldc_tx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_tx_4_digital_input_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_tx_4_digital_input_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_tx_4_digital_input_is_in_range(uint32_t value);

/**
 * Pack message BLDC_RX_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bldc_rx_4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bldc_rx_4_t *src_p,
    size_t size);

/**
 * Unpack message BLDC_RX_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bldc_rx_4_unpack(
    struct can_mcu_bldc_rx_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_mcu_bldc_rx_4_digital_output_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bldc_rx_4_digital_output_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bldc_rx_4_digital_output_is_in_range(uint32_t value);

/**
 * Pack message Steering_command.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_steering_command_pack(
    uint8_t *dst_p,
    const struct can_mcu_steering_command_t *src_p,
    size_t size);

/**
 * Unpack message Steering_command.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_steering_command_unpack(
    struct can_mcu_steering_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_steering_command_position_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_steering_command_position_target_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_steering_command_position_target_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_mcu_steering_command_velocity_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_steering_command_velocity_target_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_steering_command_velocity_target_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_steering_command_steering_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_steering_command_steering_mode_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_steering_command_steering_mode_is_in_range(uint16_t value);

/**
 * Pack message Inverter_Right_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_inverter_right_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_inverter_right_info_t *src_p,
    size_t size);

/**
 * Unpack message Inverter_Right_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_inverter_right_info_unpack(
    struct can_mcu_inverter_right_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_right_info_irms_max_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_right_info_irms_max_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_right_info_irms_max_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_right_info_i_lim_in_use_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_right_info_i_lim_in_use_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_right_info_i_lim_in_use_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_right_info_irm_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_right_info_irm_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_right_info_irm_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_right_info_max_rpm_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_right_info_max_rpm_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_right_info_max_rpm_right_is_in_range(uint16_t value);

/**
 * Pack message Cooling.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_cooling_pack(
    uint8_t *dst_p,
    const struct can_mcu_cooling_t *src_p,
    size_t size);

/**
 * Unpack message Cooling.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_cooling_unpack(
    struct can_mcu_cooling_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_pump_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_pump_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_pump_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_tsac_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_tsac_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_tsac_fans_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_hall_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_hall_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_hall_fans_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_chassis_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_chassis_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_chassis_fans_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_cooling_radiator_fanss_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_cooling_radiator_fanss_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_cooling_radiator_fanss_is_in_range(uint8_t value);

/**
 * Pack message Inverter_Left_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_inverter_left_info_pack(
    uint8_t *dst_p,
    const struct can_mcu_inverter_left_info_t *src_p,
    size_t size);

/**
 * Unpack message Inverter_Left_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_inverter_left_info_unpack(
    struct can_mcu_inverter_left_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_left_info_irms_max_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_left_info_irms_max_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_left_info_irms_max_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_left_info_i_lim_in_use_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_left_info_i_lim_in_use_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_left_info_i_lim_in_use_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_left_info_irm_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_left_info_irm_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_left_info_irm_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_inverter_left_info_max_rpm_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_inverter_left_info_max_rpm_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_inverter_left_info_max_rpm_left_is_in_range(uint16_t value);

/**
 * Pack message ECU_PARAMETERS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_parameters_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_parameters_t *src_p,
    size_t size);

/**
 * Unpack message ECU_PARAMETERS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_parameters_unpack(
    struct can_mcu_ecu_parameters_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_parameters_inverter_rpm_percentage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_inverter_rpm_percentage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_inverter_rpm_percentage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_parameters_inverter_i_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_inverter_i_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_inverter_i_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_power_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_power_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_power_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_servo_start_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_servo_start_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_servo_start_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_regen_min_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_regen_min_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_regen_min_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_ed_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_ed_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_ed_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_tc_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_tc_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_tc_enable_is_in_range(uint8_t value);

/**
 * Pack message ECU_PARAMETERS_ACTUAL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_ecu_parameters_actual_pack(
    uint8_t *dst_p,
    const struct can_mcu_ecu_parameters_actual_t *src_p,
    size_t size);

/**
 * Unpack message ECU_PARAMETERS_ACTUAL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_ecu_parameters_actual_unpack(
    struct can_mcu_ecu_parameters_actual_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_parameters_actual_inverter_rpm_max_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_actual_inverter_rpm_max_actual_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_actual_inverter_rpm_max_actual_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_ecu_parameters_actual_inverter_i_max_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_actual_inverter_i_max_actual_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_actual_inverter_i_max_actual_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_actual_power_target_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_actual_power_target_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_actual_power_target_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_actual_servo_start_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_actual_servo_start_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_actual_servo_start_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_actual_regen_min_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_actual_regen_min_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_actual_regen_min_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_actual_ed_enable_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_actual_ed_enable_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_actual_ed_enable_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_ecu_parameters_actual_tc_enable_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_ecu_parameters_actual_tc_enable_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_ecu_parameters_actual_tc_enable_actual_is_in_range(uint8_t value);

/**
 * Pack message BMS_MIN_MAX_S1_S2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s1_s2_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s1_s2_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S1_S2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s1_s2_unpack(
    struct can_mcu_bms_min_max_s1_s2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s1_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s1_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s1_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s1_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s1_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s1_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s2_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s2_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s2_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s1_s2_s2_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s1_s2_s2_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s1_s2_s2_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S3_S4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s3_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s3_s4_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S3_S4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s3_s4_unpack(
    struct can_mcu_bms_min_max_s3_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s3_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s3_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s3_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s3_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s3_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s3_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s4_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s4_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s4_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s3_s4_s4_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s3_s4_s4_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s3_s4_s4_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S5_S6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s5_s6_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s5_s6_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S5_S6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s5_s6_unpack(
    struct can_mcu_bms_min_max_s5_s6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s5_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s5_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s5_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s5_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s5_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s5_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s6_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s6_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s6_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s5_s6_s6_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s5_s6_s6_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s5_s6_s6_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S7_S8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s7_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s7_s8_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S7_S8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s7_s8_unpack(
    struct can_mcu_bms_min_max_s7_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s7_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s7_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s7_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s7_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s7_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s7_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s8_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s8_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s8_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s7_s8_s8_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s7_s8_s8_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s7_s8_s8_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S9_S10.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s9_s10_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s9_s10_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S9_S10.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s9_s10_unpack(
    struct can_mcu_bms_min_max_s9_s10_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s9_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s9_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s9_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s9_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s9_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s9_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s10_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s10_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s10_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s9_s10_s10_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s9_s10_s10_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s9_s10_s10_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_MIN_MAX_S11_S12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_min_max_s11_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_min_max_s11_s12_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MIN_MAX_S11_S12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_min_max_s11_s12_unpack(
    struct can_mcu_bms_min_max_s11_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s11_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s11_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s11_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s11_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s11_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s11_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s12_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s12_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s12_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_min_max_s11_s12_s12_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_min_max_s11_s12_s12_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_min_max_s11_s12_s12_max_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S1_S4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s1_s4_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s1_s4_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S1_S4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s1_s4_unpack(
    struct can_mcu_bms_max_temp_s1_s4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s1_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s1_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s1_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s2_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s2_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s2_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s3_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s3_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s3_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s1_s4_s4_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s1_s4_s4_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s1_s4_s4_max_temp_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S5_S8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s5_s8_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s5_s8_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S5_S8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s5_s8_unpack(
    struct can_mcu_bms_max_temp_s5_s8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s5_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s5_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s5_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s6_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s6_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s6_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s7_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s7_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s7_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s5_s8_s8_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s5_s8_s8_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s5_s8_s8_max_temp_is_in_range(uint16_t value);

/**
 * Pack message BMS_Max_Temp_S9_S12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_bms_max_temp_s9_s12_pack(
    uint8_t *dst_p,
    const struct can_mcu_bms_max_temp_s9_s12_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Max_Temp_S9_S12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_bms_max_temp_s9_s12_unpack(
    struct can_mcu_bms_max_temp_s9_s12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s9_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s9_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s9_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s10_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s10_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s10_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_bms_max_temp_s9_s12_s11_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s11_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s11_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_mcu_bms_max_temp_s9_s12_s12_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_bms_max_temp_s9_s12_s12_max_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_bms_max_temp_s9_s12_s12_max_temp_is_in_range(uint8_t value);

/**
 * Pack message APU_Temps.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_mcu_apu_temps_pack(
    uint8_t *dst_p,
    const struct can_mcu_apu_temps_t *src_p,
    size_t size);

/**
 * Unpack message APU_Temps.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_mcu_apu_temps_unpack(
    struct can_mcu_apu_temps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_apu_temps_cpu_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_temps_cpu_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_temps_cpu_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_mcu_apu_temps_gpu_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_mcu_apu_temps_gpu_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_mcu_apu_temps_gpu_temp_is_in_range(uint16_t value);


#ifdef __cplusplus
}
#endif

#endif
