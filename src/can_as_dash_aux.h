/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.1.0 Thu Feb 11 15:36:53 2021.
 */

#ifndef CAN_AS_DASH_AUX_H
#define CAN_AS_DASH_AUX_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_AS_DASH_AUX_DASH_101_FRAME_ID (0x65u)
#define CAN_AS_DASH_AUX_DASH_198_FRAME_ID (0xc6u)
#define CAN_AS_DASH_AUX_DASH_279_FRAME_ID (0x117u)
#define CAN_AS_DASH_AUX_DASH_107_FRAME_ID (0x6bu)
#define CAN_AS_DASH_AUX_AUX_357_FRAME_ID (0x165u)
#define CAN_AS_DASH_AUX_AUX_384_FRAME_ID (0x180u)
#define CAN_AS_DASH_AUX_AUX_412_FRAME_ID (0x19cu)
#define CAN_AS_DASH_AUX_AUX_166_FRAME_ID (0xa6u)
#define CAN_AS_DASH_AUX_DASH_204_FRAME_ID (0xccu)
#define CAN_AS_DASH_AUX_AUX_336_FRAME_ID (0x150u)
#define CAN_AS_DASH_AUX_AMI_505_FRAME_ID (0x1f9u)
#define CAN_AS_DASH_AUX_APU_660_FRAME_ID (0x294u)
#define CAN_AS_DASH_AUX_SWA_510_FRAME_ID (0x1feu)
#define CAN_AS_DASH_AUX_SWA_530_FRAME_ID (0x212u)
#define CAN_AS_DASH_AUX_EBS_550_FRAME_ID (0x226u)

/* Frame lengths in bytes. */
#define CAN_AS_DASH_AUX_DASH_101_LENGTH (4u)
#define CAN_AS_DASH_AUX_DASH_198_LENGTH (2u)
#define CAN_AS_DASH_AUX_DASH_279_LENGTH (7u)
#define CAN_AS_DASH_AUX_DASH_107_LENGTH (6u)
#define CAN_AS_DASH_AUX_AUX_357_LENGTH (8u)
#define CAN_AS_DASH_AUX_AUX_384_LENGTH (7u)
#define CAN_AS_DASH_AUX_AUX_412_LENGTH (8u)
#define CAN_AS_DASH_AUX_AUX_166_LENGTH (1u)
#define CAN_AS_DASH_AUX_DASH_204_LENGTH (5u)
#define CAN_AS_DASH_AUX_AUX_336_LENGTH (2u)
#define CAN_AS_DASH_AUX_AMI_505_LENGTH (1u)
#define CAN_AS_DASH_AUX_APU_660_LENGTH (2u)
#define CAN_AS_DASH_AUX_SWA_510_LENGTH (2u)
#define CAN_AS_DASH_AUX_SWA_530_LENGTH (2u)
#define CAN_AS_DASH_AUX_EBS_550_LENGTH (6u)

/* Extended or standard frame types. */
#define CAN_AS_DASH_AUX_DASH_101_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_DASH_198_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_DASH_279_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_DASH_107_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_357_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_384_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_412_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_166_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_DASH_204_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_336_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AMI_505_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_APU_660_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_SWA_510_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_SWA_530_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_EBS_550_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define CAN_AS_DASH_AUX_DASH_101_CYCLE_TIME_MS (20u)
#define CAN_AS_DASH_AUX_DASH_198_CYCLE_TIME_MS (10u)
#define CAN_AS_DASH_AUX_DASH_279_CYCLE_TIME_MS (100u)
#define CAN_AS_DASH_AUX_DASH_107_CYCLE_TIME_MS (5u)
#define CAN_AS_DASH_AUX_AUX_357_CYCLE_TIME_MS (5u)
#define CAN_AS_DASH_AUX_AUX_384_CYCLE_TIME_MS (1000u)
#define CAN_AS_DASH_AUX_AUX_412_CYCLE_TIME_MS (100u)
#define CAN_AS_DASH_AUX_AUX_166_CYCLE_TIME_MS (10u)
#define CAN_AS_DASH_AUX_DASH_204_CYCLE_TIME_MS (100u)
#define CAN_AS_DASH_AUX_AUX_336_CYCLE_TIME_MS (1000u)
#define CAN_AS_DASH_AUX_AMI_505_CYCLE_TIME_MS (250u)
#define CAN_AS_DASH_AUX_APU_660_CYCLE_TIME_MS (125u)
#define CAN_AS_DASH_AUX_SWA_510_CYCLE_TIME_MS (10u)
#define CAN_AS_DASH_AUX_SWA_530_CYCLE_TIME_MS (1000u)
#define CAN_AS_DASH_AUX_EBS_550_CYCLE_TIME_MS (100u)

/* Signal choices. */
#define CAN_AS_DASH_AUX_AUX_384_SAFE_STATE_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_AUX_384_SAFE_STATE_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_AUX_412_ACCU_FANS_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_AUX_412_ACCU_FANS_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_AUX_412_LEFT_FANS_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_AUX_412_LEFT_FANS_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_AUX_412_RIGHT_FANS_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_AUX_412_RIGHT_FANS_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_AUX_166_BRAKELIGHT_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_AUX_166_BRAKELIGHT_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_ERROR_MISSION_CHOICE (-1)
#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_NO_MISSION_CHOICE (0)
#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_ACCELERATION_CHOICE (1)
#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_SKIDPAD_CHOICE (2)
#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_AUTOCROSS_CHOICE (3)
#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_TRACKDRIVE_CHOICE (4)
#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_EBSTEST_CHOICE (5)
#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_INSPECTION_CHOICE (6)
#define CAN_AS_DASH_AUX_AMI_505_AMI_MISSION_MANUAL_DRIVING_CHOICE (7)

#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_ERROR_MISSION_CHOICE (-1)
#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_NO_MISSION_CHOICE (0)
#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_ACCELERATION_CHOICE (1)
#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_SKIDPAD_CHOICE (2)
#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_AUTOCROSS_CHOICE (3)
#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_TRACKDRIVE_CHOICE (4)
#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_EBSTEST_CHOICE (5)
#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_INSPECTION_CHOICE (6)
#define CAN_AS_DASH_AUX_APU_660_AS_MISSION_MANUAL_DRIVING_CHOICE (7)

#define CAN_AS_DASH_AUX_APU_660_AS_STATE_MANUAL_DRIVING_CHOICE (0)
#define CAN_AS_DASH_AUX_APU_660_AS_STATE_AS_OFF_CHOICE (1)
#define CAN_AS_DASH_AUX_APU_660_AS_STATE_AS_READY_CHOICE (2)
#define CAN_AS_DASH_AUX_APU_660_AS_STATE_AS_DRIVING_CHOICE (3)
#define CAN_AS_DASH_AUX_APU_660_AS_STATE_AS_FINISHED_CHOICE (4)
#define CAN_AS_DASH_AUX_APU_660_AS_STATE_AS_EMERGENCY_CHOICE (5)

#define CAN_AS_DASH_AUX_EBS_550_ASMS_STATE_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_550_ASMS_STATE_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_550_TSMS_OUT_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_550_TSMS_OUT_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_550_EBS_ENGAGED_NO_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_550_EBS_ENGAGED_YES_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_550_EBS_IS_ARMED_NO_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_550_EBS_IS_ARMED_YES_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_550_EBS_LED_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_550_EBS_LED_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_550_K2_STATE_RES_GO_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_550_K2_STATE_RES_GO_PRESSED_CHOICE (13u)

/**
 * Signals in message DASH_101.
 *
 * APPS Raw Values
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_101_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps1_raw;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps2_raw;
};

/**
 * Signals in message DASH_198.
 *
 * Brake Raw Value
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_198_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_raw;
};

/**
 * Signals in message DASH_279.
 *
 * Dashboard Buttons and Toggles
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_279_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_toggle;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t second_toggle;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t third_toggle_notused;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t start;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ad_act;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t green_tsal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_state;
};

/**
 * Signals in message DASH_107.
 *
 * Front Hall Effect Sensors
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_107_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t hall_fl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t hall_fr;
};

/**
 * Signals in message AUX_357.
 *
 * Rear Hall Effect Sensors
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_357_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t hall_rl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t hall_rr;
};

/**
 * Signals in message AUX_384.
 *
 * TSAL Safe State
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_384_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t safe_state;
};

/**
 * Signals in message AUX_412.
 *
 * Pumps & Fans Signals
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_412_t {
    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_pump_signal;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_pump_signal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t accu_fans_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_fans_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_fans_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t accu_fans;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_fans;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_fans;
};

/**
 * Signals in message AUX_166.
 *
 * Brake Light
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_166_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brakelight;
};

/**
 * Signals in message DASH_204.
 *
 * LEDs to Dashboard
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_204_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t buzzer;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t safe_state_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_out;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sensor_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_software;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pl_active;
};

/**
 * Signals in message AUX_336.
 *
 * EBS Tank Pressure Raw Value
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_336_t {
    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ebs_pressure_raw;
};

/**
 * Signals in message AMI_505.
 *
 * AMI Rotary Switch Position
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_ami_505_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ami_mission;
};

/**
 * Signals in message APU_660.
 *
 * Selected Mission, AS State
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_apu_660_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t as_mission;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t as_state;
};

/**
 * Signals in message SWA_510.
 *
 * Steering Actuation Wheel Actual Position
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_swa_510_t {
    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_actual;
};

/**
 * Signals in message SWA_530.
 *
 * Steering Wheel Target
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_swa_530_t {
    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_target;
};

/**
 * Signals in message EBS_550.
 *
 * ASMS State, SDC State, EBS Activated, EBS Armed, EBS LED, K2 State
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_ebs_550_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asms_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsms_out;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_engaged;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_is_armed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_led;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t k2_state;
};

/**
 * Pack message DASH_101.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_101_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_101_t *src_p,
    size_t size);

/**
 * Unpack message DASH_101.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_101_unpack(
    struct can_as_dash_aux_dash_101_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_dash_101_apps1_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_101_apps1_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_101_apps1_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_dash_101_apps2_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_101_apps2_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_101_apps2_raw_is_in_range(uint16_t value);

/**
 * Pack message DASH_198.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_198_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_198_t *src_p,
    size_t size);

/**
 * Unpack message DASH_198.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_198_unpack(
    struct can_as_dash_aux_dash_198_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_dash_198_brake_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_198_brake_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_198_brake_raw_is_in_range(uint16_t value);

/**
 * Pack message DASH_279.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_279_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_279_t *src_p,
    size_t size);

/**
 * Unpack message DASH_279.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_279_unpack(
    struct can_as_dash_aux_dash_279_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_279_enable_toggle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_279_enable_toggle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_279_enable_toggle_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_279_second_toggle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_279_second_toggle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_279_second_toggle_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_279_third_toggle_notused_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_279_third_toggle_notused_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_279_third_toggle_notused_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_279_start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_279_start_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_279_start_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_279_ad_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_279_ad_act_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_279_ad_act_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_279_green_tsal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_279_green_tsal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_279_green_tsal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_279_sc_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_279_sc_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_279_sc_state_is_in_range(uint8_t value);

/**
 * Pack message DASH_107.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_107_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_107_t *src_p,
    size_t size);

/**
 * Unpack message DASH_107.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_107_unpack(
    struct can_as_dash_aux_dash_107_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_as_dash_aux_dash_107_hall_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_107_hall_fl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_107_hall_fl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_dash_107_hall_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_107_hall_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_107_hall_fr_is_in_range(uint16_t value);

/**
 * Pack message AUX_357.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_357_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_357_t *src_p,
    size_t size);

/**
 * Unpack message AUX_357.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_357_unpack(
    struct can_as_dash_aux_aux_357_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_as_dash_aux_aux_357_hall_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_357_hall_rl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_357_hall_rl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_as_dash_aux_aux_357_hall_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_357_hall_rr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_357_hall_rr_is_in_range(uint32_t value);

/**
 * Pack message AUX_384.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_384_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_384_t *src_p,
    size_t size);

/**
 * Unpack message AUX_384.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_384_unpack(
    struct can_as_dash_aux_aux_384_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_384_safe_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_384_safe_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_384_safe_state_is_in_range(uint8_t value);

/**
 * Pack message AUX_412.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_412_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_412_t *src_p,
    size_t size);

/**
 * Unpack message AUX_412.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_412_unpack(
    struct can_as_dash_aux_aux_412_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_412_left_pump_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_412_left_pump_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_412_left_pump_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_412_right_pump_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_412_right_pump_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_412_right_pump_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_412_accu_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_412_accu_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_412_accu_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_412_left_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_412_left_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_412_left_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_412_right_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_412_right_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_412_right_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_412_accu_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_412_accu_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_412_accu_fans_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_412_left_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_412_left_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_412_left_fans_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_412_right_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_412_right_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_412_right_fans_is_in_range(uint8_t value);

/**
 * Pack message AUX_166.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_166_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_166_t *src_p,
    size_t size);

/**
 * Unpack message AUX_166.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_166_unpack(
    struct can_as_dash_aux_aux_166_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_166_brakelight_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_166_brakelight_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_166_brakelight_is_in_range(uint8_t value);

/**
 * Pack message DASH_204.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_204_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_204_t *src_p,
    size_t size);

/**
 * Unpack message DASH_204.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_204_unpack(
    struct can_as_dash_aux_dash_204_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_204_fan_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_204_fan_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_204_fan_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_204_buzzer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_204_buzzer_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_204_buzzer_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_204_safe_state_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_204_safe_state_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_204_safe_state_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_204_enable_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_204_enable_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_204_enable_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_204_sensor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_204_sensor_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_204_sensor_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_204_sc_software_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_204_sc_software_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_204_sc_software_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_204_pl_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_204_pl_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_204_pl_active_is_in_range(uint8_t value);

/**
 * Pack message AUX_336.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_336_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_336_t *src_p,
    size_t size);

/**
 * Unpack message AUX_336.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_336_unpack(
    struct can_as_dash_aux_aux_336_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_aux_336_ebs_pressure_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_336_ebs_pressure_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_336_ebs_pressure_raw_is_in_range(uint16_t value);

/**
 * Pack message AMI_505.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_ami_505_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ami_505_t *src_p,
    size_t size);

/**
 * Unpack message AMI_505.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_ami_505_unpack(
    struct can_as_dash_aux_ami_505_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_as_dash_aux_ami_505_ami_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ami_505_ami_mission_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ami_505_ami_mission_is_in_range(int8_t value);

/**
 * Pack message APU_660.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_apu_660_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_apu_660_t *src_p,
    size_t size);

/**
 * Unpack message APU_660.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_apu_660_unpack(
    struct can_as_dash_aux_apu_660_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_as_dash_aux_apu_660_as_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_apu_660_as_mission_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_apu_660_as_mission_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_as_dash_aux_apu_660_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_apu_660_as_state_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_apu_660_as_state_is_in_range(int8_t value);

/**
 * Pack message SWA_510.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_swa_510_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_swa_510_t *src_p,
    size_t size);

/**
 * Unpack message SWA_510.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_swa_510_unpack(
    struct can_as_dash_aux_swa_510_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_swa_510_steering_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_swa_510_steering_actual_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_swa_510_steering_actual_is_in_range(uint16_t value);

/**
 * Pack message SWA_530.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_swa_530_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_swa_530_t *src_p,
    size_t size);

/**
 * Unpack message SWA_530.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_swa_530_unpack(
    struct can_as_dash_aux_swa_530_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_swa_530_steering_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_swa_530_steering_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_swa_530_steering_target_is_in_range(uint16_t value);

/**
 * Pack message EBS_550.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_ebs_550_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ebs_550_t *src_p,
    size_t size);

/**
 * Unpack message EBS_550.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_ebs_550_unpack(
    struct can_as_dash_aux_ebs_550_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_550_asms_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_550_asms_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_550_asms_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_550_tsms_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_550_tsms_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_550_tsms_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_550_ebs_engaged_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_550_ebs_engaged_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_550_ebs_engaged_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_550_ebs_is_armed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_550_ebs_is_armed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_550_ebs_is_armed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_550_ebs_led_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_550_ebs_led_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_550_ebs_led_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_550_k2_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_550_k2_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_550_k2_state_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
