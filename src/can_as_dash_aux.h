/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.2.0 Thu Apr  1 20:05:33 2021.
 */

#ifndef CAN_AS_DASH_AUX_H
#define CAN_AS_DASH_AUX_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_AS_DASH_AUX_DASH_APPS_FRAME_ID (0x65u)
#define CAN_AS_DASH_AUX_DASH_BRAKE_FRAME_ID (0xc6u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_FRAME_ID (0x117u)
#define CAN_AS_DASH_AUX_DASH_FRONT_HALL_FRAME_ID (0x6bu)
#define CAN_AS_DASH_AUX_AUX_REAR_HALL_FRAME_ID (0x165u)
#define CAN_AS_DASH_AUX_AUX_TSAL_SAFE_STATE_FRAME_ID (0x180u)
#define CAN_AS_DASH_AUX_AUX_PUMPS_FANS_FRAME_ID (0x19cu)
#define CAN_AS_DASH_AUX_AUX_BRAKELIGHT_FRAME_ID (0xa6u)
#define CAN_AS_DASH_AUX_DASH_LEDS_FRAME_ID (0xccu)
#define CAN_AS_DASH_AUX_AUX_TANK_PRESSURE_FRAME_ID (0x150u)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_FRAME_ID (0x1f9u)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_FRAME_ID (0x32u)
#define CAN_AS_DASH_AUX_SWA_ACTUAL_FRAME_ID (0x1feu)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_FRAME_ID (0x5au)
#define CAN_AS_DASH_AUX_EBS_SERVICE_BRAKE_FRAME_ID (0xc8u)
#define CAN_AS_DASH_AUX_SWA_COMMANDED_FRAME_ID (0x212u)
#define CAN_AS_DASH_AUX_APU_COMMAND_FRAME_ID (0x214u)

/* Frame lengths in bytes. */
#define CAN_AS_DASH_AUX_DASH_APPS_LENGTH (4u)
#define CAN_AS_DASH_AUX_DASH_BRAKE_LENGTH (2u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_LENGTH (7u)
#define CAN_AS_DASH_AUX_DASH_FRONT_HALL_LENGTH (6u)
#define CAN_AS_DASH_AUX_AUX_REAR_HALL_LENGTH (8u)
#define CAN_AS_DASH_AUX_AUX_TSAL_SAFE_STATE_LENGTH (7u)
#define CAN_AS_DASH_AUX_AUX_PUMPS_FANS_LENGTH (8u)
#define CAN_AS_DASH_AUX_AUX_BRAKELIGHT_LENGTH (1u)
#define CAN_AS_DASH_AUX_DASH_LEDS_LENGTH (5u)
#define CAN_AS_DASH_AUX_AUX_TANK_PRESSURE_LENGTH (2u)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_LENGTH (1u)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_LENGTH (2u)
#define CAN_AS_DASH_AUX_SWA_ACTUAL_LENGTH (2u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_LENGTH (4u)
#define CAN_AS_DASH_AUX_EBS_SERVICE_BRAKE_LENGTH (1u)
#define CAN_AS_DASH_AUX_SWA_COMMANDED_LENGTH (8u)
#define CAN_AS_DASH_AUX_APU_COMMAND_LENGTH (4u)

/* Extended or standard frame types. */
#define CAN_AS_DASH_AUX_DASH_APPS_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_DASH_BRAKE_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_DASH_FRONT_HALL_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_REAR_HALL_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_TSAL_SAFE_STATE_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_PUMPS_FANS_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_BRAKELIGHT_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_DASH_LEDS_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AUX_TANK_PRESSURE_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_SWA_ACTUAL_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_EBS_SERVICE_BRAKE_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_SWA_COMMANDED_IS_EXTENDED (0)
#define CAN_AS_DASH_AUX_APU_COMMAND_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define CAN_AS_DASH_AUX_DASH_APPS_CYCLE_TIME_MS (20u)
#define CAN_AS_DASH_AUX_DASH_BRAKE_CYCLE_TIME_MS (10u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_CYCLE_TIME_MS (100u)
#define CAN_AS_DASH_AUX_DASH_FRONT_HALL_CYCLE_TIME_MS (5u)
#define CAN_AS_DASH_AUX_AUX_REAR_HALL_CYCLE_TIME_MS (5u)
#define CAN_AS_DASH_AUX_AUX_TSAL_SAFE_STATE_CYCLE_TIME_MS (1000u)
#define CAN_AS_DASH_AUX_AUX_PUMPS_FANS_CYCLE_TIME_MS (100u)
#define CAN_AS_DASH_AUX_AUX_BRAKELIGHT_CYCLE_TIME_MS (10u)
#define CAN_AS_DASH_AUX_DASH_LEDS_CYCLE_TIME_MS (100u)
#define CAN_AS_DASH_AUX_AUX_TANK_PRESSURE_CYCLE_TIME_MS (1000u)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_CYCLE_TIME_MS (250u)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_CYCLE_TIME_MS (125u)
#define CAN_AS_DASH_AUX_SWA_ACTUAL_CYCLE_TIME_MS (10u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_CYCLE_TIME_MS (100u)
#define CAN_AS_DASH_AUX_EBS_SERVICE_BRAKE_CYCLE_TIME_MS (10u)
#define CAN_AS_DASH_AUX_SWA_COMMANDED_CYCLE_TIME_MS (8u)
#define CAN_AS_DASH_AUX_APU_COMMAND_CYCLE_TIME_MS (20u)

/* Signal choices. */
#define CAN_AS_DASH_AUX_DASH_BUTTONS_ENABLE_TOGGLE_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_ENABLE_TOGGLE_ON_CHOICE (1u)

#define CAN_AS_DASH_AUX_DASH_BUTTONS_SECOND_TOGGLE_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_SECOND_TOGGLE_ON_CHOICE (1u)

#define CAN_AS_DASH_AUX_DASH_BUTTONS_THIRD_TOGGLE_NOTUSED_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_THIRD_TOGGLE_NOTUSED_ON_CHOICE (1u)

#define CAN_AS_DASH_AUX_DASH_BUTTONS_START_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_START_ON_CHOICE (1u)

#define CAN_AS_DASH_AUX_DASH_BUTTONS_AD_ACT_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_AD_ACT_ON_CHOICE (1u)

#define CAN_AS_DASH_AUX_DASH_BUTTONS_GREEN_TSAL_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_GREEN_TSAL_ON_CHOICE (1u)

#define CAN_AS_DASH_AUX_DASH_BUTTONS_SC_STATE_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_BUTTONS_SC_STATE_ON_CHOICE (1u)

#define CAN_AS_DASH_AUX_AUX_TSAL_SAFE_STATE_SAFE_STATE_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_AUX_TSAL_SAFE_STATE_SAFE_STATE_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_AUX_BRAKELIGHT_BRAKELIGHT_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_AUX_BRAKELIGHT_BRAKELIGHT_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_DASH_LEDS_BUZZER_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_LEDS_BUZZER_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_DASH_LEDS_SAFE_STATE_1_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_LEDS_SAFE_STATE_1_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_DASH_LEDS_ENABLE_OUT_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_LEDS_ENABLE_OUT_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_DASH_LEDS_SENSOR_ERROR_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_LEDS_SENSOR_ERROR_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_DASH_LEDS_SC_SOFTWARE_OPEN_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_LEDS_SC_SOFTWARE_CLOSED_CHOICE (1u)

#define CAN_AS_DASH_AUX_DASH_LEDS_PL_ACTIVE_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_DASH_LEDS_PL_ACTIVE_ON_CHOICE (1u)

#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_ERROR_MISSION_CHOICE (-1)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_NO_MISSION_CHOICE (0)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_ACCELERATION_CHOICE (1)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_SKIDPAD_CHOICE (2)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_AUTOCROSS_CHOICE (3)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_TRACKDRIVE_CHOICE (4)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_EBSTEST_CHOICE (5)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_INSPECTION_CHOICE (6)
#define CAN_AS_DASH_AUX_AMI_SELECTED_MISSION_AMI_MISSION_MANUAL_DRIVING_CHOICE (7)

#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_ERROR_MISSION_CHOICE (-1)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_NO_MISSION_CHOICE (0)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_ACCELERATION_CHOICE (1)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_SKIDPAD_CHOICE (2)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_AUTOCROSS_CHOICE (3)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_TRACKDRIVE_CHOICE (4)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_EBSTEST_CHOICE (5)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_INSPECTION_CHOICE (6)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_MISSION_MANUAL_DRIVING_CHOICE (7)

#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_STATE_MANUAL_DRIVING_CHOICE (0u)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_STATE_AS_OFF_CHOICE (1u)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_STATE_AS_READY_CHOICE (2u)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_STATE_AS_DRIVING_CHOICE (3u)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_STATE_AS_FINISHED_CHOICE (4u)
#define CAN_AS_DASH_AUX_APU_STATE_MISSION_AS_STATE_AS_EMERGENCY_CHOICE (5u)

#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_ASMS_STATE_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_ASMS_STATE_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_TSMS_OUT_SDC_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_TSMS_OUT_SDC_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_K2_STATE_RES_GO_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_K2_STATE_RES_GO_PRESSED_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_EBS_ENGAGED_NO_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_EBS_ENGAGED_YES_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_EBS_ARMED_NO_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_EBS_ARMED_YES_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_EBS_LED_OFF_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_EBS_LED_ON_CHOICE (13u)

#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_SERVICE_BRAKE_STATUS_SERVICE_BRAKE_DISENGAGED_CHOICE (1u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_SERVICE_BRAKE_STATUS_SERVICE_BRAKE_ENGAGED_CHOICE (2u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_SERVICE_BRAKE_STATUS_SERVICE_BRAKE_AVAILABLE_CHOICE (3u)

#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_INITIAL_CHECKED_NO_CHOICE (0u)
#define CAN_AS_DASH_AUX_EBS_SUPERVISOR_INITIAL_CHECKED_YES_CHOICE (13u)

#define CAN_AS_DASH_AUX_SWA_COMMANDED_STEERING_MODE_STEERING_RATE_CONTROL_CHOICE (0u)
#define CAN_AS_DASH_AUX_SWA_COMMANDED_STEERING_MODE_STEERING_ANGLE_CONTROL_CHOICE (13u)

#define CAN_AS_DASH_AUX_SWA_COMMANDED_STEERING_RATE_DIRECTION_COUNTER_CLOCKWISE_CHOICE (0u)
#define CAN_AS_DASH_AUX_SWA_COMMANDED_STEERING_RATE_DIRECTION_CLOCKWISE_CHOICE (1u)

#define CAN_AS_DASH_AUX_SWA_COMMANDED_STEERING_RATE_IS_ZERO_FALSE_CHOICE (0u)
#define CAN_AS_DASH_AUX_SWA_COMMANDED_STEERING_RATE_IS_ZERO_TRUE_CHOICE (13u)

/**
 * Signals in message DASH_APPS.
 *
 * APPS Raw Values
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_apps_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps1_raw;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps2_raw;
};

/**
 * Signals in message DASH_BRAKE.
 *
 * Brake Raw Value
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_brake_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_raw;
};

/**
 * Signals in message DASH_BUTTONS.
 *
 * Dashboard Buttons and Toggles
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_buttons_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_toggle;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t second_toggle;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t third_toggle_notused;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t start;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ad_act;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t green_tsal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_state;
};

/**
 * Signals in message DASH_FRONT_HALL.
 *
 * Front Hall Effect Sensors
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_front_hall_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t hall_fl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t hall_fr;
};

/**
 * Signals in message AUX_REAR_HALL.
 *
 * Rear Hall Effect Sensors
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_rear_hall_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t hall_rl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t hall_rr;
};

/**
 * Signals in message AUX_TSAL_SAFE_STATE.
 *
 * TSAL Safe State
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_tsal_safe_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t safe_state;
};

/**
 * Signals in message AUX_PUMPS_FANS.
 *
 * Pumps & Fans Signals
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_pumps_fans_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_pump_signal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_pump_signal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t accu_fans_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_fans_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_fans_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t accu_fans;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_fans;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_fans;
};

/**
 * Signals in message AUX_BRAKELIGHT.
 *
 * Brake Light
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_brakelight_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brakelight;
};

/**
 * Signals in message DASH_LEDS.
 *
 * LEDs to Dashboard
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_dash_leds_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan_pwm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t buzzer;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t safe_state_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_out;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sensor_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_software;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pl_active;
};

/**
 * Signals in message AUX_TANK_PRESSURE.
 *
 * EBS Tank Pressure Raw Value
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_aux_tank_pressure_t {
    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ebs_pressure_raw;
};

/**
 * Signals in message AMI_SELECTED_MISSION.
 *
 * AMI Rotary Switch Position
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_ami_selected_mission_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ami_mission;
};

/**
 * Signals in message APU_STATE_MISSION.
 *
 * Selected Mission, AS State
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_apu_state_mission_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t as_mission;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;
};

/**
 * Signals in message SWA_ACTUAL.
 *
 * Steering Actuation Wheel Actual Position
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_swa_actual_t {
    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_actual;
};

/**
 * Signals in message EBS_SUPERVISOR.
 *
 * ASMS State, SDC State, EBS Activated, EBS Armed, EBS LED, K2 State
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_ebs_supervisor_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t asms_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsms_out;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t k2_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_engaged;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_armed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_led;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t initial_checked;
};

/**
 * Signals in message EBS_SERVICE_BRAKE.
 *
 * Service Brake Percentage
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_ebs_service_brake_t {
    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t servo_commanded_percentage;
};

/**
 * Signals in message SWA_COMMANDED.
 *
 * Steering commands
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_swa_commanded_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_rate_direction;

    /**
     * This should be in the field [820,3173] (see steering mapping excel)
     * No need to fill in case of steering rate control
     *
     * Range: 820..3173 (820..3173 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_angle_commanded;

    /**
     * This should be in the field [941,94100], which corresponds to [318.81, 3.18] RPM on the stepper accordingly.
     * No need to fill in case of steering angle control
     *
     * Range: 941..94100 (941..94100 Step period (uS))
     * Scale: 1
     * Offset: 0
     */
    uint32_t steering_rate_commanded;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_rate_is_zero;
};

/**
 * Signals in message APU_COMMAND.
 *
 * Throttle/Brake Commands
 *
 * All signal values are as on the CAN bus.
 */
struct can_as_dash_aux_apu_command_t {
    /**
     * Throttle/Brake command [-1,1]
     *
     * Range: -1..1 (-1..1 -)
     * Scale: 1
     * Offset: 0
     */
    float throttle_brake_commanded;
};

/**
 * Pack message DASH_APPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_apps_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_apps_t *src_p,
    size_t size);

/**
 * Unpack message DASH_APPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_apps_unpack(
    struct can_as_dash_aux_dash_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_dash_apps_apps1_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_apps_apps1_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_apps_apps1_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_dash_apps_apps2_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_apps_apps2_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_apps_apps2_raw_is_in_range(uint16_t value);

/**
 * Pack message DASH_BRAKE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_brake_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_brake_t *src_p,
    size_t size);

/**
 * Unpack message DASH_BRAKE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_brake_unpack(
    struct can_as_dash_aux_dash_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_dash_brake_brake_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_brake_brake_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_brake_brake_raw_is_in_range(uint16_t value);

/**
 * Pack message DASH_BUTTONS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_buttons_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_buttons_t *src_p,
    size_t size);

/**
 * Unpack message DASH_BUTTONS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_buttons_unpack(
    struct can_as_dash_aux_dash_buttons_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_buttons_enable_toggle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_buttons_enable_toggle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_buttons_enable_toggle_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_buttons_second_toggle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_buttons_second_toggle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_buttons_second_toggle_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_buttons_third_toggle_notused_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_buttons_third_toggle_notused_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_buttons_third_toggle_notused_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_buttons_start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_buttons_start_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_buttons_start_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_buttons_ad_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_buttons_ad_act_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_buttons_ad_act_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_buttons_green_tsal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_buttons_green_tsal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_buttons_green_tsal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_buttons_sc_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_buttons_sc_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_buttons_sc_state_is_in_range(uint8_t value);

/**
 * Pack message DASH_FRONT_HALL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_front_hall_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_front_hall_t *src_p,
    size_t size);

/**
 * Unpack message DASH_FRONT_HALL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_front_hall_unpack(
    struct can_as_dash_aux_dash_front_hall_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_as_dash_aux_dash_front_hall_hall_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_front_hall_hall_fl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_front_hall_hall_fl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_dash_front_hall_hall_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_front_hall_hall_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_front_hall_hall_fr_is_in_range(uint16_t value);

/**
 * Pack message AUX_REAR_HALL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_rear_hall_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_rear_hall_t *src_p,
    size_t size);

/**
 * Unpack message AUX_REAR_HALL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_rear_hall_unpack(
    struct can_as_dash_aux_aux_rear_hall_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_as_dash_aux_aux_rear_hall_hall_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_rear_hall_hall_rl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_rear_hall_hall_rl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_as_dash_aux_aux_rear_hall_hall_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_rear_hall_hall_rr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_rear_hall_hall_rr_is_in_range(uint32_t value);

/**
 * Pack message AUX_TSAL_SAFE_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_tsal_safe_state_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_tsal_safe_state_t *src_p,
    size_t size);

/**
 * Unpack message AUX_TSAL_SAFE_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_tsal_safe_state_unpack(
    struct can_as_dash_aux_aux_tsal_safe_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_tsal_safe_state_safe_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_tsal_safe_state_safe_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_tsal_safe_state_safe_state_is_in_range(uint8_t value);

/**
 * Pack message AUX_PUMPS_FANS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_pumps_fans_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_pumps_fans_t *src_p,
    size_t size);

/**
 * Unpack message AUX_PUMPS_FANS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_pumps_fans_unpack(
    struct can_as_dash_aux_aux_pumps_fans_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_pumps_fans_left_pump_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_pumps_fans_left_pump_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_pumps_fans_left_pump_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_pumps_fans_right_pump_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_pumps_fans_right_pump_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_pumps_fans_right_pump_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_pumps_fans_accu_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_pumps_fans_accu_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_pumps_fans_accu_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_pumps_fans_left_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_pumps_fans_left_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_pumps_fans_left_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_pumps_fans_right_fans_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_pumps_fans_right_fans_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_pumps_fans_right_fans_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_pumps_fans_accu_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_pumps_fans_accu_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_pumps_fans_accu_fans_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_pumps_fans_left_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_pumps_fans_left_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_pumps_fans_left_fans_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_pumps_fans_right_fans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_pumps_fans_right_fans_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_pumps_fans_right_fans_is_in_range(uint8_t value);

/**
 * Pack message AUX_BRAKELIGHT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_brakelight_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_brakelight_t *src_p,
    size_t size);

/**
 * Unpack message AUX_BRAKELIGHT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_brakelight_unpack(
    struct can_as_dash_aux_aux_brakelight_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_aux_brakelight_brakelight_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_brakelight_brakelight_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_brakelight_brakelight_is_in_range(uint8_t value);

/**
 * Pack message DASH_LEDS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_dash_leds_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_leds_t *src_p,
    size_t size);

/**
 * Unpack message DASH_LEDS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_dash_leds_unpack(
    struct can_as_dash_aux_dash_leds_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_leds_fan_pwm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_leds_fan_pwm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_leds_fan_pwm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_leds_buzzer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_leds_buzzer_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_leds_buzzer_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_leds_safe_state_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_leds_safe_state_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_leds_safe_state_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_leds_enable_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_leds_enable_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_leds_enable_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_leds_sensor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_leds_sensor_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_leds_sensor_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_leds_sc_software_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_leds_sc_software_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_leds_sc_software_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_dash_leds_pl_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_dash_leds_pl_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_dash_leds_pl_active_is_in_range(uint8_t value);

/**
 * Pack message AUX_TANK_PRESSURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_aux_tank_pressure_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_tank_pressure_t *src_p,
    size_t size);

/**
 * Unpack message AUX_TANK_PRESSURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_aux_tank_pressure_unpack(
    struct can_as_dash_aux_aux_tank_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_aux_tank_pressure_ebs_pressure_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_aux_tank_pressure_ebs_pressure_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_aux_tank_pressure_ebs_pressure_raw_is_in_range(uint16_t value);

/**
 * Pack message AMI_SELECTED_MISSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_ami_selected_mission_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ami_selected_mission_t *src_p,
    size_t size);

/**
 * Unpack message AMI_SELECTED_MISSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_ami_selected_mission_unpack(
    struct can_as_dash_aux_ami_selected_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_as_dash_aux_ami_selected_mission_ami_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ami_selected_mission_ami_mission_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ami_selected_mission_ami_mission_is_in_range(int8_t value);

/**
 * Pack message APU_STATE_MISSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_apu_state_mission_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_apu_state_mission_t *src_p,
    size_t size);

/**
 * Unpack message APU_STATE_MISSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_apu_state_mission_unpack(
    struct can_as_dash_aux_apu_state_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can_as_dash_aux_apu_state_mission_as_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_apu_state_mission_as_mission_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_apu_state_mission_as_mission_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_apu_state_mission_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_apu_state_mission_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_apu_state_mission_as_state_is_in_range(uint8_t value);

/**
 * Pack message SWA_ACTUAL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_swa_actual_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_swa_actual_t *src_p,
    size_t size);

/**
 * Unpack message SWA_ACTUAL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_swa_actual_unpack(
    struct can_as_dash_aux_swa_actual_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_swa_actual_steering_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_swa_actual_steering_actual_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_swa_actual_steering_actual_is_in_range(uint16_t value);

/**
 * Pack message EBS_SUPERVISOR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_ebs_supervisor_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ebs_supervisor_t *src_p,
    size_t size);

/**
 * Unpack message EBS_SUPERVISOR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_ebs_supervisor_unpack(
    struct can_as_dash_aux_ebs_supervisor_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_supervisor_asms_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_supervisor_asms_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_supervisor_asms_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_supervisor_tsms_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_supervisor_tsms_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_supervisor_tsms_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_supervisor_k2_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_supervisor_k2_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_supervisor_k2_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_supervisor_ebs_engaged_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_supervisor_ebs_engaged_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_supervisor_ebs_engaged_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_supervisor_ebs_armed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_supervisor_ebs_armed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_supervisor_ebs_armed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_supervisor_ebs_led_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_supervisor_ebs_led_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_supervisor_ebs_led_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_supervisor_service_brake_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_supervisor_service_brake_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_supervisor_service_brake_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_supervisor_initial_checked_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_supervisor_initial_checked_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_supervisor_initial_checked_is_in_range(uint8_t value);

/**
 * Pack message EBS_SERVICE_BRAKE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_ebs_service_brake_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ebs_service_brake_t *src_p,
    size_t size);

/**
 * Unpack message EBS_SERVICE_BRAKE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_ebs_service_brake_unpack(
    struct can_as_dash_aux_ebs_service_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_ebs_service_brake_servo_commanded_percentage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_ebs_service_brake_servo_commanded_percentage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_ebs_service_brake_servo_commanded_percentage_is_in_range(uint8_t value);

/**
 * Pack message SWA_COMMANDED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_swa_commanded_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_swa_commanded_t *src_p,
    size_t size);

/**
 * Unpack message SWA_COMMANDED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_swa_commanded_unpack(
    struct can_as_dash_aux_swa_commanded_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_swa_commanded_steering_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_swa_commanded_steering_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_swa_commanded_steering_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_swa_commanded_steering_rate_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_swa_commanded_steering_rate_direction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_swa_commanded_steering_rate_direction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_as_dash_aux_swa_commanded_steering_angle_commanded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_swa_commanded_steering_angle_commanded_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_swa_commanded_steering_angle_commanded_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_as_dash_aux_swa_commanded_steering_rate_commanded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_swa_commanded_steering_rate_commanded_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_swa_commanded_steering_rate_commanded_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_as_dash_aux_swa_commanded_steering_rate_is_zero_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_swa_commanded_steering_rate_is_zero_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_swa_commanded_steering_rate_is_zero_is_in_range(uint8_t value);

/**
 * Pack message APU_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_as_dash_aux_apu_command_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_apu_command_t *src_p,
    size_t size);

/**
 * Unpack message APU_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_as_dash_aux_apu_command_unpack(
    struct can_as_dash_aux_apu_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float can_as_dash_aux_apu_command_throttle_brake_commanded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_as_dash_aux_apu_command_throttle_brake_commanded_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_as_dash_aux_apu_command_throttle_brake_commanded_is_in_range(float value);


#ifdef __cplusplus
}
#endif

#endif
