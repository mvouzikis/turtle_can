/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.2.0 Thu May 27 22:35:51 2021.
 */

#include <string.h>

#include "can_as_dash_aux.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int can_as_dash_aux_dash_apps_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_apps_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_right_shift_u16(src_p->apps1_raw, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->apps1_raw, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->apps2_raw, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->apps2_raw, 0u, 0xffu);

    return (4);
}

int can_as_dash_aux_dash_apps_unpack(
    struct can_as_dash_aux_dash_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->apps1_raw = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->apps1_raw |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->apps2_raw = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->apps2_raw |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);

    return (0);
}

uint16_t can_as_dash_aux_dash_apps_apps1_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_dash_apps_apps1_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_apps_apps1_raw_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_as_dash_aux_dash_apps_apps2_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_dash_apps_apps2_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_apps_apps2_raw_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_dash_brake_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_brake_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_right_shift_u16(src_p->brake_raw, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->brake_raw, 0u, 0xffu);

    return (2);
}

int can_as_dash_aux_dash_brake_unpack(
    struct can_as_dash_aux_dash_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->brake_raw = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->brake_raw |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);

    return (0);
}

uint16_t can_as_dash_aux_dash_brake_brake_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_dash_brake_brake_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_brake_brake_raw_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_dash_buttons_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_buttons_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->enable_toggle, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->second_toggle, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->third_toggle_notused, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->start, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->ad_act, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->green_tsal, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->sc_state, 0u, 0xffu);

    return (7);
}

int can_as_dash_aux_dash_buttons_unpack(
    struct can_as_dash_aux_dash_buttons_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    dst_p->enable_toggle = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->second_toggle = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->third_toggle_notused = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->start = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->ad_act = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->green_tsal = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->sc_state = unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

uint8_t can_as_dash_aux_dash_buttons_enable_toggle_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_buttons_enable_toggle_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_buttons_enable_toggle_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_dash_buttons_second_toggle_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_buttons_second_toggle_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_buttons_second_toggle_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_dash_buttons_third_toggle_notused_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_buttons_third_toggle_notused_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_buttons_third_toggle_notused_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_dash_buttons_start_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_buttons_start_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_buttons_start_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_dash_buttons_ad_act_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_buttons_ad_act_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_buttons_ad_act_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_dash_buttons_green_tsal_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_buttons_green_tsal_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_buttons_green_tsal_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_dash_buttons_sc_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_buttons_sc_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_buttons_sc_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_dash_front_hall_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_front_hall_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_right_shift_u16(src_p->rpm_fl, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->rpm_fl, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->rpm_fr, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->rpm_fr, 0u, 0xffu);

    return (4);
}

int can_as_dash_aux_dash_front_hall_unpack(
    struct can_as_dash_aux_dash_front_hall_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->rpm_fl = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->rpm_fl |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->rpm_fr = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->rpm_fr |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);

    return (0);
}

uint16_t can_as_dash_aux_dash_front_hall_rpm_fl_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_dash_front_hall_rpm_fl_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_front_hall_rpm_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_as_dash_aux_dash_front_hall_rpm_fr_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_dash_front_hall_rpm_fr_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_front_hall_rpm_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_aux_rear_hall_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_rear_hall_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u32(src_p->hall_rl, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->hall_rl, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->hall_rl, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->hall_rl, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->hall_rr, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->hall_rr, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->hall_rr, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(src_p->hall_rr, 0u, 0xffu);

    return (8);
}

int can_as_dash_aux_aux_rear_hall_unpack(
    struct can_as_dash_aux_aux_rear_hall_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->hall_rl = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->hall_rl |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->hall_rl |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->hall_rl |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->hall_rr = unpack_left_shift_u32(src_p[4], 24u, 0xffu);
    dst_p->hall_rr |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    dst_p->hall_rr |= unpack_left_shift_u32(src_p[6], 8u, 0xffu);
    dst_p->hall_rr |= unpack_right_shift_u32(src_p[7], 0u, 0xffu);

    return (0);
}

uint32_t can_as_dash_aux_aux_rear_hall_hall_rl_encode(double value)
{
    return (uint32_t)(value);
}

double can_as_dash_aux_aux_rear_hall_hall_rl_decode(uint32_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_rear_hall_hall_rl_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t can_as_dash_aux_aux_rear_hall_hall_rr_encode(double value)
{
    return (uint32_t)(value);
}

double can_as_dash_aux_aux_rear_hall_hall_rr_decode(uint32_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_rear_hall_hall_rr_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_aux_tsal_safe_state_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_tsal_safe_state_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->safe_state, 0u, 0xffu);

    return (1);
}

int can_as_dash_aux_aux_tsal_safe_state_unpack(
    struct can_as_dash_aux_aux_tsal_safe_state_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->safe_state = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_as_dash_aux_aux_tsal_safe_state_safe_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_tsal_safe_state_safe_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_tsal_safe_state_safe_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_aux_pumps_fans_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_pumps_fans_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->left_pump_signal, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->right_pump_signal, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->accu_fans_pwm, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->left_fans_pwm, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->right_fans_pwm, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->accu_fans, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->left_fans, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->right_fans, 0u, 0xffu);

    return (8);
}

int can_as_dash_aux_aux_pumps_fans_unpack(
    struct can_as_dash_aux_aux_pumps_fans_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->left_pump_signal = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->right_pump_signal = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->accu_fans_pwm = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->left_fans_pwm = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->right_fans_pwm = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->accu_fans = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->left_fans = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->right_fans = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

uint8_t can_as_dash_aux_aux_pumps_fans_left_pump_signal_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_pumps_fans_left_pump_signal_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_pumps_fans_left_pump_signal_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_aux_pumps_fans_right_pump_signal_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_pumps_fans_right_pump_signal_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_pumps_fans_right_pump_signal_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_aux_pumps_fans_accu_fans_pwm_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_pumps_fans_accu_fans_pwm_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_pumps_fans_accu_fans_pwm_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_aux_pumps_fans_left_fans_pwm_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_pumps_fans_left_fans_pwm_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_pumps_fans_left_fans_pwm_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_aux_pumps_fans_right_fans_pwm_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_pumps_fans_right_fans_pwm_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_pumps_fans_right_fans_pwm_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_aux_pumps_fans_accu_fans_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_pumps_fans_accu_fans_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_pumps_fans_accu_fans_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_aux_pumps_fans_left_fans_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_pumps_fans_left_fans_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_pumps_fans_left_fans_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_aux_pumps_fans_right_fans_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_pumps_fans_right_fans_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_pumps_fans_right_fans_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_aux_brakelight_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_aux_brakelight_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->brakelight, 0u, 0xffu);

    return (1);
}

int can_as_dash_aux_aux_brakelight_unpack(
    struct can_as_dash_aux_aux_brakelight_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->brakelight = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_as_dash_aux_aux_brakelight_brakelight_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_aux_brakelight_brakelight_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_aux_brakelight_brakelight_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_dash_leds_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_dash_leds_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->fan_pwm, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->buzzer, 4u, 0xf0u);
    dst_p[1] |= pack_left_shift_u8(src_p->safe_state_1, 0u, 0x0fu);
    dst_p[2] |= pack_left_shift_u8(src_p->enable_out, 4u, 0xf0u);
    dst_p[2] |= pack_left_shift_u8(src_p->ebs_led, 0u, 0x0fu);
    dst_p[3] |= pack_left_shift_u8(src_p->sc_software, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->pl_active, 0u, 0xffu);

    return (5);
}

int can_as_dash_aux_dash_leds_unpack(
    struct can_as_dash_aux_dash_leds_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->fan_pwm = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->buzzer = unpack_right_shift_u8(src_p[1], 4u, 0xf0u);
    dst_p->safe_state_1 = unpack_right_shift_u8(src_p[1], 0u, 0x0fu);
    dst_p->enable_out = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    dst_p->ebs_led = unpack_right_shift_u8(src_p[2], 0u, 0x0fu);
    dst_p->sc_software = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->pl_active = unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

uint8_t can_as_dash_aux_dash_leds_fan_pwm_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_leds_fan_pwm_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_leds_fan_pwm_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_dash_leds_buzzer_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_leds_buzzer_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_leds_buzzer_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_dash_leds_safe_state_1_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_leds_safe_state_1_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_leds_safe_state_1_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_dash_leds_enable_out_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_leds_enable_out_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_leds_enable_out_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_dash_leds_ebs_led_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_leds_ebs_led_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_leds_ebs_led_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_dash_leds_sc_software_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_leds_sc_software_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_leds_sc_software_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_dash_leds_pl_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_dash_leds_pl_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_dash_leds_pl_active_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_ebs_tank_pressure_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ebs_tank_pressure_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_right_shift_u16(src_p->ebs_pressure_raw, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->ebs_pressure_raw, 0u, 0xffu);

    return (2);
}

int can_as_dash_aux_ebs_tank_pressure_unpack(
    struct can_as_dash_aux_ebs_tank_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->ebs_pressure_raw = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->ebs_pressure_raw |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);

    return (0);
}

uint16_t can_as_dash_aux_ebs_tank_pressure_ebs_pressure_raw_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_ebs_tank_pressure_ebs_pressure_raw_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_tank_pressure_ebs_pressure_raw_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

int can_as_dash_aux_ami_selected_mission_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ami_selected_mission_t *src_p,
    size_t size)
{
    uint8_t ami_mission;

    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    ami_mission = (uint8_t)src_p->ami_mission;
    dst_p[0] |= pack_left_shift_u8(ami_mission, 0u, 0xffu);

    return (1);
}

int can_as_dash_aux_ami_selected_mission_unpack(
    struct can_as_dash_aux_ami_selected_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t ami_mission;

    if (size < 1u) {
        return (-EINVAL);
    }

    ami_mission = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->ami_mission = (int8_t)ami_mission;

    return (0);
}

int8_t can_as_dash_aux_ami_selected_mission_ami_mission_encode(double value)
{
    return (int8_t)(value);
}

double can_as_dash_aux_ami_selected_mission_ami_mission_decode(int8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ami_selected_mission_ami_mission_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_apu_state_mission_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_apu_state_mission_t *src_p,
    size_t size)
{
    uint8_t as_mission;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    as_mission = (uint8_t)src_p->as_mission;
    dst_p[0] |= pack_left_shift_u8(as_mission, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->as_state, 0u, 0xffu);

    return (2);
}

int can_as_dash_aux_apu_state_mission_unpack(
    struct can_as_dash_aux_apu_state_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t as_mission;

    if (size < 2u) {
        return (-EINVAL);
    }

    as_mission = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->as_mission = (int8_t)as_mission;
    dst_p->as_state = unpack_right_shift_u8(src_p[1], 0u, 0xffu);

    return (0);
}

int8_t can_as_dash_aux_apu_state_mission_as_mission_encode(double value)
{
    return (int8_t)(value);
}

double can_as_dash_aux_apu_state_mission_as_mission_decode(int8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_apu_state_mission_as_mission_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_apu_state_mission_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_apu_state_mission_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_apu_state_mission_as_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_swa_status_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_swa_status_t *src_p,
    size_t size)
{
    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u16(src_p->steering_actual, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->steering_actual, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->analog1_error, 0u, 0x01u);
    dst_p[2] |= pack_left_shift_u8(src_p->analog2_error, 1u, 0x02u);
    dst_p[2] |= pack_left_shift_u8(src_p->stall_occurred, 2u, 0x04u);

    return (3);
}

int can_as_dash_aux_swa_status_unpack(
    struct can_as_dash_aux_swa_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 3u) {
        return (-EINVAL);
    }

    dst_p->steering_actual = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->steering_actual |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->analog1_error = unpack_right_shift_u8(src_p[2], 0u, 0x01u);
    dst_p->analog2_error = unpack_right_shift_u8(src_p[2], 1u, 0x02u);
    dst_p->stall_occurred = unpack_right_shift_u8(src_p[2], 2u, 0x04u);

    return (0);
}

uint16_t can_as_dash_aux_swa_status_steering_actual_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_swa_status_steering_actual_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_status_steering_actual_is_in_range(uint16_t value)
{
    return (value <= 4095u);
}

uint8_t can_as_dash_aux_swa_status_analog1_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_swa_status_analog1_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_status_analog1_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_as_dash_aux_swa_status_analog2_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_swa_status_analog2_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_status_analog2_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_as_dash_aux_swa_status_stall_occurred_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_swa_status_stall_occurred_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_status_stall_occurred_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_as_dash_aux_ebs_supervisor_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ebs_supervisor_t *src_p,
    size_t size)
{
    uint8_t initial_check_stage;

    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->asms_state, 0u, 0x0fu);
    dst_p[0] |= pack_left_shift_u8(src_p->tsms_out, 4u, 0xf0u);
    dst_p[1] |= pack_left_shift_u8(src_p->ebs_status, 0u, 0x0fu);
    dst_p[1] |= pack_left_shift_u8(src_p->ebs_led, 4u, 0xf0u);
    dst_p[2] |= pack_left_shift_u8(src_p->service_brake_status, 0u, 0x0fu);
    dst_p[2] |= pack_left_shift_u8(src_p->initial_checked, 4u, 0xf0u);
    initial_check_stage = (uint8_t)src_p->initial_check_stage;
    dst_p[3] |= pack_left_shift_u8(initial_check_stage, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->monitor_tank_pressure, 0u, 0x03u);
    dst_p[4] |= pack_left_shift_u8(src_p->monitor_brake_pressure, 2u, 0x0cu);
    dst_p[4] |= pack_left_shift_u8(src_p->monitor_servo_check, 4u, 0x30u);
    dst_p[4] |= pack_left_shift_u8(src_p->monitor_apu, 6u, 0xc0u);

    return (5);
}

int can_as_dash_aux_ebs_supervisor_unpack(
    struct can_as_dash_aux_ebs_supervisor_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t initial_check_stage;

    if (size < 5u) {
        return (-EINVAL);
    }

    dst_p->asms_state = unpack_right_shift_u8(src_p[0], 0u, 0x0fu);
    dst_p->tsms_out = unpack_right_shift_u8(src_p[0], 4u, 0xf0u);
    dst_p->ebs_status = unpack_right_shift_u8(src_p[1], 0u, 0x0fu);
    dst_p->ebs_led = unpack_right_shift_u8(src_p[1], 4u, 0xf0u);
    dst_p->service_brake_status = unpack_right_shift_u8(src_p[2], 0u, 0x0fu);
    dst_p->initial_checked = unpack_right_shift_u8(src_p[2], 4u, 0xf0u);
    initial_check_stage = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->initial_check_stage = (int8_t)initial_check_stage;
    dst_p->monitor_tank_pressure = unpack_right_shift_u8(src_p[4], 0u, 0x03u);
    dst_p->monitor_brake_pressure = unpack_right_shift_u8(src_p[4], 2u, 0x0cu);
    dst_p->monitor_servo_check = unpack_right_shift_u8(src_p[4], 4u, 0x30u);
    dst_p->monitor_apu = unpack_right_shift_u8(src_p[4], 6u, 0xc0u);

    return (0);
}

uint8_t can_as_dash_aux_ebs_supervisor_asms_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_asms_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_asms_state_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_ebs_supervisor_tsms_out_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_tsms_out_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_tsms_out_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_ebs_supervisor_ebs_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_ebs_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_ebs_status_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_ebs_supervisor_ebs_led_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_ebs_led_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_ebs_led_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_ebs_supervisor_service_brake_status_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_service_brake_status_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_service_brake_status_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_as_dash_aux_ebs_supervisor_initial_checked_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_initial_checked_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_initial_checked_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

int8_t can_as_dash_aux_ebs_supervisor_initial_check_stage_encode(double value)
{
    return (int8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_initial_check_stage_decode(int8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_initial_check_stage_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_ebs_supervisor_monitor_tank_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_monitor_tank_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_monitor_tank_pressure_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_as_dash_aux_ebs_supervisor_monitor_brake_pressure_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_monitor_brake_pressure_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_monitor_brake_pressure_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_as_dash_aux_ebs_supervisor_monitor_servo_check_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_monitor_servo_check_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_monitor_servo_check_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_as_dash_aux_ebs_supervisor_monitor_apu_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_supervisor_monitor_apu_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_supervisor_monitor_apu_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int can_as_dash_aux_ebs_service_brake_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ebs_service_brake_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->servo_commanded_percentage, 0u, 0xffu);

    return (1);
}

int can_as_dash_aux_ebs_service_brake_unpack(
    struct can_as_dash_aux_ebs_service_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->servo_commanded_percentage = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t can_as_dash_aux_ebs_service_brake_servo_commanded_percentage_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ebs_service_brake_servo_commanded_percentage_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ebs_service_brake_servo_commanded_percentage_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

int can_as_dash_aux_swa_commanded_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_swa_commanded_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u16(src_p->steering_angle_commanded, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->steering_angle_commanded, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(src_p->steering_rate_commanded, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->steering_rate_commanded, 8u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->steering_rate_commanded, 16u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->steering_mode, 0u, 0x01u);
    dst_p[5] |= pack_left_shift_u8(src_p->steering_rate_direction, 1u, 0x02u);
    dst_p[5] |= pack_left_shift_u8(src_p->steering_rate_is_zero, 2u, 0x04u);

    return (6);
}

int can_as_dash_aux_swa_commanded_unpack(
    struct can_as_dash_aux_swa_commanded_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->steering_angle_commanded = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->steering_angle_commanded |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->steering_rate_commanded = unpack_right_shift_u32(src_p[2], 0u, 0xffu);
    dst_p->steering_rate_commanded |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    dst_p->steering_rate_commanded |= unpack_left_shift_u32(src_p[4], 16u, 0xffu);
    dst_p->steering_mode = unpack_right_shift_u8(src_p[5], 0u, 0x01u);
    dst_p->steering_rate_direction = unpack_right_shift_u8(src_p[5], 1u, 0x02u);
    dst_p->steering_rate_is_zero = unpack_right_shift_u8(src_p[5], 2u, 0x04u);

    return (0);
}

uint16_t can_as_dash_aux_swa_commanded_steering_angle_commanded_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_swa_commanded_steering_angle_commanded_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_commanded_steering_angle_commanded_is_in_range(uint16_t value)
{
    return ((value >= 920u) && (value <= 3110u));
}

uint32_t can_as_dash_aux_swa_commanded_steering_rate_commanded_encode(double value)
{
    return (uint32_t)(value);
}

double can_as_dash_aux_swa_commanded_steering_rate_commanded_decode(uint32_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_commanded_steering_rate_commanded_is_in_range(uint32_t value)
{
    return ((value >= 941u) && (value <= 94100u));
}

uint8_t can_as_dash_aux_swa_commanded_steering_mode_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_swa_commanded_steering_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_commanded_steering_mode_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_as_dash_aux_swa_commanded_steering_rate_direction_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_swa_commanded_steering_rate_direction_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_commanded_steering_rate_direction_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_as_dash_aux_swa_commanded_steering_rate_is_zero_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_swa_commanded_steering_rate_is_zero_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_swa_commanded_steering_rate_is_zero_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_as_dash_aux_apu_command_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_apu_command_t *src_p,
    size_t size)
{
    uint32_t throttle_brake_commanded;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&throttle_brake_commanded, &src_p->throttle_brake_commanded, sizeof(throttle_brake_commanded));
    dst_p[0] |= pack_left_shift_u32(throttle_brake_commanded, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(throttle_brake_commanded, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(throttle_brake_commanded, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(throttle_brake_commanded, 24u, 0xffu);

    return (4);
}

int can_as_dash_aux_apu_command_unpack(
    struct can_as_dash_aux_apu_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t throttle_brake_commanded;

    if (size < 4u) {
        return (-EINVAL);
    }

    throttle_brake_commanded = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    throttle_brake_commanded |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->throttle_brake_commanded, &throttle_brake_commanded, sizeof(dst_p->throttle_brake_commanded));

    return (0);
}

float can_as_dash_aux_apu_command_throttle_brake_commanded_encode(double value)
{
    return (float)(value);
}

double can_as_dash_aux_apu_command_throttle_brake_commanded_decode(float value)
{
    return ((double)value);
}

bool can_as_dash_aux_apu_command_throttle_brake_commanded_is_in_range(float value)
{
    return ((value >= -1.0f) && (value <= 1.0f));
}

int can_as_dash_aux_inv_resolvers_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_inv_resolvers_t *src_p,
    size_t size)
{
    uint16_t commanded_torque_left;
    uint16_t commanded_torque_right;
    uint16_t motor_rpm_left;
    uint16_t motor_rpm_right;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    motor_rpm_left = (uint16_t)src_p->motor_rpm_left;
    dst_p[0] |= pack_left_shift_u16(motor_rpm_left, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(motor_rpm_left, 8u, 0xffu);
    motor_rpm_right = (uint16_t)src_p->motor_rpm_right;
    dst_p[2] |= pack_left_shift_u16(motor_rpm_right, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(motor_rpm_right, 8u, 0xffu);
    commanded_torque_left = (uint16_t)src_p->commanded_torque_left;
    dst_p[4] |= pack_left_shift_u16(commanded_torque_left, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(commanded_torque_left, 8u, 0xffu);
    commanded_torque_right = (uint16_t)src_p->commanded_torque_right;
    dst_p[6] |= pack_left_shift_u16(commanded_torque_right, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(commanded_torque_right, 8u, 0xffu);

    return (8);
}

int can_as_dash_aux_inv_resolvers_unpack(
    struct can_as_dash_aux_inv_resolvers_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t commanded_torque_left;
    uint16_t commanded_torque_right;
    uint16_t motor_rpm_left;
    uint16_t motor_rpm_right;

    if (size < 8u) {
        return (-EINVAL);
    }

    motor_rpm_left = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    motor_rpm_left |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->motor_rpm_left = (int16_t)motor_rpm_left;
    motor_rpm_right = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    motor_rpm_right |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->motor_rpm_right = (int16_t)motor_rpm_right;
    commanded_torque_left = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    commanded_torque_left |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->commanded_torque_left = (int16_t)commanded_torque_left;
    commanded_torque_right = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    commanded_torque_right |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->commanded_torque_right = (int16_t)commanded_torque_right;

    return (0);
}

int16_t can_as_dash_aux_inv_resolvers_motor_rpm_left_encode(double value)
{
    return (int16_t)(value);
}

double can_as_dash_aux_inv_resolvers_motor_rpm_left_decode(int16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_inv_resolvers_motor_rpm_left_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_as_dash_aux_inv_resolvers_motor_rpm_right_encode(double value)
{
    return (int16_t)(value);
}

double can_as_dash_aux_inv_resolvers_motor_rpm_right_decode(int16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_inv_resolvers_motor_rpm_right_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_as_dash_aux_inv_resolvers_commanded_torque_left_encode(double value)
{
    return (int16_t)(value);
}

double can_as_dash_aux_inv_resolvers_commanded_torque_left_decode(int16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_inv_resolvers_commanded_torque_left_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_as_dash_aux_inv_resolvers_commanded_torque_right_encode(double value)
{
    return (int16_t)(value);
}

double can_as_dash_aux_inv_resolvers_commanded_torque_right_decode(int16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_inv_resolvers_commanded_torque_right_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_ecu_parameters_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ecu_parameters_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->inverter_rpm_max, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->inverter_rpm_max, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->inverter_i_max, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->inverter_i_max, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->power_target_kw, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->ed2_gain, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->ed2_gain, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->i_rms_max_charging_factor, 0u, 0xffu);

    return (8);
}

int can_as_dash_aux_ecu_parameters_unpack(
    struct can_as_dash_aux_ecu_parameters_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->inverter_rpm_max = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->inverter_rpm_max |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->inverter_i_max = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->inverter_i_max |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->power_target_kw = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->ed2_gain = unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->ed2_gain |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->i_rms_max_charging_factor = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

uint16_t can_as_dash_aux_ecu_parameters_inverter_rpm_max_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_ecu_parameters_inverter_rpm_max_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_parameters_inverter_rpm_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_as_dash_aux_ecu_parameters_inverter_i_max_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_ecu_parameters_inverter_i_max_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_parameters_inverter_i_max_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_ecu_parameters_power_target_kw_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ecu_parameters_power_target_kw_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_parameters_power_target_kw_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t can_as_dash_aux_ecu_parameters_ed2_gain_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_ecu_parameters_ed2_gain_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_parameters_ed2_gain_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_ecu_parameters_i_rms_max_charging_factor_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ecu_parameters_i_rms_max_charging_factor_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_parameters_i_rms_max_charging_factor_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_as_dash_aux_ecu_params_actual_pack(
    uint8_t *dst_p,
    const struct can_as_dash_aux_ecu_params_actual_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->inverter_rpm_max_mean, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->inverter_rpm_max_mean, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->inverter_i_max_mean, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->inverter_i_max_mean, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->power_target_k_w_actual, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->ed2_gain_actual, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->ed2_gain_actual, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->i_rms_max_charging_factor_actual, 0u, 0xffu);

    return (8);
}

int can_as_dash_aux_ecu_params_actual_unpack(
    struct can_as_dash_aux_ecu_params_actual_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->inverter_rpm_max_mean = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->inverter_rpm_max_mean |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->inverter_i_max_mean = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->inverter_i_max_mean |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->power_target_k_w_actual = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->ed2_gain_actual = unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->ed2_gain_actual |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->i_rms_max_charging_factor_actual = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

uint16_t can_as_dash_aux_ecu_params_actual_inverter_rpm_max_mean_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_ecu_params_actual_inverter_rpm_max_mean_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_params_actual_inverter_rpm_max_mean_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_as_dash_aux_ecu_params_actual_inverter_i_max_mean_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_ecu_params_actual_inverter_i_max_mean_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_params_actual_inverter_i_max_mean_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_ecu_params_actual_power_target_k_w_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ecu_params_actual_power_target_k_w_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_params_actual_power_target_k_w_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t can_as_dash_aux_ecu_params_actual_ed2_gain_actual_encode(double value)
{
    return (uint16_t)(value);
}

double can_as_dash_aux_ecu_params_actual_ed2_gain_actual_decode(uint16_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_params_actual_ed2_gain_actual_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t can_as_dash_aux_ecu_params_actual_i_rms_max_charging_factor_actual_encode(double value)
{
    return (uint8_t)(value);
}

double can_as_dash_aux_ecu_params_actual_i_rms_max_charging_factor_actual_decode(uint8_t value)
{
    return ((double)value);
}

bool can_as_dash_aux_ecu_params_actual_i_rms_max_charging_factor_actual_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}
